var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
import { app, BrowserWindow, ipcMain, dialog, Menu, shell } from "electron";
import fs, { promises, existsSync } from "fs";
import path, { join } from "path";
import require$$0 from "util";
import require$$1$1 from "stream";
import require$$1$2 from "zlib";
import require$$0$1 from "assert";
import require$$3 from "buffer";
import { fileURLToPath } from "url";
function $constructor(name, initializer2, params) {
  function init(inst, def) {
    var _a;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name);
    initializer2(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = (params == null ? void 0 : params.Parent) ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a;
    const inst = (params == null ? void 0 : params.Parent) ? new Definition() : this;
    init(inst, def);
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      var _a, _b;
      if ((params == null ? void 0 : params.Parent) && inst instanceof params.Parent)
        return true;
      return (_b = (_a = inst == null ? void 0 : inst._zod) == null ? void 0 : _a.traits) == null ? void 0 : _b.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
class $ZodAsyncError extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}
class $ZodEncodeError extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
}
const globalConfig = {};
function config(newConfig) {
  return globalConfig;
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  return {
    get value() {
      {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder$g(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match == null ? void 0 : match[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
const EVALUATING = Symbol("evaluating");
function defineLazy(object2, key, getter) {
  let value = void 0;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function esc(str) {
  return JSON.stringify(str);
}
const captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
const allowsEval = cached(() => {
  var _a;
  if (typeof navigator !== "undefined" && ((_a = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a.includes("Cloudflare"))) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  return o;
}
const propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone$1(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || (params == null ? void 0 : params.parent))
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if ((params == null ? void 0 : params.message) !== void 0) {
    if ((params == null ? void 0 : params.error) !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
const NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone$1(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone$1(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  });
  return clone$1(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: schema._zod.def.checks
  };
  return clone$1(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone$1(a, def);
}
function partial(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone$1(schema, def);
}
function required(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone$1(schema, def);
}
function aborted(x2, startIndex = 0) {
  var _a;
  if (x2.aborted === true)
    return true;
  for (let i = startIndex; i < x2.issues.length; i++) {
    if (((_a = x2.issues[i]) == null ? void 0 : _a.continue) !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path2, issues) {
  return issues.map((iss) => {
    var _a;
    (_a = iss).path ?? (_a.path = []);
    iss.path.unshift(path2);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message == null ? void 0 : message.message;
}
function finalizeIssue(iss, ctx, config2) {
  var _a, _b, _c, _d, _e, _f;
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage((_c = (_b = (_a = iss.inst) == null ? void 0 : _a._zod.def) == null ? void 0 : _b.error) == null ? void 0 : _c.call(_b, iss)) ?? unwrapMessage((_d = ctx == null ? void 0 : ctx.error) == null ? void 0 : _d.call(ctx, iss)) ?? unwrapMessage((_e = config2.customError) == null ? void 0 : _e.call(config2, iss)) ?? unwrapMessage((_f = config2.localeError) == null ? void 0 : _f.call(config2, iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!(ctx == null ? void 0 : ctx.reportInput)) {
    delete full.input;
  }
  return full;
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
const initializer$1 = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
const $ZodError = $constructor("$ZodError", initializer$1);
const $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
function flattenError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error2) => {
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error);
  return fieldErrors;
}
const _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new ((_params == null ? void 0 : _params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params == null ? void 0 : _params.callee);
    throw e;
  }
  return result.value;
};
const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new ((params == null ? void 0 : params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params == null ? void 0 : params.callee);
    throw e;
  }
  return result.value;
};
const _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
const safeParse$1 = /* @__PURE__ */ _safeParse($ZodRealError);
const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
const safeParseAsync$1 = /* @__PURE__ */ _safeParseAsync($ZodRealError);
const _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
const _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
const _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
const _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
const _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
const _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
const _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
const _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};
const cuid = /^[cC][^\s-]{8,}$/;
const cuid2 = /^[0-9a-z]+$/;
const ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
const xid = /^[0-9a-vA-V]{20}$/;
const ksuid = /^[A-Za-z0-9]{27}$/;
const nanoid = /^[a-zA-Z0-9_-]{21}$/;
const duration$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
const guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
const uuid = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
const email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
const _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji$1, "u");
}
const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
const cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
const cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
const base64url = /^[A-Za-z0-9_-]*$/;
const hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
const e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
const date$3 = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time$1(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime$1(args) {
  const time2 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex2 = `${time2}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex2})$`);
}
const string$1 = (params) => {
  const regex = params ? `[\\s\\S]{${(params == null ? void 0 : params.minimum) ?? 0},${(params == null ? void 0 : params.maximum) ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
const integer = /^\d+$/;
const number$1 = /^-?\d+(?:\.\d+)?/i;
const lowercase = /^[^A-Z]*$/;
const uppercase = /^[^a-z]*$/;
const $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a = inst._zod).onattach ?? (_a.onattach = []);
});
const numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
const $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a;
    (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder$g(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = (_a = def.format) == null ? void 0 : _a.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
const $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a = inst._zod).check ?? (_a.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
const $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});
class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x2) => x2);
    const minIndent = Math.min(...lines.map((x2) => x2.length - x2.trimStart().length));
    const dedented = lines.map((x2) => x2.slice(minIndent)).map((x2) => " ".repeat(this.indent * 2) + x2);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this == null ? void 0 : this.args;
    const content = (this == null ? void 0 : this.content) ?? [``];
    const lines = [...content.map((x2) => `  ${x2}`)];
    return new F(...args, lines.join("\n"));
  }
}
const version = {
  major: 4,
  minor: 1,
  patch: 1
};
const $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a2;
  var _a;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    (_a2 = inst._zod.deferred) == null ? void 0 : _a2.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted2 = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted2) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && (ctx == null ? void 0 : ctx.async) === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted2)
              isAborted2 = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted2)
            isAborted2 = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      var _a3;
      try {
        const r = safeParse$1(inst, value);
        return r.success ? { value: r.data } : { issues: (_a3 = r.error) == null ? void 0 : _a3.issues };
      } catch (_) {
        return safeParseAsync$1(inst, value).then((r) => {
          var _a4;
          return r.success ? { value: r.data } : { issues: (_a4 = r.error) == null ? void 0 : _a4.issues };
        });
      }
    },
    vendor: "zod",
    version: 1
  };
});
const $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  var _a;
  $ZodType.init(inst, def);
  inst._zod.pattern = [...((_a = inst == null ? void 0 : inst._zod.bag) == null ? void 0 : _a.patterns) ?? []].pop() ?? string$1(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
const $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
const $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
const $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
const $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
const $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
const $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
const $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
const $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
const $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
const $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
const $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
const $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
const $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime$1(def));
  $ZodStringFormat.init(inst, def);
});
const $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date$3);
  $ZodStringFormat.init(inst, def);
});
const $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time$1(def));
  $ZodStringFormat.init(inst, def);
});
const $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration$1);
  $ZodStringFormat.init(inst, def);
});
const $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
const $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
const $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
const $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const [address, prefix] = payload.value.split("/");
    try {
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
const $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c2) => c2 === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
const $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT$g(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && (parsedHeader == null ? void 0 : parsedHeader.typ) !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
const $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT$g(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number$1;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
const $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
const $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
const $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
const $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape[k]._zod.traits.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  for (const key of Object.keys(input)) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
    } else {
      handlePropertyResult(r, payload, key, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
const $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject$1 = isObject;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject$1(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
      } else {
        handlePropertyResult(r, payload, key, input);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
const $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {}`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc(key);
      doc.write(`const ${id} = ${parseStr(key)};`);
      doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
      `);
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject$1 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval$1 = allowsEval;
  const fastEnabled = jit && allowsEval$1.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject$1(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && (ctx == null ? void 0 : ctx.async) === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
const $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
const $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues$g(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$g(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$g(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues$g(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
const $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
const $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
const $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
const $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
const $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x2) => x2 !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
const $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
const $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
const $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
const $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
class $ZodRegistry {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry();
}
const globalRegistry = /* @__PURE__ */ registry();
function _string(Class, params) {
  return new Class({
    type: "string",
    ...normalizeParams(params)
  });
}
function _email(Class, params) {
  return new Class({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class, params) {
  return new Class({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class, params) {
  return new Class({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji(Class, params) {
  return new Class({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class, params) {
  return new Class({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class, params) {
  return new Class({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class, params) {
  return new Class({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class, params) {
  return new Class({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class, params) {
  return new Class({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class, params) {
  return new Class({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class, params) {
  return new Class({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class, params) {
  return new Class({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class, params) {
  return new Class({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class, params) {
  return new Class({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class, params) {
  return new Class({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class, params) {
  return new Class({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class, params) {
  return new Class({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class, params) {
  return new Class({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _isoDateTime(Class, params) {
  return new Class({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class, params) {
  return new Class({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class, params) {
  return new Class({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class, params) {
  return new Class({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class, params) {
  return new Class({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class, params) {
  return new Class({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _unknown(Class) {
  return new Class({
    type: "unknown"
  });
}
function _never(Class, params) {
  return new Class({
    type: "never",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class, element, params) {
  return new Class({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _refine(Class, fn, _params) {
  const schema = new Class({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _superRefine(fn) {
  const ch = _check$1((payload) => {
    payload.addIssue = (issue$1) => {
      if (typeof issue$1 === "string") {
        payload.issues.push(issue(issue$1, payload.value, ch._zod.def));
      } else {
        const _issue = issue$1;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check$1(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
const ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime(params) {
  return _isoDateTime(ZodISODateTime, params);
}
const ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date$2(params) {
  return _isoDate(ZodISODate, params);
}
const ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time(params) {
  return _isoTime(ZodISOTime, params);
}
const ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration(params) {
  return _isoDuration(ZodISODuration, params);
}
const initializer = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
const ZodRealError = $constructor("ZodError", initializer, {
  Parent: Error
});
const parse$1 = /* @__PURE__ */ _parse(ZodRealError);
const parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
const safeParse = /* @__PURE__ */ _safeParse(ZodRealError);
const safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);
const encode$3 = /* @__PURE__ */ _encode(ZodRealError);
const decode$3 = /* @__PURE__ */ _decode(ZodRealError);
const encodeAsync = /* @__PURE__ */ _encodeAsync(ZodRealError);
const decodeAsync = /* @__PURE__ */ _decodeAsync(ZodRealError);
const safeEncode = /* @__PURE__ */ _safeEncode(ZodRealError);
const safeDecode = /* @__PURE__ */ _safeDecode(ZodRealError);
const safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
const safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);
const ZodType$g = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(
      {
        ...def,
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }
      // { parent: true }
    );
  };
  inst.clone = (def2, params) => clone$1(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data, params) => parse$1(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode$3(inst, data, params);
  inst.decode = (data, params) => decode$3(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync(inst, data, params);
  inst.refine = (check, params) => inst.check(refine(check, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      var _a;
      return (_a = globalRegistry.get(inst)) == null ? void 0 : _a.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
const _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType$g.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
const ZodString$g = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime(params));
  inst.date = (params) => inst.check(date$2(params));
  inst.time = (params) => inst.check(time(params));
  inst.duration = (params) => inst.check(duration(params));
});
function string(params) {
  return _string(ZodString$g, params);
}
const ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
const ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodNumber$g = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType$g.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number(params) {
  return _number(ZodNumber$g, params);
}
const ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber$g.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
const ZodUnknown$g = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType$g.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown$g);
}
const ZodNever$g = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType$g.init(inst, def);
});
function never(params) {
  return _never(ZodNever$g, params);
}
const ZodArray$g = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType$g.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray$g, element, params);
}
const ZodObject$g = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType$g.init(inst, def);
  defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return safeExtend(inst, incoming);
  };
  inst.merge = (other) => merge(inst, other);
  inst.pick = (mask) => pick(inst, mask);
  inst.omit = (mask) => omit(inst, mask);
  inst.partial = (...args) => partial(ZodOptional$g, inst, args[0]);
  inst.required = (...args) => required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    get shape() {
      assignProp(this, "shape", shape ? objectClone(shape) : {});
      return this.shape;
    },
    ...normalizeParams(params)
  };
  return new ZodObject$g(def);
}
const ZodUnion$g = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType$g.init(inst, def);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion$g({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
const ZodIntersection$g = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType$g.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection$g({
    type: "intersection",
    left,
    right
  });
}
const ZodEnum$g = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType$g.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum$g({
      ...def,
      checks: [],
      ...normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum$g({
      ...def,
      checks: [],
      ...normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum$g({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
const ZodLiteral$g = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType$g.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral$g({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
const ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType$g.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue$1) => {
      if (typeof issue$1 === "string") {
        payload.issues.push(issue(issue$1, payload.value, def));
      } else {
        const _issue = issue$1;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
const ZodOptional$g = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType$g.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional$g({
    type: "optional",
    innerType
  });
}
const ZodNullable$g = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType$g.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable$g({
    type: "nullable",
    innerType
  });
}
const ZodDefault$g = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType$g.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
  return new ZodDefault$g({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
const ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType$g.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
const ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType$g.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
const ZodCatch$g = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType$g.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
  return new ZodCatch$g({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
const ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType$g.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
const ZodReadonly$g = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType$g.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly$g({
    type: "readonly",
    innerType
  });
}
const ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType$g.init(inst, def);
});
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
const ItemType = _enum([
  "Bed",
  "DiningChair",
  "DiningTable",
  "FloorLamp",
  "Free",
  "Plant",
  "Wall",
  "Material"
]);
const Item = object({
  assetId: string().min(1),
  name: string().min(1),
  type: ItemType,
  vendorPrice: number().nonnegative().default(0),
  tags: array(string()).default([]),
  thumbnailPath: string().default("")
});
const Recipe = object({
  id: string().min(1),
  resultAssetId: string().min(1),
  ingredients: array(
    object({ assetId: string().min(1), qty: number().int().positive() })
  )
});
const Project = object({
  version: literal(1),
  items: array(Item),
  recipes: array(Recipe)
});
function ensureProject(projectDir) {
  const f = path.join(projectDir, "db.json");
  if (!fs.existsSync(projectDir)) fs.mkdirSync(projectDir, { recursive: true });
  if (!fs.existsSync(f))
    fs.writeFileSync(f, JSON.stringify({ version: 1, items: [], recipes: [] }));
  const thumbs = path.join(projectDir, "assets", "thumbnails");
  if (!fs.existsSync(thumbs)) fs.mkdirSync(thumbs, { recursive: true });
  return f;
}
function loadProject(projectDir) {
  const f = ensureProject(projectDir);
  const raw = fs.readFileSync(f, "utf8");
  return Project.parse(JSON.parse(raw));
}
function saveProject(projectDir, data) {
  const f = ensureProject(projectDir);
  fs.writeFileSync(f, JSON.stringify(data));
}
function projectThumbsDir(projectDir) {
  return path.join(projectDir, "assets", "thumbnails");
}
var HeaderTypes;
(function(HeaderTypes2) {
  HeaderTypes2[HeaderTypes2["BITMAP_INFO_HEADER"] = 40] = "BITMAP_INFO_HEADER";
  HeaderTypes2[HeaderTypes2["BITMAP_V2_INFO_HEADER"] = 52] = "BITMAP_V2_INFO_HEADER";
  HeaderTypes2[HeaderTypes2["BITMAP_V3_INFO_HEADER"] = 56] = "BITMAP_V3_INFO_HEADER";
  HeaderTypes2[HeaderTypes2["BITMAP_V4_HEADER"] = 108] = "BITMAP_V4_HEADER";
  HeaderTypes2[HeaderTypes2["BITMAP_V5_HEADER"] = 124] = "BITMAP_V5_HEADER";
})(HeaderTypes || (HeaderTypes = {}));
function maskColor(maskRed, maskGreen, maskBlue, maskAlpha) {
  const maskRedR = ~maskRed + 1 & maskRed;
  const maskGreenR = ~maskGreen + 1 & maskGreen;
  const maskBlueR = ~maskBlue + 1 & maskBlue;
  const maskAlphaR = ~maskAlpha + 1 & maskAlpha;
  const shiftedMaskRedL = maskRed / maskRedR + 1;
  const shiftedMaskGreenL = maskGreen / maskGreenR + 1;
  const shiftedMaskBlueL = maskBlue / maskBlueR + 1;
  const shiftedMaskAlphaL = maskAlpha / maskAlphaR + 1;
  return {
    shiftRed: (x2) => (x2 & maskRed) / maskRedR * 256 / shiftedMaskRedL,
    shiftGreen: (x2) => (x2 & maskGreen) / maskGreenR * 256 / shiftedMaskGreenL,
    shiftBlue: (x2) => (x2 & maskBlue) / maskBlueR * 256 / shiftedMaskBlueL,
    shiftAlpha: maskAlpha !== 0 ? (x2) => (x2 & maskAlpha) / maskAlphaR * 256 / shiftedMaskAlphaL : () => 255
  };
}
var BmpCompression;
(function(BmpCompression2) {
  BmpCompression2[BmpCompression2["NONE"] = 0] = "NONE";
  BmpCompression2[BmpCompression2["BI_RLE8"] = 1] = "BI_RLE8";
  BmpCompression2[BmpCompression2["BI_RLE4"] = 2] = "BI_RLE4";
  BmpCompression2[BmpCompression2["BI_BIT_FIELDS"] = 3] = "BI_BIT_FIELDS";
  BmpCompression2[BmpCompression2["BI_ALPHA_BIT_FIELDS"] = 6] = "BI_ALPHA_BIT_FIELDS";
})(BmpCompression || (BmpCompression = {}));
class BmpDecoder {
  constructor(buffer, { toRGBA } = { toRGBA: false }) {
    // Header
    __publicField2(this, "flag");
    __publicField2(this, "fileSize");
    __publicField2(this, "reserved1");
    __publicField2(this, "reserved2");
    __publicField2(this, "offset");
    __publicField2(this, "headerSize");
    __publicField2(this, "width");
    __publicField2(this, "height");
    __publicField2(this, "planes");
    __publicField2(this, "bitPP");
    __publicField2(this, "compression");
    __publicField2(this, "rawSize");
    __publicField2(this, "hr");
    __publicField2(this, "vr");
    __publicField2(this, "colors");
    __publicField2(this, "importantColors");
    __publicField2(this, "palette");
    __publicField2(this, "data");
    __publicField2(this, "maskRed");
    __publicField2(this, "maskGreen");
    __publicField2(this, "maskBlue");
    __publicField2(this, "maskAlpha");
    __publicField2(this, "toRGBA");
    __publicField2(this, "pos");
    __publicField2(this, "bottomUp");
    __publicField2(this, "buffer");
    __publicField2(this, "locRed");
    __publicField2(this, "locGreen");
    __publicField2(this, "locBlue");
    __publicField2(this, "locAlpha");
    __publicField2(this, "shiftRed");
    __publicField2(this, "shiftGreen");
    __publicField2(this, "shiftBlue");
    __publicField2(this, "shiftAlpha");
    this.buffer = buffer;
    this.toRGBA = !!toRGBA;
    this.pos = 0;
    this.bottomUp = true;
    this.flag = this.buffer.toString("utf-8", 0, this.pos += 2);
    if (this.flag !== "BM") {
      throw new Error("Invalid BMP File");
    }
    this.locRed = this.toRGBA ? 0 : 3;
    this.locGreen = this.toRGBA ? 1 : 2;
    this.locBlue = this.toRGBA ? 2 : 1;
    this.locAlpha = this.toRGBA ? 3 : 0;
    this.parseHeader();
    this.parseRGBA();
  }
  parseHeader() {
    this.fileSize = this.readUInt32LE();
    this.reserved1 = this.buffer.readUInt16LE(this.pos);
    this.pos += 2;
    this.reserved2 = this.buffer.readUInt16LE(this.pos);
    this.pos += 2;
    this.offset = this.readUInt32LE();
    this.headerSize = this.readUInt32LE();
    if (!(this.headerSize in HeaderTypes)) {
      throw new Error(`Unsupported BMP header size ${this.headerSize}`);
    }
    this.width = this.readUInt32LE();
    this.height = this.readUInt32LE();
    this.height = this.height > 2147483647 ? this.height - 4294967296 : this.height;
    this.planes = this.buffer.readUInt16LE(this.pos);
    this.pos += 2;
    this.bitPP = this.buffer.readUInt16LE(this.pos);
    this.pos += 2;
    this.compression = this.readUInt32LE();
    this.rawSize = this.readUInt32LE();
    this.hr = this.readUInt32LE();
    this.vr = this.readUInt32LE();
    this.colors = this.readUInt32LE();
    this.importantColors = this.readUInt32LE();
    if (this.bitPP === 32) {
      this.maskAlpha = 0;
      this.maskRed = 16711680;
      this.maskGreen = 65280;
      this.maskBlue = 255;
    } else if (this.bitPP === 16) {
      this.maskAlpha = 0;
      this.maskRed = 31744;
      this.maskGreen = 992;
      this.maskBlue = 31;
    }
    if (this.headerSize > HeaderTypes.BITMAP_INFO_HEADER || this.compression === BmpCompression.BI_BIT_FIELDS || this.compression === BmpCompression.BI_ALPHA_BIT_FIELDS) {
      this.maskRed = this.readUInt32LE();
      this.maskGreen = this.readUInt32LE();
      this.maskBlue = this.readUInt32LE();
    }
    if (this.headerSize > HeaderTypes.BITMAP_V2_INFO_HEADER || this.compression === BmpCompression.BI_ALPHA_BIT_FIELDS) {
      this.maskAlpha = this.readUInt32LE();
    }
    if (this.headerSize > HeaderTypes.BITMAP_V3_INFO_HEADER) {
      this.pos += HeaderTypes.BITMAP_V4_HEADER - HeaderTypes.BITMAP_V3_INFO_HEADER;
    }
    if (this.headerSize > HeaderTypes.BITMAP_V4_HEADER) {
      this.pos += HeaderTypes.BITMAP_V5_HEADER - HeaderTypes.BITMAP_V4_HEADER;
    }
    if (this.bitPP <= 8 || this.colors > 0) {
      const len = this.colors === 0 ? 1 << this.bitPP : this.colors;
      this.palette = new Array(len);
      for (let i = 0; i < len; i++) {
        const blue = this.buffer.readUInt8(this.pos++);
        const green = this.buffer.readUInt8(this.pos++);
        const red = this.buffer.readUInt8(this.pos++);
        const quad = this.buffer.readUInt8(this.pos++);
        this.palette[i] = {
          red,
          green,
          blue,
          quad
        };
      }
    }
    if (this.height < 0) {
      this.height *= -1;
      this.bottomUp = false;
    }
    const coloShift = maskColor(this.maskRed, this.maskGreen, this.maskBlue, this.maskAlpha);
    this.shiftRed = coloShift.shiftRed;
    this.shiftGreen = coloShift.shiftGreen;
    this.shiftBlue = coloShift.shiftBlue;
    this.shiftAlpha = coloShift.shiftAlpha;
  }
  parseRGBA() {
    this.data = Buffer.alloc(this.width * this.height * 4);
    switch (this.bitPP) {
      case 1:
        this.bit1();
        break;
      case 4:
        this.bit4();
        break;
      case 8:
        this.bit8();
        break;
      case 16:
        this.bit16();
        break;
      case 24:
        this.bit24();
        break;
      default:
        this.bit32();
    }
  }
  bit1() {
    const xLen = Math.ceil(this.width / 8);
    const mode = xLen % 4;
    const padding = mode !== 0 ? 4 - mode : 0;
    this.scanImage(padding, xLen, (x2, line) => {
      const b = this.buffer.readUInt8(this.pos++);
      const location = line * this.width * 4 + x2 * 8 * 4;
      for (let i = 0; i < 8; i++) {
        if (x2 * 8 + i < this.width) {
          const rgb = this.palette[b >> 7 - i & 1];
          this.data[location + i * this.locAlpha] = 0;
          this.data[location + i * 4 + this.locBlue] = rgb.blue;
          this.data[location + i * 4 + this.locGreen] = rgb.green;
          this.data[location + i * 4 + this.locRed] = rgb.red;
        } else {
          break;
        }
      }
    });
  }
  bit4() {
    if (this.compression === BmpCompression.BI_RLE4) {
      this.data.fill(0);
      let lowNibble = false;
      let lines = this.bottomUp ? this.height - 1 : 0;
      let location = 0;
      while (location < this.data.length) {
        const a = this.buffer.readUInt8(this.pos++);
        const b = this.buffer.readUInt8(this.pos++);
        if (a === 0) {
          if (b === 0) {
            lines += this.bottomUp ? -1 : 1;
            location = lines * this.width * 4;
            lowNibble = false;
            continue;
          }
          if (b === 1) {
            break;
          }
          if (b === 2) {
            const x2 = this.buffer.readUInt8(this.pos++);
            const y2 = this.buffer.readUInt8(this.pos++);
            lines += this.bottomUp ? -y2 : y2;
            location += y2 * this.width * 4 + x2 * 4;
          } else {
            let c2 = this.buffer.readUInt8(this.pos++);
            for (let i = 0; i < b; i++) {
              location = this.setPixelData(location, lowNibble ? c2 & 15 : (c2 & 240) >> 4);
              if (i & 1 && i + 1 < b) {
                c2 = this.buffer.readUInt8(this.pos++);
              }
              lowNibble = !lowNibble;
            }
            if ((b + 1 >> 1 & 1) === 1) {
              this.pos++;
            }
          }
        } else {
          for (let i = 0; i < a; i++) {
            location = this.setPixelData(location, lowNibble ? b & 15 : (b & 240) >> 4);
            lowNibble = !lowNibble;
          }
        }
      }
    } else {
      const xLen = Math.ceil(this.width / 2);
      const mode = xLen % 4;
      const padding = mode !== 0 ? 4 - mode : 0;
      this.scanImage(padding, xLen, (x2, line) => {
        const b = this.buffer.readUInt8(this.pos++);
        const location = line * this.width * 4 + x2 * 2 * 4;
        const first4 = b >> 4;
        let rgb = this.palette[first4];
        this.data[location] = 0;
        this.data[location + 1] = rgb.blue;
        this.data[location + 2] = rgb.green;
        this.data[location + 3] = rgb.red;
        if (x2 * 2 + 1 >= this.width) {
          return false;
        }
        const last4 = b & 15;
        rgb = this.palette[last4];
        this.data[location + 4] = 0;
        this.data[location + 4 + 1] = rgb.blue;
        this.data[location + 4 + 2] = rgb.green;
        this.data[location + 4 + 3] = rgb.red;
      });
    }
  }
  bit8() {
    if (this.compression === BmpCompression.BI_RLE8) {
      this.data.fill(0);
      let lines = this.bottomUp ? this.height - 1 : 0;
      let location = 0;
      while (location < this.data.length) {
        const a = this.buffer.readUInt8(this.pos++);
        const b = this.buffer.readUInt8(this.pos++);
        if (a === 0) {
          if (b === 0) {
            lines += this.bottomUp ? -1 : 1;
            location = lines * this.width * 4;
            continue;
          }
          if (b === 1) {
            break;
          }
          if (b === 2) {
            const x2 = this.buffer.readUInt8(this.pos++);
            const y2 = this.buffer.readUInt8(this.pos++);
            lines += this.bottomUp ? -y2 : y2;
            location += y2 * this.width * 4 + x2 * 4;
          } else {
            for (let i = 0; i < b; i++) {
              const c2 = this.buffer.readUInt8(this.pos++);
              location = this.setPixelData(location, c2);
            }
            const shouldIncrement = b & true;
            if (shouldIncrement) {
              this.pos++;
            }
          }
        } else {
          for (let i = 0; i < a; i++) {
            location = this.setPixelData(location, b);
          }
        }
      }
    } else {
      const mode = this.width % 4;
      const padding = mode !== 0 ? 4 - mode : 0;
      this.scanImage(padding, this.width, (x2, line) => {
        const b = this.buffer.readUInt8(this.pos++);
        const location = line * this.width * 4 + x2 * 4;
        if (b < this.palette.length) {
          const rgb = this.palette[b];
          this.data[location] = 0;
          this.data[location + 1] = rgb.blue;
          this.data[location + 2] = rgb.green;
          this.data[location + 3] = rgb.red;
        } else {
          this.data[location] = 0;
          this.data[location + 1] = 255;
          this.data[location + 2] = 255;
          this.data[location + 3] = 255;
        }
      });
    }
  }
  bit16() {
    const padding = this.width % 2 * 2;
    this.scanImage(padding, this.width, (x2, line) => {
      const loc = line * this.width * 4 + x2 * 4;
      const px = this.buffer.readUInt16LE(this.pos);
      this.pos += 2;
      this.data[loc + this.locRed] = this.shiftRed(px);
      this.data[loc + this.locGreen] = this.shiftGreen(px);
      this.data[loc + this.locBlue] = this.shiftBlue(px);
      this.data[loc + this.locAlpha] = this.shiftAlpha(px);
    });
  }
  bit24() {
    const padding = this.width % 4;
    this.scanImage(padding, this.width, (x2, line) => {
      const loc = line * this.width * 4 + x2 * 4;
      const blue = this.buffer.readUInt8(this.pos++);
      const green = this.buffer.readUInt8(this.pos++);
      const red = this.buffer.readUInt8(this.pos++);
      this.data[loc + this.locRed] = red;
      this.data[loc + this.locGreen] = green;
      this.data[loc + this.locBlue] = blue;
      this.data[loc + this.locAlpha] = 0;
    });
  }
  bit32() {
    this.scanImage(0, this.width, (x2, line) => {
      const loc = line * this.width * 4 + x2 * 4;
      const px = this.readUInt32LE();
      this.data[loc + this.locRed] = this.shiftRed(px);
      this.data[loc + this.locGreen] = this.shiftGreen(px);
      this.data[loc + this.locBlue] = this.shiftBlue(px);
      this.data[loc + this.locAlpha] = this.shiftAlpha(px);
    });
  }
  scanImage(padding = 0, width = this.width, processPixel) {
    for (let y2 = this.height - 1; y2 >= 0; y2--) {
      const line = this.bottomUp ? y2 : this.height - 1 - y2;
      for (let x2 = 0; x2 < width; x2++) {
        const result = processPixel.call(this, x2, line);
        if (result === false) {
          return;
        }
      }
      this.pos += padding;
    }
  }
  readUInt32LE() {
    const value = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    return value;
  }
  setPixelData(location, rgbIndex) {
    const { blue, green, red } = this.palette[rgbIndex];
    this.data[location + this.locAlpha] = 0;
    this.data[location + 1 + this.locBlue] = blue;
    this.data[location + 2 + this.locGreen] = green;
    this.data[location + 3 + this.locRed] = red;
    return location + 4;
  }
}
function createInteger(numbers) {
  return numbers.reduce((final, n) => final << 1 | n, 0);
}
function createColor(color) {
  return color.quad << 24 | color.red << 16 | color.green << 8 | color.blue;
}
class BmpEncoder {
  constructor(imgData) {
    __publicField2(this, "fileSize");
    __publicField2(this, "reserved1");
    __publicField2(this, "reserved2");
    __publicField2(this, "offset");
    __publicField2(this, "width");
    __publicField2(this, "flag");
    __publicField2(this, "height");
    __publicField2(this, "planes");
    __publicField2(this, "bitPP");
    __publicField2(this, "compress");
    __publicField2(this, "hr");
    __publicField2(this, "vr");
    __publicField2(this, "colors");
    __publicField2(this, "importantColors");
    __publicField2(this, "rawSize");
    __publicField2(this, "headerSize");
    __publicField2(this, "data");
    __publicField2(this, "palette");
    __publicField2(this, "extraBytes");
    __publicField2(this, "buffer");
    __publicField2(this, "bytesInColor");
    __publicField2(this, "pos");
    this.buffer = imgData.data;
    this.width = imgData.width;
    this.height = imgData.height;
    this.headerSize = HeaderTypes.BITMAP_INFO_HEADER;
    this.flag = "BM";
    this.bitPP = imgData.bitPP || 24;
    this.offset = 54;
    this.reserved1 = imgData.reserved1 || 0;
    this.reserved2 = imgData.reserved2 || 0;
    this.planes = 1;
    this.compress = 0;
    this.hr = imgData.hr || 0;
    this.vr = imgData.vr || 0;
    this.importantColors = imgData.importantColors || 0;
    this.colors = Math.min(2 ** (this.bitPP - 1 || 1), imgData.colors || Infinity);
    this.palette = imgData.palette || [];
    if (this.colors && this.bitPP < 16) {
      this.offset += this.colors * 4;
    } else {
      this.colors = 0;
    }
    switch (this.bitPP) {
      case 32:
        this.bytesInColor = 4;
        break;
      case 16:
        this.bytesInColor = 2;
        break;
      case 8:
        this.bytesInColor = 1;
        break;
      case 4:
        this.bytesInColor = 1 / 2;
        break;
      case 1:
        this.bytesInColor = 1 / 8;
        break;
      default:
        this.bytesInColor = 3;
        this.bitPP = 24;
    }
    const rowWidth = this.width * this.bitPP / 32;
    const rowBytes = Math.ceil(rowWidth);
    this.extraBytes = (rowBytes - rowWidth) * 4;
    this.rawSize = this.height * rowBytes * 4 + 2;
    this.fileSize = this.rawSize + this.offset;
    this.data = Buffer.alloc(this.fileSize, 1);
    this.pos = 0;
    this.encode();
  }
  encode() {
    this.pos = 0;
    this.writeHeader();
    switch (this.bitPP) {
      case 32:
        this.bit32();
        break;
      case 16:
        this.bit16();
        break;
      case 8:
        this.bit8();
        break;
      case 4:
        this.bit4();
        break;
      case 1:
        this.bit1();
        break;
      default:
        this.bit24();
    }
  }
  writeHeader() {
    this.data.write(this.flag, this.pos, 2);
    this.pos += 2;
    this.writeUInt32LE(this.fileSize);
    this.writeUInt32LE(this.reserved1 << 16 | this.reserved2);
    this.writeUInt32LE(this.offset);
    this.writeUInt32LE(this.headerSize);
    this.writeUInt32LE(this.width);
    this.writeUInt32LE(this.height);
    this.data.writeUInt16LE(this.planes, this.pos);
    this.pos += 2;
    this.data.writeUInt16LE(this.bitPP, this.pos);
    this.pos += 2;
    this.writeUInt32LE(this.compress);
    this.writeUInt32LE(this.rawSize);
    this.writeUInt32LE(this.hr);
    this.writeUInt32LE(this.vr);
    this.writeUInt32LE(this.colors);
    this.writeUInt32LE(this.importantColors);
  }
  bit1() {
    if (this.palette.length && this.colors === 2) {
      this.initColors(1);
    } else {
      this.writeUInt32LE(16777215);
      this.writeUInt32LE(0);
    }
    this.pos += 1;
    let lineArr = [];
    this.writeImage((p, index, x2) => {
      let i = index;
      i++;
      const b = this.buffer[i++];
      const g = this.buffer[i++];
      const r = this.buffer[i++];
      const brightness = r * 0.2126 + g * 0.7152 + b * 0.0722;
      lineArr.push(brightness > 127 ? 0 : 1);
      if ((x2 + 1) % 8 === 0) {
        this.data[p - 1] = createInteger(lineArr);
        lineArr = [];
      } else if (x2 === this.width - 1 && lineArr.length > 0) {
        this.data[p - 1] = createInteger(lineArr) << 4;
        lineArr = [];
      }
      return i;
    });
  }
  bit4() {
    const colors = this.initColors(4);
    let integerPair = [];
    this.writeImage((p, index, x2) => {
      let i = index;
      const colorInt = createColor({
        quad: this.buffer[i++],
        blue: this.buffer[i++],
        green: this.buffer[i++],
        red: this.buffer[i++]
      });
      const colorExists = colors.findIndex((c2) => c2 === colorInt);
      if (colorExists !== -1) {
        integerPair.push(colorExists);
      } else {
        integerPair.push(0);
      }
      if ((x2 + 1) % 2 === 0) {
        this.data[p] = integerPair[0] << 4 | integerPair[1];
        integerPair = [];
      }
      return i;
    });
  }
  bit8() {
    const colors = this.initColors(8);
    this.writeImage((p, index) => {
      let i = index;
      const colorInt = createColor({
        quad: this.buffer[i++],
        blue: this.buffer[i++],
        green: this.buffer[i++],
        red: this.buffer[i++]
      });
      const colorExists = colors.findIndex((c2) => c2 === colorInt);
      if (colorExists !== -1) {
        this.data[p] = colorExists;
      } else {
        this.data[p] = 0;
      }
      return i;
    });
  }
  bit16() {
    this.writeImage((p, index) => {
      let i = index + 1;
      const b = this.buffer[i++] / 8;
      const g = this.buffer[i++] / 8;
      const r = this.buffer[i++] / 8;
      const color = r << 10 | g << 5 | b;
      this.data[p] = color & 255;
      this.data[p + 1] = (color & 65280) >> 8;
      return i;
    });
  }
  bit24() {
    this.writeImage((p, index) => {
      let i = index + 1;
      this.data[p] = this.buffer[i++];
      this.data[p + 1] = this.buffer[i++];
      this.data[p + 2] = this.buffer[i++];
      return i;
    });
  }
  bit32() {
    this.writeImage((p, index) => {
      let i = index;
      this.data[p + 3] = this.buffer[i++];
      this.data[p] = this.buffer[i++];
      this.data[p + 1] = this.buffer[i++];
      this.data[p + 2] = this.buffer[i++];
      return i;
    });
  }
  writeImage(writePixel) {
    const rowBytes = this.extraBytes + this.width * this.bytesInColor;
    let i = 0;
    for (let y2 = 0; y2 < this.height; y2++) {
      for (let x2 = 0; x2 < this.width; x2++) {
        const p = Math.floor(this.pos + (this.height - 1 - y2) * rowBytes + x2 * this.bytesInColor);
        i = writePixel.call(this, p, i, x2, y2);
      }
    }
  }
  initColors(bit) {
    const colors = [];
    if (this.palette.length) {
      for (let i = 0; i < this.colors; i++) {
        const rootColor = createColor(this.palette[i]);
        this.writeUInt32LE(rootColor);
        colors.push(rootColor);
      }
    } else {
      throw new Error(`To encode ${bit}-bit BMPs a pallette is needed. Please choose up to ${this.colors} colors. Colors must be 32-bit integers.`);
    }
    return colors;
  }
  writeUInt32LE(value) {
    this.data.writeUInt32LE(value, this.pos);
    this.pos += 4;
  }
}
function decode$2(bmpData, options) {
  return new BmpDecoder(bmpData, options);
}
function encode$2(imgData) {
  return new BmpEncoder(imgData);
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color, opts) {
  color = color ? color : "";
  opts = opts || {};
  if (color instanceof tinycolor) {
    return color;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color, opts);
  }
  var rgb = inputToRGB(color);
  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1) this._r = Math.round(this._r);
  if (this._g < 1) this._g = Math.round(this._g);
  if (this._b < 1) this._b = Math.round(this._b);
  this._ok = rgb.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid2() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  },
  getLuminance: function getLuminance() {
    var rgb = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R, G, B;
    RsRGB = rgb.r / 255;
    GsRGB = rgb.g / 255;
    BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) R = RsRGB / 12.92;
    else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928) G = GsRGB / 12.92;
    else G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928) B = BsRGB / 12.92;
    else B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h = Math.round(hsv.h * 360), s = Math.round(hsv.s * 100), v = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    var h = Math.round(hsl.h * 360), s = Math.round(hsl.s * 100), l = Math.round(hsl.l * 100);
    return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString(format) {
    var formatSet = !!format;
    format = format || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
    if (needsAlphaFormat) {
      if (format === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format === "hex" || format === "hex6") {
      formattedString = this.toHexString();
    }
    if (format === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format === "name") {
      formattedString = this.toName();
    }
    if (format === "hsl") {
      formattedString = this.toHslString();
    }
    if (format === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone2() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn, args) {
    var color = fn.apply(null, [this].concat([].slice.call(args)));
    this._r = color._r;
    this._g = color._g;
    this._b = color._b;
    this.setAlpha(color._a);
    return this;
  },
  lighten: function lighten2() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken2() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn, args) {
    return fn.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color, opts) {
  if (_typeof(color) == "object") {
    var newColor = {};
    for (var i in color) {
      if (color.hasOwnProperty(i)) {
        if (i === "a") {
          newColor[i] = color[i];
        } else {
          newColor[i] = convertToPercentage(color[i]);
        }
      }
    }
    color = newColor;
  }
  return tinycolor(color, opts);
};
function inputToRGB(color) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a = 1;
  var s = null;
  var v = null;
  var l = null;
  var ok = false;
  var format = false;
  if (typeof color == "string") {
    color = stringInputToObject(color);
  }
  if (_typeof(color) == "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s, v);
      ok = true;
      format = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s = convertToPercentage(color.s);
      l = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s, l);
      ok = true;
      format = "hsl";
    }
    if (color.hasOwnProperty("a")) {
      a = color.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok,
    format: color.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a
  };
}
function rgbToRgb(r, g, b) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
function rgbToHsl(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h, s, l = (max + min) / 2;
  if (max == min) {
    h = s = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h,
    s,
    l
  };
}
function hslToRgb(h, s, l) {
  var r, g, b;
  h = bound01(h, 360);
  s = bound01(s, 100);
  l = bound01(l, 100);
  function hue2rgb(p2, q2, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;
    if (t < 1 / 2) return q2;
    if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
    return p2;
  }
  if (s === 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}
function rgbToHsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h, s, v = max;
  var d = max - min;
  s = max === 0 ? 0 : d / max;
  if (max == min) {
    h = 0;
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h,
    s,
    v
  };
}
function hsvToRgb(h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  var i = Math.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6, r = [v, q, p, p, t, v][mod], g = [t, v, v, q, p, p][mod], b = [p, p, t, v, v, q][mod];
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}
function rgbToHex(r, g, b, allow3Char) {
  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r, g, b, a, allow4Char) {
  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];
  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function rgbaToArgbHex(r, g, b, a) {
  var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  return hex.join("");
}
tinycolor.equals = function(color1, color2) {
  if (!color1 || !color2) return false;
  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s -= amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _saturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s += amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _greyscale(color) {
  return tinycolor(color).desaturate(100);
}
function _lighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l += amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _brighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb = tinycolor(color).toRgb();
  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb);
}
function _darken(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l -= amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _spin(color, amount) {
  var hsl = tinycolor(color).toHsl();
  var hue = (hsl.h + amount) % 360;
  hsl.h = hue < 0 ? 360 + hue : hue;
  return tinycolor(hsl);
}
function _complement(color) {
  var hsl = tinycolor(color).toHsl();
  hsl.h = (hsl.h + 180) % 360;
  return tinycolor(hsl);
}
function polyad(color, number2) {
  if (isNaN(number2) || number2 <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl = tinycolor(color).toHsl();
  var result = [tinycolor(color)];
  var step = 360 / number2;
  for (var i = 1; i < number2; i++) {
    result.push(tinycolor({
      h: (hsl.h + i * step) % 360,
      s: hsl.s,
      l: hsl.l
    }));
  }
  return result;
}
function _splitcomplement(color) {
  var hsl = tinycolor(color).toHsl();
  var h = hsl.h;
  return [tinycolor(color), tinycolor({
    h: (h + 72) % 360,
    s: hsl.s,
    l: hsl.l
  }), tinycolor({
    h: (h + 216) % 360,
    s: hsl.s,
    l: hsl.l
  })];
}
function _analogous(color, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl = tinycolor(color).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color)];
  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
    hsl.h = (hsl.h + part) % 360;
    ret.push(tinycolor(hsl));
  }
  return ret;
}
function _monochromatic(color, results) {
  results = results || 6;
  var hsv = tinycolor(color).toHsv();
  var h = hsv.h, s = hsv.s, v = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h,
      s,
      v
    }));
    v = (v + modification) % 1;
  }
  return ret;
}
tinycolor.mix = function(color1, color2, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color2).toRgb();
  var p = amount / 100;
  var rgba = {
    r: (rgb2.r - rgb1.r) * p + rgb1.r,
    g: (rgb2.g - rgb1.g) * p + rgb1.g,
    b: (rgb2.b - rgb1.b) * p + rgb1.b,
    a: (rgb2.a - rgb1.a) * p + rgb1.a
  };
  return tinycolor(rgba);
};
tinycolor.readability = function(color1, color2) {
  var c1 = tinycolor(color1);
  var c2 = tinycolor(color2);
  return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color2, wcag2) {
  var readability = tinycolor.readability(color1, color2);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size = args.size;
  for (var i = 0; i < colorList.length; i++) {
    readability = tinycolor.readability(baseColor, colorList[i]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};
var names$1 = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip(names$1);
function flip(o) {
  var flipped = {};
  for (var i in o) {
    if (o.hasOwnProperty(i)) {
      flipped[o[i]] = i;
    }
  }
  return flipped;
}
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}
function bound01(n, max) {
  if (isOnePointZero(n)) n = "100%";
  var processPercent = isPercentage(n);
  n = Math.min(max, Math.max(0, parseFloat(n)));
  if (processPercent) {
    n = parseInt(n * max, 10) / 100;
  }
  if (Math.abs(n - max) < 1e-6) {
    return 1;
  }
  return n % max / parseFloat(max);
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function isOnePointZero(n) {
  return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
}
function isPercentage(n) {
  return typeof n === "string" && n.indexOf("%") != -1;
}
function pad2(c2) {
  return c2.length == 1 ? "0" + c2 : "" + c2;
}
function convertToPercentage(n) {
  if (n <= 1) {
    n = n * 100 + "%";
  }
  return n;
}
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
function convertHexToDecimal(h) {
  return parseIntFromHex(h) / 255;
}
var matchers = function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function isValidCSSUnit(color) {
  return !!matchers.CSS_UNIT.exec(color);
}
function stringInputToObject(color) {
  color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named = false;
  if (names$1[color]) {
    color = names$1[color];
    named = true;
  } else if (color == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match;
  if (match = matchers.rgb.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  var level, size;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size !== "small" && size !== "large") {
    size = "small";
  }
  return {
    level,
    size
  };
}
function clone(image) {
  const newBitmap = {
    width: image.bitmap.width,
    height: image.bitmap.height,
    data: Buffer.from(image.bitmap.data)
  };
  return new image.constructor(newBitmap);
}
function scan(image, xArg, yArg, wArg, hArg, cbArg) {
  let x2;
  let y2;
  let w;
  let h;
  let cb;
  if (typeof xArg === "function") {
    cb = xArg;
    x2 = 0;
    y2 = 0;
    w = image.bitmap.width;
    h = image.bitmap.height;
  } else {
    x2 = xArg;
    if (typeof yArg !== "number")
      throw new Error("y must be a number");
    y2 = yArg;
    if (typeof wArg !== "number")
      throw new Error("w must be a number");
    w = wArg;
    if (typeof hArg !== "number")
      throw new Error("h must be a number");
    h = hArg;
    if (typeof cbArg !== "function")
      throw new Error("cb must be a function");
    cb = cbArg;
  }
  x2 = Math.round(x2);
  y2 = Math.round(y2);
  w = Math.round(w);
  h = Math.round(h);
  const bound = cb.bind(image);
  for (let _y = y2; _y < y2 + h; _y++) {
    for (let _x = x2; _x < x2 + w; _x++) {
      const idx = image.bitmap.width * _y + _x << 2;
      bound(_x, _y, idx);
    }
  }
  return image;
}
function* scanIterator(image, x2, y2, w, h) {
  x2 = Math.round(x2);
  y2 = Math.round(y2);
  w = Math.round(w);
  h = Math.round(h);
  for (let _y = y2; _y < y2 + h; _y++) {
    for (let _x = x2; _x < x2 + w; _x++) {
      const idx = image.bitmap.width * _y + _x << 2;
      yield { x: _x, y: _y, idx, image };
    }
  }
}
function intToRGBA$1(i) {
  if (typeof i !== "number") {
    throw new Error("i must be a number");
  }
  const rgba = {
    r: 0,
    g: 0,
    b: 0,
    a: 0
  };
  rgba.r = Math.floor(i / Math.pow(256, 3));
  rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));
  rgba.b = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1));
  rgba.a = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0));
  return rgba;
}
function colorDiff(rgba1, rgba2) {
  const sq = (n) => Math.pow(n, 2);
  const { max } = Math;
  const maxVal = 255 * 255 * 3;
  const rgba1A = "a" in rgba1 ? rgba1.a : 255;
  const rgba2A = "a" in rgba2 ? rgba2.a : 255;
  return (max(sq(rgba1.r - rgba2.r), sq(rgba1.r - rgba2.r - rgba1A + rgba2A)) + max(sq(rgba1.g - rgba2.g), sq(rgba1.g - rgba2.g - rgba1A + rgba2A)) + max(sq(rgba1.b - rgba2.b), sq(rgba1.b - rgba2.b - rgba1A + rgba2A))) / maxVal;
}
function limit255(n) {
  n = Math.max(n, 0);
  n = Math.min(n, 255);
  return n;
}
function cssColorToHex(cssColor) {
  if (typeof cssColor === "number") {
    return cssColor;
  }
  return parseInt(tinycolor(cssColor).toHex8(), 16);
}
function encode$1(image, options = {}) {
  scan({ bitmap: image }, 0, 0, image.width, image.height, function(_, __, index) {
    const red = image.data[index + 0];
    const green = image.data[index + 1];
    const blue = image.data[index + 2];
    const alpha = image.data[index + 3];
    image.data[index + 0] = alpha;
    image.data[index + 1] = blue;
    image.data[index + 2] = green;
    image.data[index + 3] = red;
  });
  return encode$2({ ...image, ...options }).data;
}
function decode$1(data, options) {
  const result = decode$2(data, options);
  scan({ bitmap: result }, 0, 0, result.width, result.height, function(_, __, index) {
    const blue = result.data[index + 1];
    const green = result.data[index + 2];
    const red = result.data[index + 3];
    result.data[index + 0] = red;
    result.data[index + 1] = green;
    result.data[index + 2] = blue;
    result.data[index + 3] = 255;
  });
  return result;
}
function msBmp() {
  return {
    mime: "image/x-ms-bmp",
    encode: encode$1,
    decode: decode$1
  };
}
function bmp() {
  return {
    mime: "image/bmp",
    encode: encode$1,
    decode: decode$1
  };
}
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var omggif = {};
var GifReader_1;
var GifWriter_1;
function GifWriter(buf, width, height, gopts) {
  var p = 0;
  var gopts = gopts === void 0 ? {} : gopts;
  var loop_count = gopts.loop === void 0 ? null : gopts.loop;
  var global_palette = gopts.palette === void 0 ? null : gopts.palette;
  if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
    throw new Error("Width/Height invalid.");
  function check_palette_and_num_colors(palette) {
    var num_colors = palette.length;
    if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) {
      throw new Error(
        "Invalid code/color length, must be power of 2 and 2 .. 256."
      );
    }
    return num_colors;
  }
  buf[p++] = 71;
  buf[p++] = 73;
  buf[p++] = 70;
  buf[p++] = 56;
  buf[p++] = 57;
  buf[p++] = 97;
  var gp_num_colors_pow2 = 0;
  var background = 0;
  if (global_palette !== null) {
    var gp_num_colors = check_palette_and_num_colors(global_palette);
    while (gp_num_colors >>= 1) ++gp_num_colors_pow2;
    gp_num_colors = 1 << gp_num_colors_pow2;
    --gp_num_colors_pow2;
    if (gopts.background !== void 0) {
      background = gopts.background;
      if (background >= gp_num_colors)
        throw new Error("Background index out of range.");
      if (background === 0)
        throw new Error("Background index explicitly passed as 0.");
    }
  }
  buf[p++] = width & 255;
  buf[p++] = width >> 8 & 255;
  buf[p++] = height & 255;
  buf[p++] = height >> 8 & 255;
  buf[p++] = (global_palette !== null ? 128 : 0) | // Global Color Table Flag.
  gp_num_colors_pow2;
  buf[p++] = background;
  buf[p++] = 0;
  if (global_palette !== null) {
    for (var i = 0, il = global_palette.length; i < il; ++i) {
      var rgb = global_palette[i];
      buf[p++] = rgb >> 16 & 255;
      buf[p++] = rgb >> 8 & 255;
      buf[p++] = rgb & 255;
    }
  }
  if (loop_count !== null) {
    if (loop_count < 0 || loop_count > 65535)
      throw new Error("Loop count invalid.");
    buf[p++] = 33;
    buf[p++] = 255;
    buf[p++] = 11;
    buf[p++] = 78;
    buf[p++] = 69;
    buf[p++] = 84;
    buf[p++] = 83;
    buf[p++] = 67;
    buf[p++] = 65;
    buf[p++] = 80;
    buf[p++] = 69;
    buf[p++] = 50;
    buf[p++] = 46;
    buf[p++] = 48;
    buf[p++] = 3;
    buf[p++] = 1;
    buf[p++] = loop_count & 255;
    buf[p++] = loop_count >> 8 & 255;
    buf[p++] = 0;
  }
  var ended = false;
  this.addFrame = function(x2, y2, w, h, indexed_pixels, opts) {
    if (ended === true) {
      --p;
      ended = false;
    }
    opts = opts === void 0 ? {} : opts;
    if (x2 < 0 || y2 < 0 || x2 > 65535 || y2 > 65535)
      throw new Error("x/y invalid.");
    if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
      throw new Error("Width/Height invalid.");
    if (indexed_pixels.length < w * h)
      throw new Error("Not enough pixels for the frame size.");
    var using_local_palette = true;
    var palette = opts.palette;
    if (palette === void 0 || palette === null) {
      using_local_palette = false;
      palette = global_palette;
    }
    if (palette === void 0 || palette === null)
      throw new Error("Must supply either a local or global palette.");
    var num_colors = check_palette_and_num_colors(palette);
    var min_code_size = 0;
    while (num_colors >>= 1) ++min_code_size;
    num_colors = 1 << min_code_size;
    var delay = opts.delay === void 0 ? 0 : opts.delay;
    var disposal = opts.disposal === void 0 ? 0 : opts.disposal;
    if (disposal < 0 || disposal > 3)
      throw new Error("Disposal out of range.");
    var use_transparency = false;
    var transparent_index = 0;
    if (opts.transparent !== void 0 && opts.transparent !== null) {
      use_transparency = true;
      transparent_index = opts.transparent;
      if (transparent_index < 0 || transparent_index >= num_colors)
        throw new Error("Transparent color index.");
    }
    if (disposal !== 0 || use_transparency || delay !== 0) {
      buf[p++] = 33;
      buf[p++] = 249;
      buf[p++] = 4;
      buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
      buf[p++] = delay & 255;
      buf[p++] = delay >> 8 & 255;
      buf[p++] = transparent_index;
      buf[p++] = 0;
    }
    buf[p++] = 44;
    buf[p++] = x2 & 255;
    buf[p++] = x2 >> 8 & 255;
    buf[p++] = y2 & 255;
    buf[p++] = y2 >> 8 & 255;
    buf[p++] = w & 255;
    buf[p++] = w >> 8 & 255;
    buf[p++] = h & 255;
    buf[p++] = h >> 8 & 255;
    buf[p++] = using_local_palette === true ? 128 | min_code_size - 1 : 0;
    if (using_local_palette === true) {
      for (var i2 = 0, il2 = palette.length; i2 < il2; ++i2) {
        var rgb2 = palette[i2];
        buf[p++] = rgb2 >> 16 & 255;
        buf[p++] = rgb2 >> 8 & 255;
        buf[p++] = rgb2 & 255;
      }
    }
    p = GifWriterOutputLZWCodeStream(
      buf,
      p,
      min_code_size < 2 ? 2 : min_code_size,
      indexed_pixels
    );
    return p;
  };
  this.end = function() {
    if (ended === false) {
      buf[p++] = 59;
      ended = true;
    }
    return p;
  };
  this.getOutputBuffer = function() {
    return buf;
  };
  this.setOutputBuffer = function(v) {
    buf = v;
  };
  this.getOutputBufferPosition = function() {
    return p;
  };
  this.setOutputBufferPosition = function(v) {
    p = v;
  };
}
function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
  buf[p++] = min_code_size;
  var cur_subblock = p++;
  var clear_code = 1 << min_code_size;
  var code_mask = clear_code - 1;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;
  var cur_code_size = min_code_size + 1;
  var cur_shift = 0;
  var cur = 0;
  function emit_bytes_to_buffer(bit_block_size) {
    while (cur_shift >= bit_block_size) {
      buf[p++] = cur & 255;
      cur >>= 8;
      cur_shift -= 8;
      if (p === cur_subblock + 256) {
        buf[cur_subblock] = 255;
        cur_subblock = p++;
      }
    }
  }
  function emit_code(c2) {
    cur |= c2 << cur_shift;
    cur_shift += cur_code_size;
    emit_bytes_to_buffer(8);
  }
  var ib_code = index_stream[0] & code_mask;
  var code_table = {};
  emit_code(clear_code);
  for (var i = 1, il = index_stream.length; i < il; ++i) {
    var k = index_stream[i] & code_mask;
    var cur_key = ib_code << 8 | k;
    var cur_code = code_table[cur_key];
    if (cur_code === void 0) {
      cur |= ib_code << cur_shift;
      cur_shift += cur_code_size;
      while (cur_shift >= 8) {
        buf[p++] = cur & 255;
        cur >>= 8;
        cur_shift -= 8;
        if (p === cur_subblock + 256) {
          buf[cur_subblock] = 255;
          cur_subblock = p++;
        }
      }
      if (next_code === 4096) {
        emit_code(clear_code);
        next_code = eoi_code + 1;
        cur_code_size = min_code_size + 1;
        code_table = {};
      } else {
        if (next_code >= 1 << cur_code_size) ++cur_code_size;
        code_table[cur_key] = next_code++;
      }
      ib_code = k;
    } else {
      ib_code = cur_code;
    }
  }
  emit_code(ib_code);
  emit_code(eoi_code);
  emit_bytes_to_buffer(1);
  if (cur_subblock + 1 === p) {
    buf[cur_subblock] = 0;
  } else {
    buf[cur_subblock] = p - cur_subblock - 1;
    buf[p++] = 0;
  }
  return p;
}
function GifReader(buf) {
  var p = 0;
  if (buf[p++] !== 71 || buf[p++] !== 73 || buf[p++] !== 70 || buf[p++] !== 56 || (buf[p++] + 1 & 253) !== 56 || buf[p++] !== 97) {
    throw new Error("Invalid GIF 87a/89a header.");
  }
  var width = buf[p++] | buf[p++] << 8;
  var height = buf[p++] | buf[p++] << 8;
  var pf0 = buf[p++];
  var global_palette_flag = pf0 >> 7;
  var num_global_colors_pow2 = pf0 & 7;
  var num_global_colors = 1 << num_global_colors_pow2 + 1;
  buf[p++];
  buf[p++];
  var global_palette_offset = null;
  var global_palette_size = null;
  if (global_palette_flag) {
    global_palette_offset = p;
    global_palette_size = num_global_colors;
    p += num_global_colors * 3;
  }
  var no_eof = true;
  var frames = [];
  var delay = 0;
  var transparent_index = null;
  var disposal = 0;
  var loop_count = null;
  this.width = width;
  this.height = height;
  while (no_eof && p < buf.length) {
    switch (buf[p++]) {
      case 33:
        switch (buf[p++]) {
          case 255:
            if (buf[p] !== 11 || // 21 FF already read, check block size.
            // NETSCAPE2.0
            buf[p + 1] == 78 && buf[p + 2] == 69 && buf[p + 3] == 84 && buf[p + 4] == 83 && buf[p + 5] == 67 && buf[p + 6] == 65 && buf[p + 7] == 80 && buf[p + 8] == 69 && buf[p + 9] == 50 && buf[p + 10] == 46 && buf[p + 11] == 48 && // Sub-block
            buf[p + 12] == 3 && buf[p + 13] == 1 && buf[p + 16] == 0) {
              p += 14;
              loop_count = buf[p++] | buf[p++] << 8;
              p++;
            } else {
              p += 12;
              while (true) {
                var block_size = buf[p++];
                if (!(block_size >= 0)) throw Error("Invalid block size");
                if (block_size === 0) break;
                p += block_size;
              }
            }
            break;
          case 249:
            if (buf[p++] !== 4 || buf[p + 4] !== 0)
              throw new Error("Invalid graphics extension block.");
            var pf1 = buf[p++];
            delay = buf[p++] | buf[p++] << 8;
            transparent_index = buf[p++];
            if ((pf1 & 1) === 0) transparent_index = null;
            disposal = pf1 >> 2 & 7;
            p++;
            break;
          case 254:
            while (true) {
              var block_size = buf[p++];
              if (!(block_size >= 0)) throw Error("Invalid block size");
              if (block_size === 0) break;
              p += block_size;
            }
            break;
          default:
            throw new Error(
              "Unknown graphic control label: 0x" + buf[p - 1].toString(16)
            );
        }
        break;
      case 44:
        var x2 = buf[p++] | buf[p++] << 8;
        var y2 = buf[p++] | buf[p++] << 8;
        var w = buf[p++] | buf[p++] << 8;
        var h = buf[p++] | buf[p++] << 8;
        var pf2 = buf[p++];
        var local_palette_flag = pf2 >> 7;
        var interlace_flag = pf2 >> 6 & 1;
        var num_local_colors_pow2 = pf2 & 7;
        var num_local_colors = 1 << num_local_colors_pow2 + 1;
        var palette_offset = global_palette_offset;
        var palette_size = global_palette_size;
        var has_local_palette = false;
        if (local_palette_flag) {
          var has_local_palette = true;
          palette_offset = p;
          palette_size = num_local_colors;
          p += num_local_colors * 3;
        }
        var data_offset = p;
        p++;
        while (true) {
          var block_size = buf[p++];
          if (!(block_size >= 0)) throw Error("Invalid block size");
          if (block_size === 0) break;
          p += block_size;
        }
        frames.push({
          x: x2,
          y: y2,
          width: w,
          height: h,
          has_local_palette,
          palette_offset,
          palette_size,
          data_offset,
          data_length: p - data_offset,
          transparent_index,
          interlaced: !!interlace_flag,
          delay,
          disposal
        });
        break;
      case 59:
        no_eof = false;
        break;
      default:
        throw new Error("Unknown gif block: 0x" + buf[p - 1].toString(16));
    }
  }
  this.numFrames = function() {
    return frames.length;
  };
  this.loopCount = function() {
    return loop_count;
  };
  this.frameInfo = function(frame_num) {
    if (frame_num < 0 || frame_num >= frames.length)
      throw new Error("Frame index out of range.");
    return frames[frame_num];
  };
  this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels);
    GifReaderLZWOutputIndexStream(
      buf,
      frame.data_offset,
      index_stream,
      num_pixels
    );
    var palette_offset2 = frame.palette_offset;
    var trans = frame.transparent_index;
    if (trans === null) trans = 256;
    var framewidth = frame.width;
    var framestride = width - framewidth;
    var xleft = framewidth;
    var opbeg = (frame.y * width + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op = opbeg;
    var scanstride = framestride * 4;
    if (frame.interlaced === true) {
      scanstride += width * 4 * 7;
    }
    var interlaceskip = 8;
    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];
      if (xleft === 0) {
        op += scanstride;
        xleft = framewidth;
        if (op >= opend) {
          scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }
      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset2 + index * 3];
        var g = buf[palette_offset2 + index * 3 + 1];
        var b = buf[palette_offset2 + index * 3 + 2];
        pixels[op++] = b;
        pixels[op++] = g;
        pixels[op++] = r;
        pixels[op++] = 255;
      }
      --xleft;
    }
  };
  this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels);
    GifReaderLZWOutputIndexStream(
      buf,
      frame.data_offset,
      index_stream,
      num_pixels
    );
    var palette_offset2 = frame.palette_offset;
    var trans = frame.transparent_index;
    if (trans === null) trans = 256;
    var framewidth = frame.width;
    var framestride = width - framewidth;
    var xleft = framewidth;
    var opbeg = (frame.y * width + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op = opbeg;
    var scanstride = framestride * 4;
    if (frame.interlaced === true) {
      scanstride += width * 4 * 7;
    }
    var interlaceskip = 8;
    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];
      if (xleft === 0) {
        op += scanstride;
        xleft = framewidth;
        if (op >= opend) {
          scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }
      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset2 + index * 3];
        var g = buf[palette_offset2 + index * 3 + 1];
        var b = buf[palette_offset2 + index * 3 + 2];
        pixels[op++] = r;
        pixels[op++] = g;
        pixels[op++] = b;
        pixels[op++] = 255;
      }
      --xleft;
    }
  };
}
function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
  var min_code_size = code_stream[p++];
  var clear_code = 1 << min_code_size;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;
  var cur_code_size = min_code_size + 1;
  var code_mask = (1 << cur_code_size) - 1;
  var cur_shift = 0;
  var cur = 0;
  var op = 0;
  var subblock_size = code_stream[p++];
  var code_table = new Int32Array(4096);
  var prev_code = null;
  while (true) {
    while (cur_shift < 16) {
      if (subblock_size === 0) break;
      cur |= code_stream[p++] << cur_shift;
      cur_shift += 8;
      if (subblock_size === 1) {
        subblock_size = code_stream[p++];
      } else {
        --subblock_size;
      }
    }
    if (cur_shift < cur_code_size)
      break;
    var code = cur & code_mask;
    cur >>= cur_code_size;
    cur_shift -= cur_code_size;
    if (code === clear_code) {
      next_code = eoi_code + 1;
      cur_code_size = min_code_size + 1;
      code_mask = (1 << cur_code_size) - 1;
      prev_code = null;
      continue;
    } else if (code === eoi_code) {
      break;
    }
    var chase_code = code < next_code ? code : prev_code;
    var chase_length = 0;
    var chase = chase_code;
    while (chase > clear_code) {
      chase = code_table[chase] >> 8;
      ++chase_length;
    }
    var k = chase;
    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
    if (op_end > output_length) {
      console.log("Warning, gif stream longer than expected.");
      return;
    }
    output[op++] = k;
    op += chase_length;
    var b = op;
    if (chase_code !== code)
      output[op++] = k;
    chase = chase_code;
    while (chase_length--) {
      chase = code_table[chase];
      output[--b] = chase & 255;
      chase >>= 8;
    }
    if (prev_code !== null && next_code < 4096) {
      code_table[next_code++] = prev_code << 8 | k;
      if (next_code >= code_mask + 1 && cur_code_size < 12) {
        ++cur_code_size;
        code_mask = code_mask << 1 | 1;
      }
    }
    prev_code = code;
  }
  if (op !== output_length) {
    console.log("Warning, gif stream shorter than expected.");
  }
  return output;
}
try {
  GifWriter_1 = omggif.GifWriter = GifWriter;
  GifReader_1 = omggif.GifReader = GifReader;
} catch (e) {
}
let BitmapImage$2 = class BitmapImage2 {
  /**
   * BitmapImage is a class that hold an RGBA (red, green, blue, alpha) representation of an image. It's shape is borrowed from the Jimp package to make it easy to transfer GIF image frames into Jimp and Jimp images into GIF image frames. Each instance has a `bitmap` property having the following properties:
   * 
   * Property | Description
   * --- | ---
   * bitmap.width | width of image in pixels
   * bitmap.height | height of image in pixels
   * bitmap.data | a Buffer whose every four bytes represents a pixel, each sequential byte of a pixel corresponding to the red, green, blue, and alpha values of the pixel
   *
   * Its constructor supports the following signatures:
   *
   * * new BitmapImage(bitmap: { width: number, height: number, data: Buffer })
   * * new BitmapImage(bitmapImage: BitmapImage)
   * * new BitmapImage(width: number, height: number, buffer: Buffer)
   * * new BitmapImage(width: number, height: number, backgroundRGBA?: number)
   * 
   * When a `BitmapImage` is provided, the constructed `BitmapImage` is a deep clone of the provided one, so that each image's pixel data can subsequently be modified without affecting each other.
   *
   * `backgroundRGBA` is an optional parameter representing a pixel as a single number. In hex, the number is as follows: 0xRRGGBBAA, where RR is the red byte, GG the green byte, BB, the blue byte, and AA the alpha value. An AA of 0x00 is considered transparent, and all non-zero AA values are treated as opaque.
   */
  constructor(...args) {
    if (args.length === 0) {
      throw new Error("constructor requires parameters");
    }
    const firstArg = args[0];
    if (firstArg !== null && typeof firstArg === "object") {
      if (firstArg instanceof BitmapImage2) {
        const sourceBitmap = firstArg.bitmap;
        this.bitmap = {
          width: sourceBitmap.width,
          height: sourceBitmap.height,
          data: new Buffer(sourceBitmap.width * sourceBitmap.height * 4)
        };
        sourceBitmap.data.copy(this.bitmap.data);
      } else if (firstArg.width && firstArg.height && firstArg.data) {
        this.bitmap = firstArg;
      } else {
        throw new Error("unrecognized constructor parameters");
      }
    } else if (typeof firstArg === "number" && typeof args[1] === "number") {
      const width = firstArg;
      const height = args[1];
      const thirdArg = args[2];
      this.bitmap = { width, height };
      if (Buffer.isBuffer(thirdArg)) {
        this.bitmap.data = thirdArg;
      } else {
        this.bitmap.data = new Buffer(width * height * 4);
        if (typeof thirdArg === "number") {
          this.fillRGBA(thirdArg);
        }
      }
    } else {
      throw new Error("unrecognized constructor parameters");
    }
  }
  /**
   * Copy a square portion of this image into another image. 
   * 
   * @param {BitmapImage} toImage Image into which to copy the square
   * @param {number} toX x-coord in toImage of upper-left corner of receiving square
   * @param {number} toY y-coord in toImage of upper-left corner of receiving square
   * @param {number} fromX x-coord in this image of upper-left corner of source square
   * @param {number} fromY y-coord in this image of upper-left corner of source square
   * @return {BitmapImage} The present image to allow for chaining.
   */
  blit(toImage, toX, toY, fromX, fromY, fromWidth, fromHeight) {
    if (fromX + fromWidth > this.bitmap.width) {
      throw new Error("copy exceeds width of source bitmap");
    }
    if (toX + fromWidth > toImage.bitmap.width) {
      throw new Error("copy exceeds width of target bitmap");
    }
    if (fromY + fromHeight > this.bitmap.height) {
      throw new Error("copy exceeds height of source bitmap");
    }
    if (toY + fromHeight > toImage.bitmap.height) {
      throw new Erro("copy exceeds height of target bitmap");
    }
    const sourceBuf = this.bitmap.data;
    const targetBuf = toImage.bitmap.data;
    const sourceByteWidth = this.bitmap.width * 4;
    const targetByteWidth = toImage.bitmap.width * 4;
    const copyByteWidth = fromWidth * 4;
    let si = fromY * sourceByteWidth + fromX * 4;
    let ti = toY * targetByteWidth + toX * 4;
    while (--fromHeight >= 0) {
      sourceBuf.copy(targetBuf, ti, si, si + copyByteWidth);
      si += sourceByteWidth;
      ti += targetByteWidth;
    }
    return this;
  }
  /**
   * Fills the image with a single color.
   * 
   * @param {number} rgba Color with which to fill image, expressed as a singlenumber in the form 0xRRGGBBAA, where AA is 0x00 for transparent and any other value for opaque.
   * @return {BitmapImage} The present image to allow for chaining.
   */
  fillRGBA(rgba) {
    const buf = this.bitmap.data;
    const bufByteWidth = this.bitmap.height * 4;
    let bi = 0;
    while (bi < bufByteWidth) {
      buf.writeUInt32BE(rgba, bi);
      bi += 4;
    }
    while (bi < buf.length) {
      buf.copy(buf, bi, 0, bufByteWidth);
      bi += bufByteWidth;
    }
    return this;
  }
  /**
   * Gets the RGBA number of the pixel at the given coordinate in the form 0xRRGGBBAA, where AA is the alpha value, with alpha 0x00 encoding to transparency in GIFs.
   * 
   * @param {number} x x-coord of pixel
   * @param {number} y y-coord of pixel
   * @return {number} RGBA of pixel in 0xRRGGBBAA form
   */
  getRGBA(x2, y2) {
    const bi = (y2 * this.bitmap.width + x2) * 4;
    return this.bitmap.data.readUInt32BE(bi);
  }
  /**
   * Gets a set of all RGBA colors found within the image.
   * 
   * @return {Set} Set of all RGBA colors that the image contains.
   */
  getRGBASet() {
    const rgbaSet = /* @__PURE__ */ new Set();
    const buf = this.bitmap.data;
    for (let bi = 0; bi < buf.length; bi += 4) {
      rgbaSet.add(buf.readUInt32BE(bi, true));
    }
    return rgbaSet;
  }
  /**
   * Converts the image to greyscale using inferred Adobe metrics.
   * 
   * @return {BitmapImage} The present image to allow for chaining.
   */
  greyscale() {
    const buf = this.bitmap.data;
    this.scan(0, 0, this.bitmap.width, this.bitmap.height, (x2, y2, idx) => {
      const grey = Math.round(
        0.299 * buf[idx] + 0.587 * buf[idx + 1] + 0.114 * buf[idx + 2]
      );
      buf[idx] = grey;
      buf[idx + 1] = grey;
      buf[idx + 2] = grey;
    });
    return this;
  }
  /**
   * Reframes the image as if placing a frame around the original image and replacing the original image with the newly framed image. When the new frame is strictly within the boundaries of the original image, this method crops the image. When any of the new boundaries exceed those of the original image, the `fillRGBA` must be provided to indicate the color with which to fill the extra space added to the image.
   * 
   * @param {number} xOffset The x-coord offset of the upper-left pixel of the desired image relative to the present image.
   * @param {number} yOffset The y-coord offset of the upper-left pixel of the desired image relative to the present image.
   * @param {number} width The width of the new image after reframing
   * @param {number} height The height of the new image after reframing
   * @param {number} fillRGBA The color with which to fill space added to the image as a result of the reframing, in 0xRRGGBBAA format, where AA is 0x00 to indicate transparent and a non-zero value to indicate opaque. This parameter is only required when the reframing exceeds the original boundaries (i.e. does not simply perform a crop).
   * @return {BitmapImage} The present image to allow for chaining.
   */
  reframe(xOffset, yOffset, width, height, fillRGBA) {
    const cropX = xOffset < 0 ? 0 : xOffset;
    const cropY = yOffset < 0 ? 0 : yOffset;
    const cropWidth = width + cropX > this.bitmap.width ? this.bitmap.width - cropX : width;
    const cropHeight = height + cropY > this.bitmap.height ? this.bitmap.height - cropY : height;
    const newX = xOffset < 0 ? -xOffset : 0;
    const newY = yOffset < 0 ? -yOffset : 0;
    let image;
    if (fillRGBA === void 0) {
      if (cropX !== xOffset || cropY != yOffset || cropWidth !== width || cropHeight !== height) {
        throw new GifError(`fillRGBA required for this reframing`);
      }
      image = new BitmapImage2(width, height);
    } else {
      image = new BitmapImage2(width, height, fillRGBA);
    }
    this.blit(image, newX, newY, cropX, cropY, cropWidth, cropHeight);
    this.bitmap = image.bitmap;
    return this;
  }
  /**
   * Scales the image size up by an integer factor. Each pixel of the original image becomes a square of the same color in the new image having a size of `factor` x `factor` pixels.
   * 
   * @param {number} factor The factor by which to scale up the image. Must be an integer >= 1.
   * @return {BitmapImage} The present image to allow for chaining.
   */
  scale(factor) {
    if (factor === 1) {
      return;
    }
    if (!Number.isInteger(factor) || factor < 1) {
      throw new Error("the scale must be an integer >= 1");
    }
    const sourceWidth = this.bitmap.width;
    const sourceHeight = this.bitmap.height;
    const destByteWidth = sourceWidth * factor * 4;
    const sourceBuf = this.bitmap.data;
    const destBuf = new Buffer(sourceHeight * destByteWidth * factor);
    let sourceIndex = 0;
    let priorDestRowIndex;
    let destIndex = 0;
    for (let y2 = 0; y2 < sourceHeight; ++y2) {
      priorDestRowIndex = destIndex;
      for (let x2 = 0; x2 < sourceWidth; ++x2) {
        const color = sourceBuf.readUInt32BE(sourceIndex, true);
        for (let cx = 0; cx < factor; ++cx) {
          destBuf.writeUInt32BE(color, destIndex);
          destIndex += 4;
        }
        sourceIndex += 4;
      }
      for (let cy = 1; cy < factor; ++cy) {
        destBuf.copy(destBuf, destIndex, priorDestRowIndex, destIndex);
        destIndex += destByteWidth;
        priorDestRowIndex += destByteWidth;
      }
    }
    this.bitmap = {
      width: sourceWidth * factor,
      height: sourceHeight * factor,
      data: destBuf
    };
    return this;
  }
  /**
   * Scans all coordinates of the image, handing each in turn to the provided handler function.
   *
   * @param {function} scanHandler A function(x: number, y: number, bi: number) to be called for each pixel of the image with that pixel's x-coord, y-coord, and index into the `data` buffer. The function accesses the pixel at this coordinate by accessing the `this.data` at index `bi`.
   * @see scanAllIndexes
   */
  scanAllCoords(scanHandler) {
    const width = this.bitmap.width;
    const bufferLength = this.bitmap.data.length;
    let x2 = 0;
    let y2 = 0;
    for (let bi = 0; bi < bufferLength; bi += 4) {
      scanHandler(x2, y2, bi);
      if (++x2 === width) {
        x2 = 0;
        ++y2;
      }
    }
  }
  /**
   * Scans all pixels of the image, handing the index of each in turn to the provided handler function. Runs a bit faster than `scanAllCoords()`, should the handler not need pixel coordinates.
   *
   * @param {function} scanHandler A function(bi: number) to be called for each pixel of the image with that pixel's index into the `data` buffer. The pixels is found at index 'bi' within `this.data`.
   * @see scanAllCoords
   */
  scanAllIndexes(scanHandler) {
    const bufferLength = this.bitmap.data.length;
    for (let bi = 0; bi < bufferLength; bi += 4) {
      scanHandler(bi);
    }
  }
};
var bitmapimage = BitmapImage$2;
var gif$1 = {};
let Gif$1 = class Gif2 {
  // width - width of GIF in pixels
  // height - height of GIF in pixels
  // loops - 0 = unending; (n > 0) = iterate n times
  // usesTransparency - whether any frames have transparent pixels
  // colorScope - scope of color tables in GIF
  // frames - array of frames
  // buffer - GIF-formatted data
  /**
   * Gif is a class representing an encoded GIF. It is intended to be a read-only representation of a byte-encoded GIF. Only encoders and decoders should be creating instances of this class.
   * 
   * Property | Description
   * --- | ---
   * width | width of the GIF at its widest
   * height | height of the GIF at its highest
   * loops | the number of times the GIF should loop before stopping; 0 => loop indefinitely
   * usesTransparency | boolean indicating whether at least one frame contains at least one transparent pixel
   * colorScope | the scope of the color tables as encoded within the GIF; either Gif.GlobalColorsOnly (== 1) or Gif.LocalColorsOnly (== 2).
   * frames | a array of GifFrame instances, one for each frame of the GIF
   * buffer | a Buffer holding the encoding's byte data
   * 
   * Its constructor should only ever be called by the GIF encoder or decoder.
   *
   * @param {Buffer} buffer A Buffer containing the encoded bytes
   * @param {GifFrame[]} frames Array of frames found in the encoding
   * @param {object} spec Properties of the encoding as listed above
   */
  constructor(buffer, frames, spec) {
    this.width = spec.width;
    this.height = spec.height;
    this.loops = spec.loops;
    this.usesTransparency = spec.usesTransparency;
    this.colorScope = spec.colorScope;
    this.frames = frames;
    this.buffer = buffer;
  }
};
Gif$1.GlobalColorsPreferred = 0;
Gif$1.GlobalColorsOnly = 1;
Gif$1.LocalColorsOnly = 2;
let GifError$2 = class GifError2 extends Error {
  /**
   * GifError is a class representing a GIF-related error
   * 
   * @param {string|Error} messageOrError
   */
  constructor(messageOrError) {
    super(messageOrError);
    if (messageOrError instanceof Error) {
      this.stack = "Gif" + messageOrError.stack;
    }
  }
};
gif$1.Gif = Gif$1;
gif$1.GifError = GifError$2;
var gifcodec = {};
var gifutil = {};
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var constants_exports = {};
__export(constants_exports, {
  bt709: () => bt709_exports
});
var bt709_exports = {};
__export(bt709_exports, {
  Y: () => Y,
  x: () => x,
  y: () => y
});
var Y = /* @__PURE__ */ ((Y2) => {
  Y2[Y2["RED"] = 0.2126] = "RED";
  Y2[Y2["GREEN"] = 0.7152] = "GREEN";
  Y2[Y2["BLUE"] = 0.0722] = "BLUE";
  Y2[Y2["WHITE"] = 1] = "WHITE";
  return Y2;
})(Y || {});
var x = /* @__PURE__ */ ((x2) => {
  x2[x2["RED"] = 0.64] = "RED";
  x2[x2["GREEN"] = 0.3] = "GREEN";
  x2[x2["BLUE"] = 0.15] = "BLUE";
  x2[x2["WHITE"] = 0.3127] = "WHITE";
  return x2;
})(x || {});
var y = /* @__PURE__ */ ((y2) => {
  y2[y2["RED"] = 0.33] = "RED";
  y2[y2["GREEN"] = 0.6] = "GREEN";
  y2[y2["BLUE"] = 0.06] = "BLUE";
  y2[y2["WHITE"] = 0.329] = "WHITE";
  return y2;
})(y || {});
var conversion_exports = {};
__export(conversion_exports, {
  lab2rgb: () => lab2rgb,
  lab2xyz: () => lab2xyz,
  rgb2hsl: () => rgb2hsl,
  rgb2lab: () => rgb2lab,
  rgb2xyz: () => rgb2xyz,
  xyz2lab: () => xyz2lab,
  xyz2rgb: () => xyz2rgb
});
function correctGamma(n) {
  return n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92;
}
function rgb2xyz(r, g, b) {
  r = correctGamma(r / 255);
  g = correctGamma(g / 255);
  b = correctGamma(b / 255);
  return {
    x: r * 0.4124 + g * 0.3576 + b * 0.1805,
    y: r * 0.2126 + g * 0.7152 + b * 0.0722,
    z: r * 0.0193 + g * 0.1192 + b * 0.9505
  };
}
var arithmetic_exports = {};
__export(arithmetic_exports, {
  degrees2radians: () => degrees2radians,
  inRange0to255: () => inRange0to255,
  inRange0to255Rounded: () => inRange0to255Rounded,
  intInRange: () => intInRange,
  max3: () => max3,
  min3: () => min3,
  stableSort: () => stableSort
});
function degrees2radians(n) {
  return n * (Math.PI / 180);
}
function max3(a, b, c2) {
  let m = a;
  if (m < b)
    m = b;
  if (m < c2)
    m = c2;
  return m;
}
function min3(a, b, c2) {
  let m = a;
  if (m > b)
    m = b;
  if (m > c2)
    m = c2;
  return m;
}
function intInRange(value, low, high) {
  if (value > high)
    value = high;
  if (value < low)
    value = low;
  return value | 0;
}
function inRange0to255Rounded(n) {
  n = Math.round(n);
  if (n > 255)
    n = 255;
  else if (n < 0)
    n = 0;
  return n;
}
function inRange0to255(n) {
  if (n > 255)
    n = 255;
  else if (n < 0)
    n = 0;
  return n;
}
function stableSort(arrayToSort, callback) {
  const type = typeof arrayToSort[0];
  let sorted;
  if (type === "number" || type === "string") {
    const ord = /* @__PURE__ */ Object.create(null);
    for (let i = 0, l = arrayToSort.length; i < l; i++) {
      const val = arrayToSort[i];
      if (ord[val] || ord[val] === 0)
        continue;
      ord[val] = i;
    }
    sorted = arrayToSort.sort((a, b) => callback(a, b) || ord[a] - ord[b]);
  } else {
    const ord2 = arrayToSort.slice(0);
    sorted = arrayToSort.sort((a, b) => callback(a, b) || ord2.indexOf(a) - ord2.indexOf(b));
  }
  return sorted;
}
function rgb2hsl(r, g, b) {
  const min = min3(r, g, b);
  const max = max3(r, g, b);
  const delta = max - min;
  const l = (min + max) / 510;
  let s = 0;
  if (l > 0 && l < 1)
    s = delta / (l < 0.5 ? max + min : 510 - max - min);
  let h = 0;
  if (delta > 0) {
    if (max === r) {
      h = (g - b) / delta;
    } else if (max === g) {
      h = 2 + (b - r) / delta;
    } else {
      h = 4 + (r - g) / delta;
    }
    h *= 60;
    if (h < 0)
      h += 360;
  }
  return { h, s, l };
}
var refX = 0.95047;
var refY = 1;
var refZ = 1.08883;
function pivot(n) {
  return n > 8856e-6 ? n ** (1 / 3) : 7.787 * n + 16 / 116;
}
function xyz2lab(x2, y2, z2) {
  x2 = pivot(x2 / refX);
  y2 = pivot(y2 / refY);
  z2 = pivot(z2 / refZ);
  if (116 * y2 - 16 < 0)
    throw new Error("xxx");
  return {
    L: Math.max(0, 116 * y2 - 16),
    a: 500 * (x2 - y2),
    b: 200 * (y2 - z2)
  };
}
function rgb2lab(r, g, b) {
  const xyz = rgb2xyz(r, g, b);
  return xyz2lab(xyz.x, xyz.y, xyz.z);
}
var refX2 = 0.95047;
var refY2 = 1;
var refZ2 = 1.08883;
function pivot2(n) {
  return n > 0.206893034 ? n ** 3 : (n - 16 / 116) / 7.787;
}
function lab2xyz(L, a, b) {
  const y2 = (L + 16) / 116;
  const x2 = a / 500 + y2;
  const z2 = y2 - b / 200;
  return {
    x: refX2 * pivot2(x2),
    y: refY2 * pivot2(y2),
    z: refZ2 * pivot2(z2)
  };
}
function correctGamma2(n) {
  return n > 31308e-7 ? 1.055 * n ** (1 / 2.4) - 0.055 : 12.92 * n;
}
function xyz2rgb(x2, y2, z2) {
  const r = correctGamma2(x2 * 3.2406 + y2 * -1.5372 + z2 * -0.4986);
  const g = correctGamma2(x2 * -0.9689 + y2 * 1.8758 + z2 * 0.0415);
  const b = correctGamma2(x2 * 0.0557 + y2 * -0.204 + z2 * 1.057);
  return {
    r: inRange0to255Rounded(r * 255),
    g: inRange0to255Rounded(g * 255),
    b: inRange0to255Rounded(b * 255)
  };
}
function lab2rgb(L, a, b) {
  const xyz = lab2xyz(L, a, b);
  return xyz2rgb(xyz.x, xyz.y, xyz.z);
}
var distance_exports = {};
__export(distance_exports, {
  AbstractDistanceCalculator: () => AbstractDistanceCalculator,
  AbstractEuclidean: () => AbstractEuclidean,
  AbstractManhattan: () => AbstractManhattan,
  CIE94GraphicArts: () => CIE94GraphicArts,
  CIE94Textiles: () => CIE94Textiles,
  CIEDE2000: () => CIEDE2000,
  CMetric: () => CMetric,
  Euclidean: () => Euclidean,
  EuclideanBT709: () => EuclideanBT709,
  EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha,
  Manhattan: () => Manhattan,
  ManhattanBT709: () => ManhattanBT709,
  ManhattanNommyde: () => ManhattanNommyde,
  PNGQuant: () => PNGQuant
});
var AbstractDistanceCalculator = class {
  constructor() {
    __publicField(this, "_maxDistance");
    __publicField(this, "_whitePoint");
    this._setDefaults();
    this.setWhitePoint(255, 255, 255, 255);
  }
  setWhitePoint(r, g, b, a) {
    this._whitePoint = {
      r: r > 0 ? 255 / r : 0,
      g: g > 0 ? 255 / g : 0,
      b: b > 0 ? 255 / b : 0,
      a: a > 0 ? 255 / a : 0
    };
    this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);
  }
  calculateNormalized(colorA, colorB) {
    return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;
  }
};
var AbstractCIE94 = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));
    const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));
    const dL = lab1.L - lab2.L;
    const dA = lab1.a - lab2.a;
    const dB = lab1.b - lab2.b;
    const c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b);
    const c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);
    const dC = c1 - c2;
    let deltaH = dA * dA + dB * dB - dC * dC;
    deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
    const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;
    return Math.sqrt((dL / this._Kl) ** 2 + (dC / (1 + this._K1 * c1)) ** 2 + (deltaH / (1 + this._K2 * c1)) ** 2 + dAlpha ** 2);
  }
};
var CIE94Textiles = class extends AbstractCIE94 {
  _setDefaults() {
    this._Kl = 2;
    this._K1 = 0.048;
    this._K2 = 0.014;
    this._kA = 0.25 * 50 / 255;
  }
};
var CIE94GraphicArts = class extends AbstractCIE94 {
  _setDefaults() {
    this._Kl = 1;
    this._K1 = 0.045;
    this._K2 = 0.015;
    this._kA = 0.25 * 100 / 255;
  }
};
var _CIEDE2000 = class extends AbstractDistanceCalculator {
  _setDefaults() {
  }
  static _calculatehp(b, ap) {
    const hp = Math.atan2(b, ap);
    if (hp >= 0)
      return hp;
    return hp + _CIEDE2000._deg360InRad;
  }
  static _calculateRT(ahp, aCp) {
    const aCp_to_7 = aCp ** 7;
    const R_C = 2 * Math.sqrt(aCp_to_7 / (aCp_to_7 + _CIEDE2000._pow25to7));
    const delta_theta = _CIEDE2000._deg30InRad * Math.exp(-(((ahp - _CIEDE2000._deg275InRad) / _CIEDE2000._deg25InRad) ** 2));
    return -Math.sin(2 * delta_theta) * R_C;
  }
  static _calculateT(ahp) {
    return 1 - 0.17 * Math.cos(ahp - _CIEDE2000._deg30InRad) + 0.24 * Math.cos(ahp * 2) + 0.32 * Math.cos(ahp * 3 + _CIEDE2000._deg6InRad) - 0.2 * Math.cos(ahp * 4 - _CIEDE2000._deg63InRad);
  }
  static _calculate_ahp(C1pC2p, h_bar, h1p, h2p) {
    const hpSum = h1p + h2p;
    if (C1pC2p === 0)
      return hpSum;
    if (h_bar <= _CIEDE2000._deg180InRad)
      return hpSum / 2;
    if (hpSum < _CIEDE2000._deg360InRad) {
      return (hpSum + _CIEDE2000._deg360InRad) / 2;
    }
    return (hpSum - _CIEDE2000._deg360InRad) / 2;
  }
  static _calculate_dHp(C1pC2p, h_bar, h2p, h1p) {
    let dhp;
    if (C1pC2p === 0) {
      dhp = 0;
    } else if (h_bar <= _CIEDE2000._deg180InRad) {
      dhp = h2p - h1p;
    } else if (h2p <= h1p) {
      dhp = h2p - h1p + _CIEDE2000._deg360InRad;
    } else {
      dhp = h2p - h1p - _CIEDE2000._deg360InRad;
    }
    return 2 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2);
  }
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));
    const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));
    const dA = (a2 - a1) * this._whitePoint.a * _CIEDE2000._kA;
    const dE2 = this.calculateRawInLab(lab1, lab2);
    return Math.sqrt(dE2 + dA * dA);
  }
  calculateRawInLab(Lab1, Lab2) {
    const L1 = Lab1.L;
    const a1 = Lab1.a;
    const b1 = Lab1.b;
    const L2 = Lab2.L;
    const a2 = Lab2.a;
    const b2 = Lab2.b;
    const C1 = Math.sqrt(a1 * a1 + b1 * b1);
    const C2 = Math.sqrt(a2 * a2 + b2 * b2);
    const pow_a_C1_C2_to_7 = ((C1 + C2) / 2) ** 7;
    const G = 0.5 * (1 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + _CIEDE2000._pow25to7)));
    const a1p = (1 + G) * a1;
    const a2p = (1 + G) * a2;
    const C1p = Math.sqrt(a1p * a1p + b1 * b1);
    const C2p = Math.sqrt(a2p * a2p + b2 * b2);
    const C1pC2p = C1p * C2p;
    const h1p = _CIEDE2000._calculatehp(b1, a1p);
    const h2p = _CIEDE2000._calculatehp(b2, a2p);
    const h_bar = Math.abs(h1p - h2p);
    const dLp = L2 - L1;
    const dCp = C2p - C1p;
    const dHp = _CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p);
    const ahp = _CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p);
    const T = _CIEDE2000._calculateT(ahp);
    const aCp = (C1p + C2p) / 2;
    const aLp_minus_50_square = ((L1 + L2) / 2 - 50) ** 2;
    const S_L = 1 + 0.015 * aLp_minus_50_square / Math.sqrt(20 + aLp_minus_50_square);
    const S_C = 1 + 0.045 * aCp;
    const S_H = 1 + 0.015 * T * aCp;
    const R_T = _CIEDE2000._calculateRT(ahp, aCp);
    const dLpSL = dLp / S_L;
    const dCpSC = dCp / S_C;
    const dHpSH = dHp / S_H;
    return dLpSL ** 2 + dCpSC ** 2 + dHpSH ** 2 + R_T * dCpSC * dHpSH;
  }
};
var CIEDE2000 = _CIEDE2000;
__publicField(CIEDE2000, "_kA", 0.25 * 100 / 255);
__publicField(CIEDE2000, "_pow25to7", 25 ** 7);
__publicField(CIEDE2000, "_deg360InRad", degrees2radians(360));
__publicField(CIEDE2000, "_deg180InRad", degrees2radians(180));
__publicField(CIEDE2000, "_deg30InRad", degrees2radians(30));
__publicField(CIEDE2000, "_deg6InRad", degrees2radians(6));
__publicField(CIEDE2000, "_deg63InRad", degrees2radians(63));
__publicField(CIEDE2000, "_deg275InRad", degrees2radians(275));
__publicField(CIEDE2000, "_deg25InRad", degrees2radians(25));
var CMetric = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const rmean = (r1 + r2) / 2 * this._whitePoint.r;
    const r = (r1 - r2) * this._whitePoint.r;
    const g = (g1 - g2) * this._whitePoint.g;
    const b = (b1 - b2) * this._whitePoint.b;
    const dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8);
    const dA = (a2 - a1) * this._whitePoint.a;
    return Math.sqrt(dE + dA * dA);
  }
  _setDefaults() {
  }
};
var AbstractEuclidean = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const dR = r2 - r1;
    const dG = g2 - g1;
    const dB = b2 - b1;
    const dA = a2 - a1;
    return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);
  }
};
var Euclidean = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 1;
    this._kG = 1;
    this._kB = 1;
    this._kA = 1;
  }
};
var EuclideanBT709 = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 0.2126;
    this._kG = 0.7152;
    this._kB = 0.0722;
    this._kA = 1;
  }
};
var EuclideanBT709NoAlpha = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 0.2126;
    this._kG = 0.7152;
    this._kB = 0.0722;
    this._kA = 0;
  }
};
var AbstractManhattan = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    let dR = r2 - r1;
    let dG = g2 - g1;
    let dB = b2 - b1;
    let dA = a2 - a1;
    if (dR < 0)
      dR = 0 - dR;
    if (dG < 0)
      dG = 0 - dG;
    if (dB < 0)
      dB = 0 - dB;
    if (dA < 0)
      dA = 0 - dA;
    return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;
  }
};
var Manhattan = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 1;
    this._kG = 1;
    this._kB = 1;
    this._kA = 1;
  }
};
var ManhattanNommyde = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 0.4984;
    this._kG = 0.8625;
    this._kB = 0.2979;
    this._kA = 1;
  }
};
var ManhattanBT709 = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 0.2126;
    this._kG = 0.7152;
    this._kB = 0.0722;
    this._kA = 1;
  }
};
var PNGQuant = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const alphas = (a2 - a1) * this._whitePoint.a;
    return this._colordifferenceCh(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifferenceCh(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifferenceCh(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);
  }
  _colordifferenceCh(x2, y2, alphas) {
    const black = x2 - y2;
    const white = black + alphas;
    return black * black + white * white;
  }
  _setDefaults() {
  }
};
var palette_exports = {};
__export(palette_exports, {
  AbstractPaletteQuantizer: () => AbstractPaletteQuantizer,
  ColorHistogram: () => ColorHistogram,
  NeuQuant: () => NeuQuant,
  NeuQuantFloat: () => NeuQuantFloat,
  RGBQuant: () => RGBQuant,
  WuColorCube: () => WuColorCube,
  WuQuant: () => WuQuant
});
var AbstractPaletteQuantizer = class {
  quantizeSync() {
    for (const value of this.quantize()) {
      if (value.palette) {
        return value.palette;
      }
    }
    throw new Error("unreachable");
  }
};
var Point = class {
  constructor() {
    __publicField(this, "r");
    __publicField(this, "g");
    __publicField(this, "b");
    __publicField(this, "a");
    __publicField(this, "uint32");
    __publicField(this, "rgba");
    this.uint32 = -1 >>> 0;
    this.r = this.g = this.b = this.a = 0;
    this.rgba = new Array(4);
    this.rgba[0] = 0;
    this.rgba[1] = 0;
    this.rgba[2] = 0;
    this.rgba[3] = 0;
  }
  static createByQuadruplet(quadruplet) {
    const point = new Point();
    point.r = quadruplet[0] | 0;
    point.g = quadruplet[1] | 0;
    point.b = quadruplet[2] | 0;
    point.a = quadruplet[3] | 0;
    point._loadUINT32();
    point._loadQuadruplet();
    return point;
  }
  static createByRGBA(red, green, blue, alpha) {
    const point = new Point();
    point.r = red | 0;
    point.g = green | 0;
    point.b = blue | 0;
    point.a = alpha | 0;
    point._loadUINT32();
    point._loadQuadruplet();
    return point;
  }
  static createByUint32(uint32) {
    const point = new Point();
    point.uint32 = uint32 >>> 0;
    point._loadRGBA();
    point._loadQuadruplet();
    return point;
  }
  from(point) {
    this.r = point.r;
    this.g = point.g;
    this.b = point.b;
    this.a = point.a;
    this.uint32 = point.uint32;
    this.rgba[0] = point.r;
    this.rgba[1] = point.g;
    this.rgba[2] = point.b;
    this.rgba[3] = point.a;
  }
  getLuminosity(useAlphaChannel) {
    let r = this.r;
    let g = this.g;
    let b = this.b;
    if (useAlphaChannel) {
      r = Math.min(255, 255 - this.a + this.a * r / 255);
      g = Math.min(255, 255 - this.a + this.a * g / 255);
      b = Math.min(255, 255 - this.a + this.a * b / 255);
    }
    return r * 0.2126 + g * 0.7152 + b * 0.0722;
  }
  _loadUINT32() {
    this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
  }
  _loadRGBA() {
    this.r = this.uint32 & 255;
    this.g = this.uint32 >>> 8 & 255;
    this.b = this.uint32 >>> 16 & 255;
    this.a = this.uint32 >>> 24 & 255;
  }
  _loadQuadruplet() {
    this.rgba[0] = this.r;
    this.rgba[1] = this.g;
    this.rgba[2] = this.b;
    this.rgba[3] = this.a;
  }
};
var PointContainer = class {
  constructor() {
    __publicField(this, "_pointArray");
    __publicField(this, "_width");
    __publicField(this, "_height");
    this._width = 0;
    this._height = 0;
    this._pointArray = [];
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
  setWidth(width) {
    this._width = width;
  }
  setHeight(height) {
    this._height = height;
  }
  getPointArray() {
    return this._pointArray;
  }
  clone() {
    const clone3 = new PointContainer();
    clone3._width = this._width;
    clone3._height = this._height;
    for (let i = 0, l = this._pointArray.length; i < l; i++) {
      clone3._pointArray[i] = Point.createByUint32(this._pointArray[i].uint32 | 0);
    }
    return clone3;
  }
  toUint32Array() {
    const l = this._pointArray.length;
    const uint32Array = new Uint32Array(l);
    for (let i = 0; i < l; i++) {
      uint32Array[i] = this._pointArray[i].uint32;
    }
    return uint32Array;
  }
  toUint8Array() {
    return new Uint8Array(this.toUint32Array().buffer);
  }
  static fromHTMLImageElement(img) {
    const width = img.naturalWidth;
    const height = img.naturalHeight;
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);
    return PointContainer.fromHTMLCanvasElement(canvas);
  }
  static fromHTMLCanvasElement(canvas) {
    const width = canvas.width;
    const height = canvas.height;
    const ctx = canvas.getContext("2d");
    const imgData = ctx.getImageData(0, 0, width, height);
    return PointContainer.fromImageData(imgData);
  }
  static fromImageData(imageData) {
    const width = imageData.width;
    const height = imageData.height;
    return PointContainer.fromUint8Array(imageData.data, width, height);
  }
  static fromUint8Array(uint8Array, width, height) {
    switch (Object.prototype.toString.call(uint8Array)) {
      case "[object Uint8ClampedArray]":
      case "[object Uint8Array]":
        break;
      default:
        uint8Array = new Uint8Array(uint8Array);
    }
    const uint32Array = new Uint32Array(uint8Array.buffer);
    return PointContainer.fromUint32Array(uint32Array, width, height);
  }
  static fromUint32Array(uint32Array, width, height) {
    const container = new PointContainer();
    container._width = width;
    container._height = height;
    for (let i = 0, l = uint32Array.length; i < l; i++) {
      container._pointArray[i] = Point.createByUint32(uint32Array[i] | 0);
    }
    return container;
  }
  static fromBuffer(buffer, width, height) {
    const uint32Array = new Uint32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT);
    return PointContainer.fromUint32Array(uint32Array, width, height);
  }
};
var hueGroups = 10;
function hueGroup(hue, segmentsNumber) {
  const maxHue = 360;
  const seg = maxHue / segmentsNumber;
  const half = seg / 2;
  for (let i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {
    if (hue >= mid && hue < mid + seg)
      return i;
  }
  return 0;
}
var Palette = class {
  constructor() {
    __publicField(this, "_pointContainer");
    __publicField(this, "_pointArray", []);
    __publicField(this, "_i32idx", {});
    this._pointContainer = new PointContainer();
    this._pointContainer.setHeight(1);
    this._pointArray = this._pointContainer.getPointArray();
  }
  add(color) {
    this._pointArray.push(color);
    this._pointContainer.setWidth(this._pointArray.length);
  }
  has(color) {
    for (let i = this._pointArray.length - 1; i >= 0; i--) {
      if (color.uint32 === this._pointArray[i].uint32)
        return true;
    }
    return false;
  }
  getNearestColor(colorDistanceCalculator, color) {
    return this._pointArray[this._getNearestIndex(colorDistanceCalculator, color) | 0];
  }
  getPointContainer() {
    return this._pointContainer;
  }
  _nearestPointFromCache(key) {
    return typeof this._i32idx[key] === "number" ? this._i32idx[key] : -1;
  }
  _getNearestIndex(colorDistanceCalculator, point) {
    let idx = this._nearestPointFromCache("" + point.uint32);
    if (idx >= 0)
      return idx;
    let minimalDistance = Number.MAX_VALUE;
    idx = 0;
    for (let i = 0, l = this._pointArray.length; i < l; i++) {
      const p = this._pointArray[i];
      const distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);
      if (distance < minimalDistance) {
        minimalDistance = distance;
        idx = i;
      }
    }
    this._i32idx[point.uint32] = idx;
    return idx;
  }
  sort() {
    this._i32idx = {};
    this._pointArray.sort((a, b) => {
      const hslA = rgb2hsl(a.r, a.g, a.b);
      const hslB = rgb2hsl(b.r, b.g, b.b);
      const hueA = a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, hueGroups);
      const hueB = b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);
      const hueDiff = hueB - hueA;
      if (hueDiff)
        return -hueDiff;
      const lA = a.getLuminosity(true);
      const lB = b.getLuminosity(true);
      if (lB - lA !== 0)
        return lB - lA;
      const satDiff = (hslB.s * 100 | 0) - (hslA.s * 100 | 0);
      if (satDiff)
        return -satDiff;
      return 0;
    });
  }
};
var utils_exports = {};
__export(utils_exports, {
  HueStatistics: () => HueStatistics,
  Palette: () => Palette,
  Point: () => Point,
  PointContainer: () => PointContainer,
  ProgressTracker: () => ProgressTracker,
  arithmetic: () => arithmetic_exports
});
var HueGroup = class {
  constructor() {
    __publicField(this, "num", 0);
    __publicField(this, "cols", []);
  }
};
var HueStatistics = class {
  constructor(numGroups, minCols) {
    __publicField(this, "_numGroups");
    __publicField(this, "_minCols");
    __publicField(this, "_stats");
    __publicField(this, "_groupsFull");
    this._numGroups = numGroups;
    this._minCols = minCols;
    this._stats = [];
    for (let i = 0; i <= numGroups; i++) {
      this._stats[i] = new HueGroup();
    }
    this._groupsFull = 0;
  }
  check(i32) {
    if (this._groupsFull === this._numGroups + 1) {
      this.check = () => {
      };
    }
    const r = i32 & 255;
    const g = i32 >>> 8 & 255;
    const b = i32 >>> 16 & 255;
    const hg = r === g && g === b ? 0 : 1 + hueGroup(rgb2hsl(r, g, b).h, this._numGroups);
    const gr = this._stats[hg];
    const min = this._minCols;
    gr.num++;
    if (gr.num > min) {
      return;
    }
    if (gr.num === min) {
      this._groupsFull++;
    }
    if (gr.num <= min) {
      this._stats[hg].cols.push(i32);
    }
  }
  injectIntoDictionary(histG) {
    for (let i = 0; i <= this._numGroups; i++) {
      if (this._stats[i].num <= this._minCols) {
        this._stats[i].cols.forEach((col) => {
          if (!histG[col]) {
            histG[col] = 1;
          } else {
            histG[col]++;
          }
        });
      }
    }
  }
  injectIntoArray(histG) {
    for (let i = 0; i <= this._numGroups; i++) {
      if (this._stats[i].num <= this._minCols) {
        this._stats[i].cols.forEach((col) => {
          if (histG.indexOf(col) === -1) {
            histG.push(col);
          }
        });
      }
    }
  }
};
var _ProgressTracker = class {
  constructor(valueRange, progressRange) {
    __publicField(this, "progress");
    __publicField(this, "_step");
    __publicField(this, "_range");
    __publicField(this, "_last");
    __publicField(this, "_progressRange");
    this._range = valueRange;
    this._progressRange = progressRange;
    this._step = Math.max(1, this._range / (_ProgressTracker.steps + 1) | 0);
    this._last = -this._step;
    this.progress = 0;
  }
  shouldNotify(current) {
    if (current - this._last >= this._step) {
      this._last = current;
      this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange);
      return true;
    }
    return false;
  }
};
var ProgressTracker = _ProgressTracker;
__publicField(ProgressTracker, "steps", 100);
var networkBiasShift = 3;
var Neuron = class {
  constructor(defaultValue) {
    __publicField(this, "r");
    __publicField(this, "g");
    __publicField(this, "b");
    __publicField(this, "a");
    this.r = this.g = this.b = this.a = defaultValue;
  }
  toPoint() {
    return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
  }
  subtract(r, g, b, a) {
    this.r -= r | 0;
    this.g -= g | 0;
    this.b -= b | 0;
    this.a -= a | 0;
  }
};
var _NeuQuant = class extends AbstractPaletteQuantizer {
  constructor(colorDistanceCalculator, colors = 256) {
    super();
    __publicField(this, "_pointArray");
    __publicField(this, "_networkSize");
    __publicField(this, "_network");
    __publicField(this, "_sampleFactor");
    __publicField(this, "_radPower");
    __publicField(this, "_freq");
    __publicField(this, "_bias");
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
    this._pointArray = [];
    this._sampleFactor = 1;
    this._networkSize = colors;
    this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
  }
  sample(pointContainer) {
    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
  }
  *quantize() {
    this._init();
    yield* this._learn();
    yield {
      palette: this._buildPalette(),
      progress: 100
    };
  }
  _init() {
    this._freq = [];
    this._bias = [];
    this._radPower = [];
    this._network = [];
    for (let i = 0; i < this._networkSize; i++) {
      this._network[i] = new Neuron((i << networkBiasShift + 8) / this._networkSize | 0);
      this._freq[i] = _NeuQuant._initialBias / this._networkSize | 0;
      this._bias[i] = 0;
    }
  }
  *_learn() {
    let sampleFactor = this._sampleFactor;
    const pointsNumber = this._pointArray.length;
    if (pointsNumber < _NeuQuant._minpicturebytes)
      sampleFactor = 1;
    const alphadec = 30 + (sampleFactor - 1) / 3 | 0;
    const pointsToSample = pointsNumber / sampleFactor | 0;
    let delta = pointsToSample / _NeuQuant._nCycles | 0;
    let alpha = _NeuQuant._initAlpha;
    let radius = (this._networkSize >> 3) * _NeuQuant._radiusBias;
    let rad = radius >> _NeuQuant._radiusBiasShift;
    if (rad <= 1)
      rad = 0;
    for (let i = 0; i < rad; i++) {
      this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuant._radBias / (rad * rad)) >>> 0;
    }
    let step;
    if (pointsNumber < _NeuQuant._minpicturebytes) {
      step = 1;
    } else if (pointsNumber % _NeuQuant._prime1 !== 0) {
      step = _NeuQuant._prime1;
    } else if (pointsNumber % _NeuQuant._prime2 !== 0) {
      step = _NeuQuant._prime2;
    } else if (pointsNumber % _NeuQuant._prime3 !== 0) {
      step = _NeuQuant._prime3;
    } else {
      step = _NeuQuant._prime4;
    }
    const tracker = new ProgressTracker(pointsToSample, 99);
    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {
      if (tracker.shouldNotify(i)) {
        yield {
          progress: tracker.progress
        };
      }
      const point = this._pointArray[pointIndex];
      const b = point.b << networkBiasShift;
      const g = point.g << networkBiasShift;
      const r = point.r << networkBiasShift;
      const a = point.a << networkBiasShift;
      const neuronIndex = this._contest(b, g, r, a);
      this._alterSingle(alpha, neuronIndex, b, g, r, a);
      if (rad !== 0)
        this._alterNeighbour(rad, neuronIndex, b, g, r, a);
      pointIndex += step;
      if (pointIndex >= pointsNumber)
        pointIndex -= pointsNumber;
      i++;
      if (delta === 0)
        delta = 1;
      if (i % delta === 0) {
        alpha -= alpha / alphadec | 0;
        radius -= radius / _NeuQuant._radiusDecrease | 0;
        rad = radius >> _NeuQuant._radiusBiasShift;
        if (rad <= 1)
          rad = 0;
        for (let j = 0; j < rad; j++) {
          this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuant._radBias / (rad * rad)) >>> 0;
        }
      }
    }
  }
  _buildPalette() {
    const palette = new Palette();
    this._network.forEach((neuron) => {
      palette.add(neuron.toPoint());
    });
    palette.sort();
    return palette;
  }
  _alterNeighbour(rad, i, b, g, r, al) {
    let lo = i - rad;
    if (lo < -1)
      lo = -1;
    let hi = i + rad;
    if (hi > this._networkSize)
      hi = this._networkSize;
    let j = i + 1;
    let k = i - 1;
    let m = 1;
    while (j < hi || k > lo) {
      const a = this._radPower[m++] / _NeuQuant._alphaRadBias;
      if (j < hi) {
        const p = this._network[j++];
        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
      }
      if (k > lo) {
        const p = this._network[k--];
        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
      }
    }
  }
  _alterSingle(alpha, i, b, g, r, a) {
    alpha /= _NeuQuant._initAlpha;
    const n = this._network[i];
    n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
  }
  _contest(b, g, r, a) {
    const multiplier = 255 * 4 << networkBiasShift;
    let bestd = 2147483647;
    let bestbiasd = bestd;
    let bestpos = -1;
    let bestbiaspos = bestpos;
    for (let i = 0; i < this._networkSize; i++) {
      const n = this._network[i];
      const dist = this._distance.calculateNormalized(n, { r, g, b, a }) * multiplier | 0;
      if (dist < bestd) {
        bestd = dist;
        bestpos = i;
      }
      const biasdist = dist - (this._bias[i] >> _NeuQuant._initialBiasShift - networkBiasShift);
      if (biasdist < bestbiasd) {
        bestbiasd = biasdist;
        bestbiaspos = i;
      }
      const betafreq = this._freq[i] >> _NeuQuant._betaShift;
      this._freq[i] -= betafreq;
      this._bias[i] += betafreq << _NeuQuant._gammaShift;
    }
    this._freq[bestpos] += _NeuQuant._beta;
    this._bias[bestpos] -= _NeuQuant._betaGamma;
    return bestbiaspos;
  }
};
var NeuQuant = _NeuQuant;
__publicField(NeuQuant, "_prime1", 499);
__publicField(NeuQuant, "_prime2", 491);
__publicField(NeuQuant, "_prime3", 487);
__publicField(NeuQuant, "_prime4", 503);
__publicField(NeuQuant, "_minpicturebytes", _NeuQuant._prime4);
__publicField(NeuQuant, "_nCycles", 100);
__publicField(NeuQuant, "_initialBiasShift", 16);
__publicField(NeuQuant, "_initialBias", 1 << _NeuQuant._initialBiasShift);
__publicField(NeuQuant, "_gammaShift", 10);
__publicField(NeuQuant, "_betaShift", 10);
__publicField(NeuQuant, "_beta", _NeuQuant._initialBias >> _NeuQuant._betaShift);
__publicField(NeuQuant, "_betaGamma", _NeuQuant._initialBias << _NeuQuant._gammaShift - _NeuQuant._betaShift);
__publicField(NeuQuant, "_radiusBiasShift", 6);
__publicField(NeuQuant, "_radiusBias", 1 << _NeuQuant._radiusBiasShift);
__publicField(NeuQuant, "_radiusDecrease", 30);
__publicField(NeuQuant, "_alphaBiasShift", 10);
__publicField(NeuQuant, "_initAlpha", 1 << _NeuQuant._alphaBiasShift);
__publicField(NeuQuant, "_radBiasShift", 8);
__publicField(NeuQuant, "_radBias", 1 << _NeuQuant._radBiasShift);
__publicField(NeuQuant, "_alphaRadBiasShift", _NeuQuant._alphaBiasShift + _NeuQuant._radBiasShift);
__publicField(NeuQuant, "_alphaRadBias", 1 << _NeuQuant._alphaRadBiasShift);
var networkBiasShift2 = 3;
var NeuronFloat = class {
  constructor(defaultValue) {
    __publicField(this, "r");
    __publicField(this, "g");
    __publicField(this, "b");
    __publicField(this, "a");
    this.r = this.g = this.b = this.a = defaultValue;
  }
  toPoint() {
    return Point.createByRGBA(this.r >> networkBiasShift2, this.g >> networkBiasShift2, this.b >> networkBiasShift2, this.a >> networkBiasShift2);
  }
  subtract(r, g, b, a) {
    this.r -= r;
    this.g -= g;
    this.b -= b;
    this.a -= a;
  }
};
var _NeuQuantFloat = class extends AbstractPaletteQuantizer {
  constructor(colorDistanceCalculator, colors = 256) {
    super();
    __publicField(this, "_pointArray");
    __publicField(this, "_networkSize");
    __publicField(this, "_network");
    __publicField(this, "_sampleFactor");
    __publicField(this, "_radPower");
    __publicField(this, "_freq");
    __publicField(this, "_bias");
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
    this._pointArray = [];
    this._sampleFactor = 1;
    this._networkSize = colors;
    this._distance.setWhitePoint(255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2);
  }
  sample(pointContainer) {
    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
  }
  *quantize() {
    this._init();
    yield* this._learn();
    yield {
      palette: this._buildPalette(),
      progress: 100
    };
  }
  _init() {
    this._freq = [];
    this._bias = [];
    this._radPower = [];
    this._network = [];
    for (let i = 0; i < this._networkSize; i++) {
      this._network[i] = new NeuronFloat((i << networkBiasShift2 + 8) / this._networkSize);
      this._freq[i] = _NeuQuantFloat._initialBias / this._networkSize;
      this._bias[i] = 0;
    }
  }
  *_learn() {
    let sampleFactor = this._sampleFactor;
    const pointsNumber = this._pointArray.length;
    if (pointsNumber < _NeuQuantFloat._minpicturebytes)
      sampleFactor = 1;
    const alphadec = 30 + (sampleFactor - 1) / 3;
    const pointsToSample = pointsNumber / sampleFactor;
    let delta = pointsToSample / _NeuQuantFloat._nCycles | 0;
    let alpha = _NeuQuantFloat._initAlpha;
    let radius = (this._networkSize >> 3) * _NeuQuantFloat._radiusBias;
    let rad = radius >> _NeuQuantFloat._radiusBiasShift;
    if (rad <= 1)
      rad = 0;
    for (let i = 0; i < rad; i++) {
      this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuantFloat._radBias / (rad * rad));
    }
    let step;
    if (pointsNumber < _NeuQuantFloat._minpicturebytes) {
      step = 1;
    } else if (pointsNumber % _NeuQuantFloat._prime1 !== 0) {
      step = _NeuQuantFloat._prime1;
    } else if (pointsNumber % _NeuQuantFloat._prime2 !== 0) {
      step = _NeuQuantFloat._prime2;
    } else if (pointsNumber % _NeuQuantFloat._prime3 !== 0) {
      step = _NeuQuantFloat._prime3;
    } else {
      step = _NeuQuantFloat._prime4;
    }
    const tracker = new ProgressTracker(pointsToSample, 99);
    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {
      if (tracker.shouldNotify(i)) {
        yield {
          progress: tracker.progress
        };
      }
      const point = this._pointArray[pointIndex];
      const b = point.b << networkBiasShift2;
      const g = point.g << networkBiasShift2;
      const r = point.r << networkBiasShift2;
      const a = point.a << networkBiasShift2;
      const neuronIndex = this._contest(b, g, r, a);
      this._alterSingle(alpha, neuronIndex, b, g, r, a);
      if (rad !== 0)
        this._alterNeighbour(rad, neuronIndex, b, g, r, a);
      pointIndex += step;
      if (pointIndex >= pointsNumber)
        pointIndex -= pointsNumber;
      i++;
      if (delta === 0)
        delta = 1;
      if (i % delta === 0) {
        alpha -= alpha / alphadec;
        radius -= radius / _NeuQuantFloat._radiusDecrease;
        rad = radius >> _NeuQuantFloat._radiusBiasShift;
        if (rad <= 1)
          rad = 0;
        for (let j = 0; j < rad; j++) {
          this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuantFloat._radBias / (rad * rad));
        }
      }
    }
  }
  _buildPalette() {
    const palette = new Palette();
    this._network.forEach((neuron) => {
      palette.add(neuron.toPoint());
    });
    palette.sort();
    return palette;
  }
  _alterNeighbour(rad, i, b, g, r, al) {
    let lo = i - rad;
    if (lo < -1)
      lo = -1;
    let hi = i + rad;
    if (hi > this._networkSize)
      hi = this._networkSize;
    let j = i + 1;
    let k = i - 1;
    let m = 1;
    while (j < hi || k > lo) {
      const a = this._radPower[m++] / _NeuQuantFloat._alphaRadBias;
      if (j < hi) {
        const p = this._network[j++];
        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
      }
      if (k > lo) {
        const p = this._network[k--];
        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
      }
    }
  }
  _alterSingle(alpha, i, b, g, r, a) {
    alpha /= _NeuQuantFloat._initAlpha;
    const n = this._network[i];
    n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
  }
  _contest(b, g, r, al) {
    const multiplier = 255 * 4 << networkBiasShift2;
    let bestd = 2147483647;
    let bestbiasd = bestd;
    let bestpos = -1;
    let bestbiaspos = bestpos;
    for (let i = 0; i < this._networkSize; i++) {
      const n = this._network[i];
      const dist = this._distance.calculateNormalized(n, { r, g, b, a: al }) * multiplier;
      if (dist < bestd) {
        bestd = dist;
        bestpos = i;
      }
      const biasdist = dist - (this._bias[i] >> _NeuQuantFloat._initialBiasShift - networkBiasShift2);
      if (biasdist < bestbiasd) {
        bestbiasd = biasdist;
        bestbiaspos = i;
      }
      const betafreq = this._freq[i] >> _NeuQuantFloat._betaShift;
      this._freq[i] -= betafreq;
      this._bias[i] += betafreq << _NeuQuantFloat._gammaShift;
    }
    this._freq[bestpos] += _NeuQuantFloat._beta;
    this._bias[bestpos] -= _NeuQuantFloat._betaGamma;
    return bestbiaspos;
  }
};
var NeuQuantFloat = _NeuQuantFloat;
__publicField(NeuQuantFloat, "_prime1", 499);
__publicField(NeuQuantFloat, "_prime2", 491);
__publicField(NeuQuantFloat, "_prime3", 487);
__publicField(NeuQuantFloat, "_prime4", 503);
__publicField(NeuQuantFloat, "_minpicturebytes", _NeuQuantFloat._prime4);
__publicField(NeuQuantFloat, "_nCycles", 100);
__publicField(NeuQuantFloat, "_initialBiasShift", 16);
__publicField(NeuQuantFloat, "_initialBias", 1 << _NeuQuantFloat._initialBiasShift);
__publicField(NeuQuantFloat, "_gammaShift", 10);
__publicField(NeuQuantFloat, "_betaShift", 10);
__publicField(NeuQuantFloat, "_beta", _NeuQuantFloat._initialBias >> _NeuQuantFloat._betaShift);
__publicField(NeuQuantFloat, "_betaGamma", _NeuQuantFloat._initialBias << _NeuQuantFloat._gammaShift - _NeuQuantFloat._betaShift);
__publicField(NeuQuantFloat, "_radiusBiasShift", 6);
__publicField(NeuQuantFloat, "_radiusBias", 1 << _NeuQuantFloat._radiusBiasShift);
__publicField(NeuQuantFloat, "_radiusDecrease", 30);
__publicField(NeuQuantFloat, "_alphaBiasShift", 10);
__publicField(NeuQuantFloat, "_initAlpha", 1 << _NeuQuantFloat._alphaBiasShift);
__publicField(NeuQuantFloat, "_radBiasShift", 8);
__publicField(NeuQuantFloat, "_radBias", 1 << _NeuQuantFloat._radBiasShift);
__publicField(NeuQuantFloat, "_alphaRadBiasShift", _NeuQuantFloat._alphaBiasShift + _NeuQuantFloat._radBiasShift);
__publicField(NeuQuantFloat, "_alphaRadBias", 1 << _NeuQuantFloat._alphaRadBiasShift);
var _ColorHistogram = class {
  constructor(method, colors) {
    __publicField(this, "_method");
    __publicField(this, "_hueStats");
    __publicField(this, "_histogram");
    __publicField(this, "_initColors");
    __publicField(this, "_minHueCols");
    this._method = method;
    this._minHueCols = colors << 2;
    this._initColors = colors << 2;
    this._hueStats = new HueStatistics(_ColorHistogram._hueGroups, this._minHueCols);
    this._histogram = /* @__PURE__ */ Object.create(null);
  }
  sample(pointContainer) {
    switch (this._method) {
      case 1:
        this._colorStats1D(pointContainer);
        break;
      case 2:
        this._colorStats2D(pointContainer);
        break;
    }
  }
  getImportanceSortedColorsIDXI32() {
    const sorted = stableSort(Object.keys(this._histogram), (a, b) => this._histogram[b] - this._histogram[a]);
    if (sorted.length === 0) {
      return [];
    }
    let idxi32;
    switch (this._method) {
      case 1:
        const initialColorsLimit = Math.min(sorted.length, this._initColors);
        const last = sorted[initialColorsLimit - 1];
        const freq = this._histogram[last];
        idxi32 = sorted.slice(0, initialColorsLimit);
        let pos = initialColorsLimit;
        const len = sorted.length;
        while (pos < len && this._histogram[sorted[pos]] === freq) {
          idxi32.push(sorted[pos++]);
        }
        this._hueStats.injectIntoArray(idxi32);
        break;
      case 2:
        idxi32 = sorted;
        break;
      default:
        throw new Error("Incorrect method");
    }
    return idxi32.map((v) => +v);
  }
  _colorStats1D(pointContainer) {
    const histG = this._histogram;
    const pointArray = pointContainer.getPointArray();
    const len = pointArray.length;
    for (let i = 0; i < len; i++) {
      const col = pointArray[i].uint32;
      this._hueStats.check(col);
      if (col in histG) {
        histG[col]++;
      } else {
        histG[col] = 1;
      }
    }
  }
  _colorStats2D(pointContainer) {
    const width = pointContainer.getWidth();
    const height = pointContainer.getHeight();
    const pointArray = pointContainer.getPointArray();
    const boxW = _ColorHistogram._boxSize[0];
    const boxH = _ColorHistogram._boxSize[1];
    const area = boxW * boxH;
    const boxes = this._makeBoxes(width, height, boxW, boxH);
    const histG = this._histogram;
    boxes.forEach((box) => {
      let effc = Math.round(box.w * box.h / area) * _ColorHistogram._boxPixels;
      if (effc < 2)
        effc = 2;
      const histL = {};
      this._iterateBox(box, width, (i) => {
        const col = pointArray[i].uint32;
        this._hueStats.check(col);
        if (col in histG) {
          histG[col]++;
        } else if (col in histL) {
          if (++histL[col] >= effc) {
            histG[col] = histL[col];
          }
        } else {
          histL[col] = 1;
        }
      });
    });
    this._hueStats.injectIntoDictionary(histG);
  }
  _iterateBox(bbox, wid, fn) {
    const b = bbox;
    const i0 = b.y * wid + b.x;
    const i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1);
    const incr = wid - b.w + 1;
    let cnt = 0;
    let i = i0;
    do {
      fn.call(this, i);
      i += ++cnt % b.w === 0 ? incr : 1;
    } while (i <= i1);
  }
  _makeBoxes(width, height, stepX, stepY) {
    const wrem = width % stepX;
    const hrem = height % stepY;
    const xend = width - wrem;
    const yend = height - hrem;
    const boxesArray = [];
    for (let y2 = 0; y2 < height; y2 += stepY) {
      for (let x2 = 0; x2 < width; x2 += stepX) {
        boxesArray.push({
          x: x2,
          y: y2,
          w: x2 === xend ? wrem : stepX,
          h: y2 === yend ? hrem : stepY
        });
      }
    }
    return boxesArray;
  }
};
var ColorHistogram = _ColorHistogram;
__publicField(ColorHistogram, "_boxSize", [64, 64]);
__publicField(ColorHistogram, "_boxPixels", 2);
__publicField(ColorHistogram, "_hueGroups", 10);
var RemovedColor = class {
  constructor(index, color, distance) {
    __publicField(this, "index");
    __publicField(this, "color");
    __publicField(this, "distance");
    this.index = index;
    this.color = color;
    this.distance = distance;
  }
};
var RGBQuant = class extends AbstractPaletteQuantizer {
  constructor(colorDistanceCalculator, colors = 256, method = 2) {
    super();
    __publicField(this, "_colors");
    __publicField(this, "_initialDistance");
    __publicField(this, "_distanceIncrement");
    __publicField(this, "_histogram");
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
    this._colors = colors;
    this._histogram = new ColorHistogram(method, colors);
    this._initialDistance = 0.01;
    this._distanceIncrement = 5e-3;
  }
  sample(image) {
    this._histogram.sample(image);
  }
  *quantize() {
    const idxi32 = this._histogram.getImportanceSortedColorsIDXI32();
    if (idxi32.length === 0) {
      throw new Error("No colors in image");
    }
    yield* this._buildPalette(idxi32);
  }
  *_buildPalette(idxi32) {
    const palette = new Palette();
    const colorArray = palette.getPointContainer().getPointArray();
    const usageArray = new Array(idxi32.length);
    for (let i = 0; i < idxi32.length; i++) {
      colorArray.push(Point.createByUint32(idxi32[i]));
      usageArray[i] = 1;
    }
    const len = colorArray.length;
    const memDist = [];
    let palLen = len;
    let thold = this._initialDistance;
    const tracker = new ProgressTracker(palLen - this._colors, 99);
    while (palLen > this._colors) {
      memDist.length = 0;
      for (let i = 0; i < len; i++) {
        if (tracker.shouldNotify(len - palLen)) {
          yield {
            progress: tracker.progress
          };
        }
        if (usageArray[i] === 0)
          continue;
        const pxi = colorArray[i];
        for (let j = i + 1; j < len; j++) {
          if (usageArray[j] === 0)
            continue;
          const pxj = colorArray[j];
          const dist = this._distance.calculateNormalized(pxi, pxj);
          if (dist < thold) {
            memDist.push(new RemovedColor(j, pxj, dist));
            usageArray[j] = 0;
            palLen--;
          }
        }
      }
      thold += palLen > this._colors * 3 ? this._initialDistance : this._distanceIncrement;
    }
    if (palLen < this._colors) {
      stableSort(memDist, (a, b) => b.distance - a.distance);
      let k = 0;
      while (palLen < this._colors && k < memDist.length) {
        const removedColor = memDist[k];
        usageArray[removedColor.index] = 1;
        palLen++;
        k++;
      }
    }
    let colors = colorArray.length;
    for (let colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {
      if (usageArray[colorIndex] === 0) {
        if (colorIndex !== colors - 1) {
          colorArray[colorIndex] = colorArray[colors - 1];
        }
        --colors;
      }
    }
    colorArray.length = colors;
    palette.sort();
    yield {
      palette,
      progress: 100
    };
  }
};
function createArray1D(dimension1) {
  const a = [];
  for (let k = 0; k < dimension1; k++) {
    a[k] = 0;
  }
  return a;
}
function createArray4D(dimension1, dimension2, dimension3, dimension4) {
  const a = new Array(dimension1);
  for (let i = 0; i < dimension1; i++) {
    a[i] = new Array(dimension2);
    for (let j = 0; j < dimension2; j++) {
      a[i][j] = new Array(dimension3);
      for (let k = 0; k < dimension3; k++) {
        a[i][j][k] = new Array(dimension4);
        for (let l = 0; l < dimension4; l++) {
          a[i][j][k][l] = 0;
        }
      }
    }
  }
  return a;
}
function createArray3D(dimension1, dimension2, dimension3) {
  const a = new Array(dimension1);
  for (let i = 0; i < dimension1; i++) {
    a[i] = new Array(dimension2);
    for (let j = 0; j < dimension2; j++) {
      a[i][j] = new Array(dimension3);
      for (let k = 0; k < dimension3; k++) {
        a[i][j][k] = 0;
      }
    }
  }
  return a;
}
function fillArray3D(a, dimension1, dimension2, dimension3, value) {
  for (let i = 0; i < dimension1; i++) {
    a[i] = [];
    for (let j = 0; j < dimension2; j++) {
      a[i][j] = [];
      for (let k = 0; k < dimension3; k++) {
        a[i][j][k] = value;
      }
    }
  }
}
function fillArray1D(a, dimension1, value) {
  for (let i = 0; i < dimension1; i++) {
    a[i] = value;
  }
}
var WuColorCube = class {
  constructor() {
    __publicField(this, "redMinimum");
    __publicField(this, "redMaximum");
    __publicField(this, "greenMinimum");
    __publicField(this, "greenMaximum");
    __publicField(this, "blueMinimum");
    __publicField(this, "blueMaximum");
    __publicField(this, "volume");
    __publicField(this, "alphaMinimum");
    __publicField(this, "alphaMaximum");
  }
};
var _WuQuant = class extends AbstractPaletteQuantizer {
  constructor(colorDistanceCalculator, colors = 256, significantBitsPerChannel = 5) {
    super();
    __publicField(this, "_reds");
    __publicField(this, "_greens");
    __publicField(this, "_blues");
    __publicField(this, "_alphas");
    __publicField(this, "_sums");
    __publicField(this, "_weights");
    __publicField(this, "_momentsRed");
    __publicField(this, "_momentsGreen");
    __publicField(this, "_momentsBlue");
    __publicField(this, "_momentsAlpha");
    __publicField(this, "_moments");
    __publicField(this, "_table");
    __publicField(this, "_pixels");
    __publicField(this, "_cubes");
    __publicField(this, "_colors");
    __publicField(this, "_significantBitsPerChannel");
    __publicField(this, "_maxSideIndex");
    __publicField(this, "_alphaMaxSideIndex");
    __publicField(this, "_sideSize");
    __publicField(this, "_alphaSideSize");
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
    this._setQuality(significantBitsPerChannel);
    this._initialize(colors);
  }
  sample(image) {
    const pointArray = image.getPointArray();
    for (let i = 0, l = pointArray.length; i < l; i++) {
      this._addColor(pointArray[i]);
    }
    this._pixels = this._pixels.concat(pointArray);
  }
  *quantize() {
    yield* this._preparePalette();
    const palette = new Palette();
    for (let paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {
      if (this._sums[paletteIndex] > 0) {
        const sum = this._sums[paletteIndex];
        const r = this._reds[paletteIndex] / sum;
        const g = this._greens[paletteIndex] / sum;
        const b = this._blues[paletteIndex] / sum;
        const a = this._alphas[paletteIndex] / sum;
        const color = Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);
        palette.add(color);
      }
    }
    palette.sort();
    yield {
      palette,
      progress: 100
    };
  }
  *_preparePalette() {
    yield* this._calculateMoments();
    let next = 0;
    const volumeVariance = createArray1D(this._colors);
    for (let cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {
      if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {
        volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0;
        volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0;
      } else {
        volumeVariance[next] = 0;
        cubeIndex--;
      }
      next = 0;
      let temp = volumeVariance[0];
      for (let index = 1; index <= cubeIndex; ++index) {
        if (volumeVariance[index] > temp) {
          temp = volumeVariance[index];
          next = index;
        }
      }
      if (temp <= 0) {
        this._colors = cubeIndex + 1;
        break;
      }
    }
    const lookupRed = [];
    const lookupGreen = [];
    const lookupBlue = [];
    const lookupAlpha = [];
    for (let k = 0; k < this._colors; ++k) {
      const weight = _WuQuant._volume(this._cubes[k], this._weights);
      if (weight > 0) {
        lookupRed[k] = _WuQuant._volume(this._cubes[k], this._momentsRed) / weight | 0;
        lookupGreen[k] = _WuQuant._volume(this._cubes[k], this._momentsGreen) / weight | 0;
        lookupBlue[k] = _WuQuant._volume(this._cubes[k], this._momentsBlue) / weight | 0;
        lookupAlpha[k] = _WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight | 0;
      } else {
        lookupRed[k] = 0;
        lookupGreen[k] = 0;
        lookupBlue[k] = 0;
        lookupAlpha[k] = 0;
      }
    }
    this._reds = createArray1D(this._colors + 1);
    this._greens = createArray1D(this._colors + 1);
    this._blues = createArray1D(this._colors + 1);
    this._alphas = createArray1D(this._colors + 1);
    this._sums = createArray1D(this._colors + 1);
    for (let index = 0, l = this._pixels.length; index < l; index++) {
      const color = this._pixels[index];
      const match = -1;
      let bestMatch = match;
      let bestDistance = Number.MAX_VALUE;
      for (let lookup = 0; lookup < this._colors; lookup++) {
        const foundRed = lookupRed[lookup];
        const foundGreen = lookupGreen[lookup];
        const foundBlue = lookupBlue[lookup];
        const foundAlpha = lookupAlpha[lookup];
        const distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);
        if (distance < bestDistance) {
          bestDistance = distance;
          bestMatch = lookup;
        }
      }
      this._reds[bestMatch] += color.r;
      this._greens[bestMatch] += color.g;
      this._blues[bestMatch] += color.b;
      this._alphas[bestMatch] += color.a;
      this._sums[bestMatch]++;
    }
  }
  _addColor(color) {
    const bitsToRemove = 8 - this._significantBitsPerChannel;
    const indexRed = (color.r >> bitsToRemove) + 1;
    const indexGreen = (color.g >> bitsToRemove) + 1;
    const indexBlue = (color.b >> bitsToRemove) + 1;
    const indexAlpha = (color.a >> bitsToRemove) + 1;
    this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;
    this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;
    this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;
    this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;
    this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;
    this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];
  }
  *_calculateMoments() {
    const area = [];
    const areaRed = [];
    const areaGreen = [];
    const areaBlue = [];
    const areaAlpha = [];
    const area2 = [];
    const xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    let trackerProgress = 0;
    const tracker = new ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);
    for (let alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {
      fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);
      for (let redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex, ++trackerProgress) {
        if (tracker.shouldNotify(trackerProgress)) {
          yield {
            progress: tracker.progress
          };
        }
        fillArray1D(area, this._sideSize, 0);
        fillArray1D(areaRed, this._sideSize, 0);
        fillArray1D(areaGreen, this._sideSize, 0);
        fillArray1D(areaBlue, this._sideSize, 0);
        fillArray1D(areaAlpha, this._sideSize, 0);
        fillArray1D(area2, this._sideSize, 0);
        for (let greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {
          let line = 0;
          let lineRed = 0;
          let lineGreen = 0;
          let lineBlue = 0;
          let lineAlpha = 0;
          let line2 = 0;
          for (let blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) {
            line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];
            lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];
            lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];
            lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];
            lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];
            line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];
            area[blueIndex] += line;
            areaRed[blueIndex] += lineRed;
            areaGreen[blueIndex] += lineGreen;
            areaBlue[blueIndex] += lineBlue;
            areaAlpha[blueIndex] += lineAlpha;
            area2[blueIndex] += line2;
            xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];
            xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];
            xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];
            xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];
            xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];
            xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];
            this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];
            this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];
            this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];
            this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];
            this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];
            this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];
          }
        }
      }
    }
  }
  static _volumeFloat(cube, moment) {
    return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
  }
  static _volume(cube, moment) {
    return _WuQuant._volumeFloat(cube, moment) | 0;
  }
  static _top(cube, direction, position, moment) {
    let result;
    switch (direction) {
      case _WuQuant._alpha:
        result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
        break;
      case _WuQuant._red:
        result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);
        break;
      case _WuQuant._green:
        result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);
        break;
      case _WuQuant._blue:
        result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);
        break;
      default:
        throw new Error("impossible");
    }
    return result | 0;
  }
  static _bottom(cube, direction, moment) {
    switch (direction) {
      case _WuQuant._alpha:
        return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
      case _WuQuant._red:
        return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
      case _WuQuant._green:
        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
      case _WuQuant._blue:
        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
      default:
        return 0;
    }
  }
  _calculateVariance(cube) {
    const volumeRed = _WuQuant._volume(cube, this._momentsRed);
    const volumeGreen = _WuQuant._volume(cube, this._momentsGreen);
    const volumeBlue = _WuQuant._volume(cube, this._momentsBlue);
    const volumeAlpha = _WuQuant._volume(cube, this._momentsAlpha);
    const volumeMoment = _WuQuant._volumeFloat(cube, this._moments);
    const volumeWeight = _WuQuant._volume(cube, this._weights);
    const distance = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;
    return volumeMoment - distance / volumeWeight;
  }
  _maximize(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {
    const bottomRed = _WuQuant._bottom(cube, direction, this._momentsRed) | 0;
    const bottomGreen = _WuQuant._bottom(cube, direction, this._momentsGreen) | 0;
    const bottomBlue = _WuQuant._bottom(cube, direction, this._momentsBlue) | 0;
    const bottomAlpha = _WuQuant._bottom(cube, direction, this._momentsAlpha) | 0;
    const bottomWeight = _WuQuant._bottom(cube, direction, this._weights) | 0;
    let result = 0;
    let cutPosition = -1;
    for (let position = first; position < last; ++position) {
      let halfRed = bottomRed + _WuQuant._top(cube, direction, position, this._momentsRed);
      let halfGreen = bottomGreen + _WuQuant._top(cube, direction, position, this._momentsGreen);
      let halfBlue = bottomBlue + _WuQuant._top(cube, direction, position, this._momentsBlue);
      let halfAlpha = bottomAlpha + _WuQuant._top(cube, direction, position, this._momentsAlpha);
      let halfWeight = bottomWeight + _WuQuant._top(cube, direction, position, this._weights);
      if (halfWeight !== 0) {
        let halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
        let temp = halfDistance / halfWeight;
        halfRed = wholeRed - halfRed;
        halfGreen = wholeGreen - halfGreen;
        halfBlue = wholeBlue - halfBlue;
        halfAlpha = wholeAlpha - halfAlpha;
        halfWeight = wholeWeight - halfWeight;
        if (halfWeight !== 0) {
          halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
          temp += halfDistance / halfWeight;
          if (temp > result) {
            result = temp;
            cutPosition = position;
          }
        }
      }
    }
    return { max: result, position: cutPosition };
  }
  _cut(first, second) {
    let direction;
    const wholeRed = _WuQuant._volume(first, this._momentsRed);
    const wholeGreen = _WuQuant._volume(first, this._momentsGreen);
    const wholeBlue = _WuQuant._volume(first, this._momentsBlue);
    const wholeAlpha = _WuQuant._volume(first, this._momentsAlpha);
    const wholeWeight = _WuQuant._volume(first, this._weights);
    const red = this._maximize(first, _WuQuant._red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
    const green = this._maximize(first, _WuQuant._green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
    const blue = this._maximize(first, _WuQuant._blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
    const alpha = this._maximize(first, _WuQuant._alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
    if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {
      direction = _WuQuant._alpha;
      if (alpha.position < 0)
        return false;
    } else if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {
      direction = _WuQuant._red;
    } else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {
      direction = _WuQuant._green;
    } else {
      direction = _WuQuant._blue;
    }
    second.redMaximum = first.redMaximum;
    second.greenMaximum = first.greenMaximum;
    second.blueMaximum = first.blueMaximum;
    second.alphaMaximum = first.alphaMaximum;
    switch (direction) {
      case _WuQuant._red:
        second.redMinimum = first.redMaximum = red.position;
        second.greenMinimum = first.greenMinimum;
        second.blueMinimum = first.blueMinimum;
        second.alphaMinimum = first.alphaMinimum;
        break;
      case _WuQuant._green:
        second.greenMinimum = first.greenMaximum = green.position;
        second.redMinimum = first.redMinimum;
        second.blueMinimum = first.blueMinimum;
        second.alphaMinimum = first.alphaMinimum;
        break;
      case _WuQuant._blue:
        second.blueMinimum = first.blueMaximum = blue.position;
        second.redMinimum = first.redMinimum;
        second.greenMinimum = first.greenMinimum;
        second.alphaMinimum = first.alphaMinimum;
        break;
      case _WuQuant._alpha:
        second.alphaMinimum = first.alphaMaximum = alpha.position;
        second.blueMinimum = first.blueMinimum;
        second.redMinimum = first.redMinimum;
        second.greenMinimum = first.greenMinimum;
        break;
    }
    first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);
    second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);
    return true;
  }
  _initialize(colors) {
    this._colors = colors;
    this._cubes = [];
    for (let cubeIndex = 0; cubeIndex < colors; cubeIndex++) {
      this._cubes[cubeIndex] = new WuColorCube();
    }
    this._cubes[0].redMinimum = 0;
    this._cubes[0].greenMinimum = 0;
    this._cubes[0].blueMinimum = 0;
    this._cubes[0].alphaMinimum = 0;
    this._cubes[0].redMaximum = this._maxSideIndex;
    this._cubes[0].greenMaximum = this._maxSideIndex;
    this._cubes[0].blueMaximum = this._maxSideIndex;
    this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;
    this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._table = [];
    for (let tableIndex = 0; tableIndex < 256; ++tableIndex) {
      this._table[tableIndex] = tableIndex * tableIndex;
    }
    this._pixels = [];
  }
  _setQuality(significantBitsPerChannel = 5) {
    this._significantBitsPerChannel = significantBitsPerChannel;
    this._maxSideIndex = 1 << this._significantBitsPerChannel;
    this._alphaMaxSideIndex = this._maxSideIndex;
    this._sideSize = this._maxSideIndex + 1;
    this._alphaSideSize = this._alphaMaxSideIndex + 1;
  }
};
var WuQuant = _WuQuant;
__publicField(WuQuant, "_alpha", 3);
__publicField(WuQuant, "_red", 2);
__publicField(WuQuant, "_green", 1);
__publicField(WuQuant, "_blue", 0);
var image_exports = {};
__export(image_exports, {
  AbstractImageQuantizer: () => AbstractImageQuantizer,
  ErrorDiffusionArray: () => ErrorDiffusionArray,
  ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel,
  ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma,
  NearestColor: () => NearestColor
});
var AbstractImageQuantizer = class {
  quantizeSync(pointContainer, palette) {
    for (const value of this.quantize(pointContainer, palette)) {
      if (value.pointContainer) {
        return value.pointContainer;
      }
    }
    throw new Error("unreachable");
  }
};
var NearestColor = class extends AbstractImageQuantizer {
  constructor(colorDistanceCalculator) {
    super();
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
  }
  *quantize(pointContainer, palette) {
    const pointArray = pointContainer.getPointArray();
    const width = pointContainer.getWidth();
    const height = pointContainer.getHeight();
    const tracker = new ProgressTracker(height, 99);
    for (let y2 = 0; y2 < height; y2++) {
      if (tracker.shouldNotify(y2)) {
        yield {
          progress: tracker.progress
        };
      }
      for (let x2 = 0, idx = y2 * width; x2 < width; x2++, idx++) {
        const point = pointArray[idx];
        point.from(palette.getNearestColor(this._distance, point));
      }
    }
    yield {
      pointContainer,
      progress: 100
    };
  }
};
var ErrorDiffusionArrayKernel = /* @__PURE__ */ ((ErrorDiffusionArrayKernel2) => {
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FloydSteinberg"] = 0] = "FloydSteinberg";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FalseFloydSteinberg"] = 1] = "FalseFloydSteinberg";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Stucki"] = 2] = "Stucki";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Atkinson"] = 3] = "Atkinson";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Jarvis"] = 4] = "Jarvis";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Burkes"] = 5] = "Burkes";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Sierra"] = 6] = "Sierra";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["TwoSierra"] = 7] = "TwoSierra";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["SierraLite"] = 8] = "SierraLite";
  return ErrorDiffusionArrayKernel2;
})(ErrorDiffusionArrayKernel || {});
var ErrorDiffusionArray = class extends AbstractImageQuantizer {
  constructor(colorDistanceCalculator, kernel, serpentine = true, minimumColorDistanceToDither = 0, calculateErrorLikeGIMP = false) {
    super();
    __publicField(this, "_minColorDistance");
    __publicField(this, "_serpentine");
    __publicField(this, "_kernel");
    __publicField(this, "_calculateErrorLikeGIMP");
    __publicField(this, "_distance");
    this._setKernel(kernel);
    this._distance = colorDistanceCalculator;
    this._minColorDistance = minimumColorDistanceToDither;
    this._serpentine = serpentine;
    this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;
  }
  *quantize(pointContainer, palette) {
    const pointArray = pointContainer.getPointArray();
    const originalPoint = new Point();
    const width = pointContainer.getWidth();
    const height = pointContainer.getHeight();
    const errorLines = [];
    let dir = 1;
    let maxErrorLines = 1;
    for (const kernel of this._kernel) {
      const kernelErrorLines = kernel[2] + 1;
      if (maxErrorLines < kernelErrorLines)
        maxErrorLines = kernelErrorLines;
    }
    for (let i = 0; i < maxErrorLines; i++) {
      this._fillErrorLine(errorLines[i] = [], width);
    }
    const tracker = new ProgressTracker(height, 99);
    for (let y2 = 0; y2 < height; y2++) {
      if (tracker.shouldNotify(y2)) {
        yield {
          progress: tracker.progress
        };
      }
      if (this._serpentine)
        dir *= -1;
      const lni = y2 * width;
      const xStart = dir === 1 ? 0 : width - 1;
      const xEnd = dir === 1 ? width : -1;
      this._fillErrorLine(errorLines[0], width);
      errorLines.push(errorLines.shift());
      const errorLine = errorLines[0];
      for (let x2 = xStart, idx = lni + xStart; x2 !== xEnd; x2 += dir, idx += dir) {
        const point = pointArray[idx];
        const error = errorLine[x2];
        originalPoint.from(point);
        const correctedPoint = Point.createByRGBA(inRange0to255Rounded(point.r + error[0]), inRange0to255Rounded(point.g + error[1]), inRange0to255Rounded(point.b + error[2]), inRange0to255Rounded(point.a + error[3]));
        const palettePoint = palette.getNearestColor(this._distance, correctedPoint);
        point.from(palettePoint);
        if (this._minColorDistance) {
          const dist = this._distance.calculateNormalized(originalPoint, palettePoint);
          if (dist < this._minColorDistance)
            continue;
        }
        let er;
        let eg;
        let eb;
        let ea;
        if (this._calculateErrorLikeGIMP) {
          er = correctedPoint.r - palettePoint.r;
          eg = correctedPoint.g - palettePoint.g;
          eb = correctedPoint.b - palettePoint.b;
          ea = correctedPoint.a - palettePoint.a;
        } else {
          er = originalPoint.r - palettePoint.r;
          eg = originalPoint.g - palettePoint.g;
          eb = originalPoint.b - palettePoint.b;
          ea = originalPoint.a - palettePoint.a;
        }
        const dStart = dir === 1 ? 0 : this._kernel.length - 1;
        const dEnd = dir === 1 ? this._kernel.length : -1;
        for (let i = dStart; i !== dEnd; i += dir) {
          const x1 = this._kernel[i][1] * dir;
          const y1 = this._kernel[i][2];
          if (x1 + x2 >= 0 && x1 + x2 < width && y1 + y2 >= 0 && y1 + y2 < height) {
            const d = this._kernel[i][0];
            const e = errorLines[y1][x1 + x2];
            e[0] += er * d;
            e[1] += eg * d;
            e[2] += eb * d;
            e[3] += ea * d;
          }
        }
      }
    }
    yield {
      pointContainer,
      progress: 100
    };
  }
  _fillErrorLine(errorLine, width) {
    if (errorLine.length > width) {
      errorLine.length = width;
    }
    const l = errorLine.length;
    for (let i = 0; i < l; i++) {
      const error = errorLine[i];
      error[0] = error[1] = error[2] = error[3] = 0;
    }
    for (let i = l; i < width; i++) {
      errorLine[i] = [0, 0, 0, 0];
    }
  }
  _setKernel(kernel) {
    switch (kernel) {
      case 0:
        this._kernel = [
          [7 / 16, 1, 0],
          [3 / 16, -1, 1],
          [5 / 16, 0, 1],
          [1 / 16, 1, 1]
        ];
        break;
      case 1:
        this._kernel = [
          [3 / 8, 1, 0],
          [3 / 8, 0, 1],
          [2 / 8, 1, 1]
        ];
        break;
      case 2:
        this._kernel = [
          [8 / 42, 1, 0],
          [4 / 42, 2, 0],
          [2 / 42, -2, 1],
          [4 / 42, -1, 1],
          [8 / 42, 0, 1],
          [4 / 42, 1, 1],
          [2 / 42, 2, 1],
          [1 / 42, -2, 2],
          [2 / 42, -1, 2],
          [4 / 42, 0, 2],
          [2 / 42, 1, 2],
          [1 / 42, 2, 2]
        ];
        break;
      case 3:
        this._kernel = [
          [1 / 8, 1, 0],
          [1 / 8, 2, 0],
          [1 / 8, -1, 1],
          [1 / 8, 0, 1],
          [1 / 8, 1, 1],
          [1 / 8, 0, 2]
        ];
        break;
      case 4:
        this._kernel = [
          [7 / 48, 1, 0],
          [5 / 48, 2, 0],
          [3 / 48, -2, 1],
          [5 / 48, -1, 1],
          [7 / 48, 0, 1],
          [5 / 48, 1, 1],
          [3 / 48, 2, 1],
          [1 / 48, -2, 2],
          [3 / 48, -1, 2],
          [5 / 48, 0, 2],
          [3 / 48, 1, 2],
          [1 / 48, 2, 2]
        ];
        break;
      case 5:
        this._kernel = [
          [8 / 32, 1, 0],
          [4 / 32, 2, 0],
          [2 / 32, -2, 1],
          [4 / 32, -1, 1],
          [8 / 32, 0, 1],
          [4 / 32, 1, 1],
          [2 / 32, 2, 1]
        ];
        break;
      case 6:
        this._kernel = [
          [5 / 32, 1, 0],
          [3 / 32, 2, 0],
          [2 / 32, -2, 1],
          [4 / 32, -1, 1],
          [5 / 32, 0, 1],
          [4 / 32, 1, 1],
          [2 / 32, 2, 1],
          [2 / 32, -1, 2],
          [3 / 32, 0, 2],
          [2 / 32, 1, 2]
        ];
        break;
      case 7:
        this._kernel = [
          [4 / 16, 1, 0],
          [3 / 16, 2, 0],
          [1 / 16, -2, 1],
          [2 / 16, -1, 1],
          [3 / 16, 0, 1],
          [2 / 16, 1, 1],
          [1 / 16, 2, 1]
        ];
        break;
      case 8:
        this._kernel = [
          [2 / 4, 1, 0],
          [1 / 4, -1, 1],
          [1 / 4, 0, 1]
        ];
        break;
      default:
        throw new Error(`ErrorDiffusionArray: unknown kernel = ${kernel}`);
    }
  }
};
function* hilbertCurve(width, height, callback) {
  const maxBound = Math.max(width, height);
  const level = Math.floor(Math.log(maxBound) / Math.log(2) + 1);
  const tracker = new ProgressTracker(width * height, 99);
  const data = {
    width,
    height,
    level,
    callback,
    tracker,
    index: 0,
    x: 0,
    y: 0
  };
  yield* walkHilbert(
    data,
    1
    /* UP */
  );
  visit(
    data,
    0
    /* NONE */
  );
}
function* walkHilbert(data, direction) {
  if (data.level < 1)
    return;
  if (data.tracker.shouldNotify(data.index)) {
    yield { progress: data.tracker.progress };
  }
  data.level--;
  switch (direction) {
    case 2:
      yield* walkHilbert(
        data,
        1
        /* UP */
      );
      visit(
        data,
        3
        /* RIGHT */
      );
      yield* walkHilbert(
        data,
        2
        /* LEFT */
      );
      visit(
        data,
        4
        /* DOWN */
      );
      yield* walkHilbert(
        data,
        2
        /* LEFT */
      );
      visit(
        data,
        2
        /* LEFT */
      );
      yield* walkHilbert(
        data,
        4
        /* DOWN */
      );
      break;
    case 3:
      yield* walkHilbert(
        data,
        4
        /* DOWN */
      );
      visit(
        data,
        2
        /* LEFT */
      );
      yield* walkHilbert(
        data,
        3
        /* RIGHT */
      );
      visit(
        data,
        1
        /* UP */
      );
      yield* walkHilbert(
        data,
        3
        /* RIGHT */
      );
      visit(
        data,
        3
        /* RIGHT */
      );
      yield* walkHilbert(
        data,
        1
        /* UP */
      );
      break;
    case 1:
      yield* walkHilbert(
        data,
        2
        /* LEFT */
      );
      visit(
        data,
        4
        /* DOWN */
      );
      yield* walkHilbert(
        data,
        1
        /* UP */
      );
      visit(
        data,
        3
        /* RIGHT */
      );
      yield* walkHilbert(
        data,
        1
        /* UP */
      );
      visit(
        data,
        1
        /* UP */
      );
      yield* walkHilbert(
        data,
        3
        /* RIGHT */
      );
      break;
    case 4:
      yield* walkHilbert(
        data,
        3
        /* RIGHT */
      );
      visit(
        data,
        1
        /* UP */
      );
      yield* walkHilbert(
        data,
        4
        /* DOWN */
      );
      visit(
        data,
        2
        /* LEFT */
      );
      yield* walkHilbert(
        data,
        4
        /* DOWN */
      );
      visit(
        data,
        4
        /* DOWN */
      );
      yield* walkHilbert(
        data,
        2
        /* LEFT */
      );
      break;
  }
  data.level++;
}
function visit(data, direction) {
  if (data.x >= 0 && data.x < data.width && data.y >= 0 && data.y < data.height) {
    data.callback(data.x, data.y);
    data.index++;
  }
  switch (direction) {
    case 2:
      data.x--;
      break;
    case 3:
      data.x++;
      break;
    case 1:
      data.y--;
      break;
    case 4:
      data.y++;
      break;
  }
}
var ErrorDiffusionRiemersma = class extends AbstractImageQuantizer {
  constructor(colorDistanceCalculator, errorQueueSize = 16, errorPropagation = 1) {
    super();
    __publicField(this, "_distance");
    __publicField(this, "_weights");
    __publicField(this, "_errorQueueSize");
    this._distance = colorDistanceCalculator;
    this._errorQueueSize = errorQueueSize;
    this._weights = ErrorDiffusionRiemersma._createWeights(errorPropagation, errorQueueSize);
  }
  *quantize(pointContainer, palette) {
    const pointArray = pointContainer.getPointArray();
    const width = pointContainer.getWidth();
    const height = pointContainer.getHeight();
    const errorQueue = [];
    let head = 0;
    for (let i = 0; i < this._errorQueueSize; i++) {
      errorQueue[i] = { r: 0, g: 0, b: 0, a: 0 };
    }
    yield* hilbertCurve(width, height, (x2, y2) => {
      const p = pointArray[x2 + y2 * width];
      let { r, g, b, a } = p;
      for (let i = 0; i < this._errorQueueSize; i++) {
        const weight = this._weights[i];
        const e = errorQueue[(i + head) % this._errorQueueSize];
        r += e.r * weight;
        g += e.g * weight;
        b += e.b * weight;
        a += e.a * weight;
      }
      const correctedPoint = Point.createByRGBA(inRange0to255Rounded(r), inRange0to255Rounded(g), inRange0to255Rounded(b), inRange0to255Rounded(a));
      const quantizedPoint = palette.getNearestColor(this._distance, correctedPoint);
      head = (head + 1) % this._errorQueueSize;
      const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;
      errorQueue[tail].r = p.r - quantizedPoint.r;
      errorQueue[tail].g = p.g - quantizedPoint.g;
      errorQueue[tail].b = p.b - quantizedPoint.b;
      errorQueue[tail].a = p.a - quantizedPoint.a;
      p.from(quantizedPoint);
    });
    yield {
      pointContainer,
      progress: 100
    };
  }
  static _createWeights(errorPropagation, errorQueueSize) {
    const weights = [];
    const multiplier = Math.exp(Math.log(errorQueueSize) / (errorQueueSize - 1));
    for (let i = 0, next = 1; i < errorQueueSize; i++) {
      weights[i] = (next + 0.5 | 0) / errorQueueSize * errorPropagation;
      next *= multiplier;
    }
    return weights;
  }
};
var quality_exports = {};
__export(quality_exports, {
  ssim: () => ssim
});
var K1 = 0.01;
var K2 = 0.03;
function ssim(image1, image2) {
  if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {
    throw new Error("Images have different sizes!");
  }
  const bitsPerComponent = 8;
  const L = (1 << bitsPerComponent) - 1;
  const c1 = (K1 * L) ** 2;
  const c2 = (K2 * L) ** 2;
  let numWindows = 0;
  let mssim = 0;
  iterate(image1, image2, (lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) => {
    let sigxy = 0;
    let sigsqx = 0;
    let sigsqy = 0;
    for (let i = 0; i < lumaValues1.length; i++) {
      sigsqx += (lumaValues1[i] - averageLumaValue1) ** 2;
      sigsqy += (lumaValues2[i] - averageLumaValue2) ** 2;
      sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);
    }
    const numPixelsInWin = lumaValues1.length - 1;
    sigsqx /= numPixelsInWin;
    sigsqy /= numPixelsInWin;
    sigxy /= numPixelsInWin;
    const numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2);
    const denominator = (averageLumaValue1 ** 2 + averageLumaValue2 ** 2 + c1) * (sigsqx + sigsqy + c2);
    const ssim2 = numerator / denominator;
    mssim += ssim2;
    numWindows++;
  });
  return mssim / numWindows;
}
function iterate(image1, image2, callback) {
  const windowSize = 8;
  const width = image1.getWidth();
  const height = image1.getHeight();
  for (let y2 = 0; y2 < height; y2 += windowSize) {
    for (let x2 = 0; x2 < width; x2 += windowSize) {
      const windowWidth = Math.min(windowSize, width - x2);
      const windowHeight = Math.min(windowSize, height - y2);
      const lumaValues1 = calculateLumaValuesForWindow(image1, x2, y2, windowWidth, windowHeight);
      const lumaValues2 = calculateLumaValuesForWindow(image2, x2, y2, windowWidth, windowHeight);
      const averageLuma1 = calculateAverageLuma(lumaValues1);
      const averageLuma2 = calculateAverageLuma(lumaValues2);
      callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);
    }
  }
}
function calculateLumaValuesForWindow(image, x2, y2, width, height) {
  const pointArray = image.getPointArray();
  const lumaValues = [];
  let counter = 0;
  for (let j = y2; j < y2 + height; j++) {
    const offset = j * image.getWidth();
    for (let i = x2; i < x2 + width; i++) {
      const point = pointArray[offset + i];
      lumaValues[counter] = point.r * 0.2126 + point.g * 0.7152 + point.b * 0.0722;
      counter++;
    }
  }
  return lumaValues;
}
function calculateAverageLuma(lumaValues) {
  let sumLuma = 0;
  for (const luma of lumaValues) {
    sumLuma += luma;
  }
  return sumLuma / lumaValues.length;
}
var setImmediateImpl = typeof setImmediate === "function" ? setImmediate : typeof process !== "undefined" && typeof (process == null ? void 0 : process.nextTick) === "function" ? (callback) => process.nextTick(callback) : (callback) => setTimeout(callback, 0);
function buildPaletteSync(images, {
  colorDistanceFormula,
  paletteQuantization,
  colors
} = {}) {
  const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
  const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);
  images.forEach((image) => paletteQuantizer.sample(image));
  return paletteQuantizer.quantizeSync();
}
async function buildPalette(images, {
  colorDistanceFormula,
  paletteQuantization,
  colors,
  onProgress
} = {}) {
  return new Promise((resolve2, reject2) => {
    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
    const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);
    images.forEach((image) => paletteQuantizer.sample(image));
    let palette;
    const iterator = paletteQuantizer.quantize();
    const next = () => {
      try {
        const result = iterator.next();
        if (result.done) {
          resolve2(palette);
        } else {
          if (result.value.palette)
            palette = result.value.palette;
          if (onProgress)
            onProgress(result.value.progress);
          setImmediateImpl(next);
        }
      } catch (error) {
        reject2(error);
      }
    };
    setImmediateImpl(next);
  });
}
function applyPaletteSync(image, palette, { colorDistanceFormula, imageQuantization } = {}) {
  const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
  const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);
  return imageQuantizer.quantizeSync(image, palette);
}
async function applyPalette(image, palette, {
  colorDistanceFormula,
  imageQuantization,
  onProgress
} = {}) {
  return new Promise((resolve2, reject2) => {
    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
    const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);
    let outPointContainer;
    const iterator = imageQuantizer.quantize(image, palette);
    const next = () => {
      try {
        const result = iterator.next();
        if (result.done) {
          resolve2(outPointContainer);
        } else {
          if (result.value.pointContainer) {
            outPointContainer = result.value.pointContainer;
          }
          if (onProgress)
            onProgress(result.value.progress);
          setImmediateImpl(next);
        }
      } catch (error) {
        reject2(error);
      }
    };
    setImmediateImpl(next);
  });
}
function colorDistanceFormulaToColorDistance(colorDistanceFormula = "euclidean-bt709") {
  switch (colorDistanceFormula) {
    case "cie94-graphic-arts":
      return new CIE94GraphicArts();
    case "cie94-textiles":
      return new CIE94Textiles();
    case "ciede2000":
      return new CIEDE2000();
    case "color-metric":
      return new CMetric();
    case "euclidean":
      return new Euclidean();
    case "euclidean-bt709":
      return new EuclideanBT709();
    case "euclidean-bt709-noalpha":
      return new EuclideanBT709NoAlpha();
    case "manhattan":
      return new Manhattan();
    case "manhattan-bt709":
      return new ManhattanBT709();
    case "manhattan-nommyde":
      return new ManhattanNommyde();
    case "pngquant":
      return new PNGQuant();
    default:
      throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);
  }
}
function imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization = "floyd-steinberg") {
  switch (imageQuantization) {
    case "nearest":
      return new NearestColor(distanceCalculator);
    case "riemersma":
      return new ErrorDiffusionRiemersma(distanceCalculator);
    case "floyd-steinberg":
      return new ErrorDiffusionArray(
        distanceCalculator,
        0
        /* FloydSteinberg */
      );
    case "false-floyd-steinberg":
      return new ErrorDiffusionArray(
        distanceCalculator,
        1
        /* FalseFloydSteinberg */
      );
    case "stucki":
      return new ErrorDiffusionArray(
        distanceCalculator,
        2
        /* Stucki */
      );
    case "atkinson":
      return new ErrorDiffusionArray(
        distanceCalculator,
        3
        /* Atkinson */
      );
    case "jarvis":
      return new ErrorDiffusionArray(
        distanceCalculator,
        4
        /* Jarvis */
      );
    case "burkes":
      return new ErrorDiffusionArray(
        distanceCalculator,
        5
        /* Burkes */
      );
    case "sierra":
      return new ErrorDiffusionArray(
        distanceCalculator,
        6
        /* Sierra */
      );
    case "two-sierra":
      return new ErrorDiffusionArray(
        distanceCalculator,
        7
        /* TwoSierra */
      );
    case "sierra-lite":
      return new ErrorDiffusionArray(
        distanceCalculator,
        8
        /* SierraLite */
      );
    default:
      throw new Error(`Unknown imageQuantization ${imageQuantization}`);
  }
}
function paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization = "wuquant", colors = 256) {
  switch (paletteQuantization) {
    case "neuquant":
      return new NeuQuant(distanceCalculator, colors);
    case "rgbquant":
      return new RGBQuant(distanceCalculator, colors);
    case "wuquant":
      return new WuQuant(distanceCalculator, colors);
    case "neuquant-float":
      return new NeuQuantFloat(distanceCalculator, colors);
    default:
      throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);
  }
}
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * cie94.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ciede2000.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * cmetric.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * common.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * constants.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ditherErrorDiffusionArray.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * euclidean.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * helper.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * hueStatistics.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * lab2rgb.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * lab2xyz.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * manhattanNeuQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * nearestColor.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * palette.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * pngQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * point.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * pointContainer.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2hsl.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2lab.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2xyz.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ssim.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * wuQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * xyz2lab.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * xyz2rgb.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * MIT License
 *
 * Copyright 2015-2018 Igor Bezkrovnyi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * riemersma.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * colorHistogram.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * neuquant.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgbquant.ts - part of Image Quantization Library
 */
const imageQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  applyPalette,
  applyPaletteSync,
  buildPalette,
  buildPaletteSync,
  constants: constants_exports,
  conversion: conversion_exports,
  distance: distance_exports,
  image: image_exports,
  palette: palette_exports,
  quality: quality_exports,
  utils: utils_exports
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(imageQ);
var gifframe = {};
const BitmapImage$1 = bitmapimage;
let GifFrame$1 = class GifFrame2 extends BitmapImage$1 {
  // xOffset - x offset of bitmap on GIF (defaults to 0)
  // yOffset - y offset of bitmap on GIF (defaults to 0)
  // disposalMethod - pixel disposal method when handling partial images
  // delayCentisecs - duration of frame in hundredths of a second
  // interlaced - whether the image is interlaced (defaults to false)
  /**
   * GifFrame is a class representing an image frame of a GIF. GIFs contain one or more instances of GifFrame.
   * 
   * Property | Description
   * --- | ---
   * xOffset | x-coord of position within GIF at which to render the image (defaults to 0)
   * yOffset | y-coord of position within GIF at which to render the image (defaults to 0)
   * disposalMethod | GIF disposal method; only relevant when the frames aren't all the same size (defaults to 2, disposing to background color)
   * delayCentisecs | duration of the frame in hundreths of a second
   * interlaced | boolean indicating whether the frame renders interlaced
   * 
   * Its constructor supports the following signatures:
   * 
   * * new GifFrame(bitmap: {width: number, height: number, data: Buffer}, options?)
   * * new GifFrame(bitmapImage: BitmapImage, options?)
   * * new GifFrame(width: number, height: number, buffer: Buffer, options?)
   * * new GifFrame(width: number, height: number, backgroundRGBA?: number, options?)
   * * new GifFrame(frame: GifFrame)
   * 
   * See the base class BitmapImage for a discussion of all parameters but `options` and `frame`. `options` is an optional argument providing initial values for the above-listed GifFrame properties. Each property within option is itself optional.
   * 
   * Provide a `frame` to the constructor to create a clone of the provided frame. The new frame includes a copy of the provided frame's pixel data so that each can subsequently be modified without affecting each other.
   */
  constructor(...args) {
    super(...args);
    if (args[0] instanceof GifFrame2) {
      const source = args[0];
      this.xOffset = source.xOffset;
      this.yOffset = source.yOffset;
      this.disposalMethod = source.disposalMethod;
      this.delayCentisecs = source.delayCentisecs;
      this.interlaced = source.interlaced;
    } else {
      const lastArg = args[args.length - 1];
      let options = {};
      if (typeof lastArg === "object" && !(lastArg instanceof BitmapImage$1)) {
        options = lastArg;
      }
      this.xOffset = options.xOffset || 0;
      this.yOffset = options.yOffset || 0;
      this.disposalMethod = options.disposalMethod !== void 0 ? options.disposalMethod : GifFrame2.DisposeToBackgroundColor;
      this.delayCentisecs = options.delayCentisecs || 8;
      this.interlaced = options.interlaced || false;
    }
  }
  /**
   * Get a summary of the colors found within the frame. The return value is an object of the following form:
   * 
   * Property | Description
   * --- | ---
   * colors | An array of all the opaque colors found within the frame. Each color is given as an RGB number of the form 0xRRGGBB. The array is sorted by increasing number. Will be an empty array when the image is completely transparent.
   * usesTransparency | boolean indicating whether there are any transparent pixels within the frame. A pixel is considered transparent if its alpha value is 0x00.
   * indexCount | The number of color indexes required to represent this palette of colors. It is equal to the number of opaque colors plus one if the image includes transparency.
   * 
   * @return {object} An object representing a color palette as described above.
   */
  getPalette() {
    const colorSet = /* @__PURE__ */ new Set();
    const buf = this.bitmap.data;
    let i = 0;
    let usesTransparency = false;
    while (i < buf.length) {
      if (buf[i + 3] === 0) {
        usesTransparency = true;
      } else {
        const color = buf.readUInt32BE(i, true) >> 8 & 16777215;
        colorSet.add(color);
      }
      i += 4;
    }
    const colors = new Array(colorSet.size);
    const iter = colorSet.values();
    for (i = 0; i < colors.length; ++i) {
      colors[i] = iter.next().value;
    }
    colors.sort((a, b) => a - b);
    let indexCount = colors.length;
    if (usesTransparency) {
      ++indexCount;
    }
    return { colors, usesTransparency, indexCount };
  }
};
GifFrame$1.DisposeToAnything = 0;
GifFrame$1.DisposeNothing = 1;
GifFrame$1.DisposeToBackgroundColor = 2;
GifFrame$1.DisposeToPrevious = 3;
gifframe.GifFrame = GifFrame$1;
var hasRequiredGifutil;
function requireGifutil() {
  if (hasRequiredGifutil) return gifutil;
  hasRequiredGifutil = 1;
  (function(exports) {
    const fs$1 = fs;
    const ImageQ = require$$1;
    const BitmapImage3 = bitmapimage;
    const { GifFrame: GifFrame3 } = gifframe;
    const { GifError: GifError3 } = gif$1;
    const { GifCodec: GifCodec2 } = requireGifcodec();
    const INVALID_SUFFIXES = [".jpg", ".jpeg", ".png", ".bmp"];
    const defaultCodec = new GifCodec2();
    exports.cloneFrames = function(frames) {
      let clones = [];
      frames.forEach((frame) => {
        clones.push(new GifFrame3(frame));
      });
      return clones;
    };
    exports.getColorInfo = function(frames, maxGlobalIndex) {
      let usesTransparency = false;
      const palettes = [];
      for (let i = 0; i < frames.length; ++i) {
        let palette = frames[i].getPalette();
        if (palette.usesTransparency) {
          usesTransparency = true;
        }
        if (palette.indexCount > 256) {
          throw new GifError3(`Frame ${i} uses more than 256 color indexes`);
        }
        palettes.push(palette);
      }
      if (maxGlobalIndex === 0) {
        return { usesTransparency, palettes };
      }
      const globalColorSet = /* @__PURE__ */ new Set();
      palettes.forEach((palette) => {
        palette.colors.forEach((color) => {
          globalColorSet.add(color);
        });
      });
      let indexCount = globalColorSet.size;
      if (usesTransparency) {
        ++indexCount;
      }
      if (maxGlobalIndex && indexCount > maxGlobalIndex) {
        return { usesTransparency, palettes };
      }
      const colors = new Array(globalColorSet.size);
      const iter = globalColorSet.values();
      for (let i = 0; i < colors.length; ++i) {
        colors[i] = iter.next().value;
      }
      colors.sort((a, b) => a - b);
      return { colors, indexCount, usesTransparency, palettes };
    };
    exports.copyAsJimp = function(jimp, bitmapImageToCopy) {
      return exports.shareAsJimp(jimp, new BitmapImage3(bitmapImageToCopy));
    };
    exports.getMaxDimensions = function(frames) {
      let maxWidth = 0, maxHeight = 0;
      frames.forEach((frame) => {
        const width = frame.xOffset + frame.bitmap.width;
        if (width > maxWidth) {
          maxWidth = width;
        }
        const height = frame.yOffset + frame.bitmap.height;
        if (height > maxHeight) {
          maxHeight = height;
        }
      });
      return { maxWidth, maxHeight };
    };
    exports.quantizeDekker = function(imageOrImages, maxColorIndexes, dither) {
      maxColorIndexes = maxColorIndexes || 256;
      _quantize(imageOrImages, "NeuQuantFloat", maxColorIndexes, 0, dither);
    };
    exports.quantizeSorokin = function(imageOrImages, maxColorIndexes, histogram2, dither) {
      maxColorIndexes = maxColorIndexes || 256;
      histogram2 = histogram2 || "min-pop";
      let histogramID;
      switch (histogram2) {
        case "min-pop":
          histogramID = 2;
          break;
        case "top-pop":
          histogramID = 1;
          break;
        default:
          throw new Error(`Invalid quantizeSorokin histogram '${histogram2}'`);
      }
      _quantize(imageOrImages, "RGBQuant", maxColorIndexes, histogramID, dither);
    };
    exports.quantizeWu = function(imageOrImages, maxColorIndexes, significantBits, dither) {
      maxColorIndexes = maxColorIndexes || 256;
      significantBits = significantBits || 5;
      if (significantBits < 1 || significantBits > 8) {
        throw new Error("Invalid quantization quality");
      }
      _quantize(imageOrImages, "WuQuant", maxColorIndexes, significantBits, dither);
    };
    exports.read = function(source, decoder2) {
      decoder2 = decoder2 || defaultCodec;
      if (Buffer.isBuffer(source)) {
        return decoder2.decodeGif(source);
      }
      return _readBinary(source).then((buffer) => {
        return decoder2.decodeGif(buffer);
      });
    };
    exports.shareAsJimp = function(jimp, bitmapImageToShare) {
      const jimpImage = new jimp(
        bitmapImageToShare.bitmap.width,
        bitmapImageToShare.bitmap.height,
        0
      );
      jimpImage.bitmap.data = bitmapImageToShare.bitmap.data;
      return jimpImage;
    };
    exports.write = function(path2, frames, spec, encoder2) {
      encoder2 = encoder2 || defaultCodec;
      const matches = path2.match(/\.[a-zA-Z]+$/);
      if (matches !== null && INVALID_SUFFIXES.includes(matches[0].toLowerCase())) {
        throw new Error(`GIF '${path2}' has an unexpected suffix`);
      }
      return encoder2.encodeGif(frames, spec).then((gif2) => {
        return _writeBinary(path2, gif2.buffer).then(() => {
          return gif2;
        });
      });
    };
    function _quantize(imageOrImages, method, maxColorIndexes, modifier, dither) {
      const images = Array.isArray(imageOrImages) ? imageOrImages : [imageOrImages];
      const ditherAlgs = [
        "FloydSteinberg",
        "FalseFloydSteinberg",
        "Stucki",
        "Atkinson",
        "Jarvis",
        "Burkes",
        "Sierra",
        "TwoSierra",
        "SierraLite"
      ];
      if (dither) {
        if (ditherAlgs.indexOf(dither.ditherAlgorithm) < 0) {
          throw new Error(`Invalid ditherAlgorithm '${dither.ditherAlgorithm}'`);
        }
        if (dither.serpentine === void 0) {
          dither.serpentine = true;
        }
        if (dither.minimumColorDistanceToDither === void 0) {
          dither.minimumColorDistanceToDither = 0;
        }
        if (dither.calculateErrorLikeGIMP === void 0) {
          dither.calculateErrorLikeGIMP = false;
        }
      }
      const distCalculator = new ImageQ.distance.Euclidean();
      const quantizer = new ImageQ.palette[method](distCalculator, maxColorIndexes, modifier);
      let imageMaker;
      if (dither) {
        imageMaker = new ImageQ.image.ErrorDiffusionArray(
          distCalculator,
          ImageQ.image.ErrorDiffusionArrayKernel[dither.ditherAlgorithm],
          dither.serpentine,
          dither.minimumColorDistanceToDither,
          dither.calculateErrorLikeGIMP
        );
      } else {
        imageMaker = new ImageQ.image.NearestColor(distCalculator);
      }
      const inputContainers = [];
      images.forEach((image) => {
        const imageBuf = image.bitmap.data;
        const inputBuf = new ArrayBuffer(imageBuf.length);
        const inputArray = new Uint32Array(inputBuf);
        for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) {
          inputArray[ai] = imageBuf.readUInt32LE(bi, true);
        }
        const inputContainer = ImageQ.utils.PointContainer.fromUint32Array(
          inputArray,
          image.bitmap.width,
          image.bitmap.height
        );
        quantizer.sample(inputContainer);
        inputContainers.push(inputContainer);
      });
      const limitedPalette = quantizer.quantizeSync();
      for (let i = 0; i < images.length; ++i) {
        const imageBuf = images[i].bitmap.data;
        const outputContainer = imageMaker.quantizeSync(inputContainers[i], limitedPalette);
        const outputArray = outputContainer.toUint32Array();
        for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) {
          imageBuf.writeUInt32LE(outputArray[ai], bi);
        }
      }
    }
    function _readBinary(path2) {
      return new Promise((resolve2, reject2) => {
        fs$1.readFile(path2, (err, buffer) => {
          if (err) {
            return reject2(err);
          }
          return resolve2(buffer);
        });
      });
    }
    function _writeBinary(path2, buffer) {
      return new Promise((resolve2, reject2) => {
        fs$1.writeFile(path2, buffer, (err) => {
          if (err) {
            return reject2(err);
          }
          return resolve2();
        });
      });
    }
  })(gifutil);
  return gifutil;
}
var hasRequiredGifcodec;
function requireGifcodec() {
  if (hasRequiredGifcodec) return gifcodec;
  hasRequiredGifcodec = 1;
  const Omggif = omggif;
  const { Gif: Gif3, GifError: GifError3 } = gif$1;
  function GifUtil2() {
    const data = requireGifutil();
    GifUtil2 = function() {
      return data;
    };
    return data;
  }
  const { GifFrame: GifFrame3 } = gifframe;
  const PER_GIF_OVERHEAD = 200;
  const PER_FRAME_OVERHEAD = 100;
  class GifCodec2 {
    // _transparentRGBA - RGB given to transparent pixels (alpha=0) on decode; defaults to null indicating 0x000000, which is fastest
    /**
     * GifCodec is a class that both encodes and decodes GIFs. It implements both the `encode()` method expected of an encoder and the `decode()` method expected of a decoder, and it wraps the `omggif` GIF encoder/decoder package. GifCodec serves as this library's default encoder and decoder, but it's possible to wrap other GIF encoders and decoders for use by `gifwrap` as well. GifCodec will not encode GIFs with interlacing.
     * 
     * Instances of this class are stateless and can be shared across multiple encodings and decodings.
     * 
     * Its constructor takes one option argument:
     * 
     * @param {object} options Optionally takes an objection whose only possible property is `transparentRGB`. Images are internally represented in RGBA format, where A is the alpha value of a pixel. When `transparentRGB` is provided, this RGB value (excluding alpha) is assigned to transparent pixels, which are also given alpha value 0x00. (All opaque pixels are given alpha value 0xFF). The RGB color of transparent pixels shouldn't matter for most applications. Defaults to 0x000000.
     */
    constructor(options = {}) {
      this._transparentRGB = null;
      if (typeof options.transparentRGB === "number" && options.transparentRGB !== 0) {
        this._transparentRGBA = options.transparentRGB * 256;
      }
      this._testInitialBufferSize = 0;
    }
    /**
     * Decodes a GIF from a Buffer to yield an instance of Gif. Transparent pixels of the GIF are given alpha values of 0x00, and opaque pixels are given alpha values of 0xFF. The RGB values of transparent pixels default to 0x000000 but can be overridden by the constructor's `transparentRGB` option.
     * 
     * @param {Buffer} buffer Bytes of an encoded GIF to decode.
     * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.
     * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.
     */
    decodeGif(buffer) {
      try {
        let reader;
        try {
          reader = new Omggif.GifReader(buffer);
        } catch (err) {
          throw new GifError3(err);
        }
        const frameCount = reader.numFrames();
        const frames = [];
        const spec = {
          width: reader.width,
          height: reader.height,
          loops: reader.loopCount()
        };
        spec.usesTransparency = false;
        for (let i = 0; i < frameCount; ++i) {
          const frameInfo = this._decodeFrame(reader, i, spec.usesTransparency);
          frames.push(frameInfo.frame);
          if (frameInfo.usesTransparency) {
            spec.usesTransparency = true;
          }
        }
        return Promise.resolve(new Gif3(buffer, frames, spec));
      } catch (err) {
        return Promise.reject(err);
      }
    }
    /**
     * Encodes a GIF from provided frames. Each pixel having an alpha value of 0x00 renders as transparent within the encoding, while all pixels of non-zero alpha value render as opaque.
     * 
     * @param {GifFrame[]} frames Array of frames to encode
     * @param {object} spec An optional object that may provide values for `loops` and `colorScope`, as defined for the Gif class. However, `colorSpace` may also take the value Gif.GlobalColorsPreferred (== 0) to indicate that the encoder should attempt to create only a global color table. `loop` defaults to 0, looping indefinitely. Set `loop` to null to disable looping, playing only once. `colorScope` defaults to Gif.GlobalColorsPreferred.
     * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.
     * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.
     */
    encodeGif(frames, spec = {}) {
      try {
        if (frames === null || frames.length === 0) {
          throw new GifError3("there are no frames");
        }
        const dims = GifUtil2().getMaxDimensions(frames);
        spec = Object.assign({}, spec);
        spec.width = dims.maxWidth;
        spec.height = dims.maxHeight;
        if (spec.loops === void 0) {
          spec.loops = 0;
        }
        spec.colorScope = spec.colorScope || Gif3.GlobalColorsPreferred;
        return Promise.resolve(this._encodeGif(frames, spec));
      } catch (err) {
        return Promise.reject(err);
      }
    }
    _decodeFrame(reader, frameIndex, alreadyUsedTransparency) {
      let info, buffer;
      try {
        info = reader.frameInfo(frameIndex);
        buffer = new Buffer(reader.width * reader.height * 4);
        reader.decodeAndBlitFrameRGBA(frameIndex, buffer);
        if (info.width !== reader.width || info.height !== reader.height) {
          if (info.y) {
            buffer = buffer.slice(info.y * reader.width * 4);
          }
          if (reader.width > info.width) {
            for (let ii = 0; ii < info.height; ++ii) {
              buffer.copy(
                buffer,
                ii * info.width * 4,
                (info.x + ii * reader.width) * 4,
                (info.x + ii * reader.width) * 4 + info.width * 4
              );
            }
          }
          buffer = buffer.slice(0, info.width * info.height * 4);
        }
      } catch (err) {
        throw new GifError3(err);
      }
      let usesTransparency = false;
      if (this._transparentRGBA === null) {
        if (!alreadyUsedTransparency) {
          for (let i = 3; i < buffer.length; i += 4) {
            if (buffer[i] === 0) {
              usesTransparency = true;
              i = buffer.length;
            }
          }
        }
      } else {
        for (let i = 3; i < buffer.length; i += 4) {
          if (buffer[i] === 0) {
            buffer.writeUInt32BE(this._transparentRGBA, i - 3);
            usesTransparency = true;
          }
        }
      }
      const frame = new GifFrame3(info.width, info.height, buffer, {
        xOffset: info.x,
        yOffset: info.y,
        disposalMethod: info.disposal,
        interlaced: info.interlaced,
        delayCentisecs: info.delay
      });
      return { frame, usesTransparency };
    }
    _encodeGif(frames, spec) {
      let colorInfo;
      if (spec.colorScope === Gif3.LocalColorsOnly) {
        colorInfo = GifUtil2().getColorInfo(frames, 0);
      } else {
        colorInfo = GifUtil2().getColorInfo(frames, 256);
        if (!colorInfo.colors) {
          if (spec.colorScope === Gif3.GlobalColorsOnly) {
            throw new GifError3(
              "Too many color indexes for global color table"
            );
          }
          spec.colorScope = Gif3.LocalColorsOnly;
        }
      }
      spec.usesTransparency = colorInfo.usesTransparency;
      const localPalettes = colorInfo.palettes;
      if (spec.colorScope === Gif3.LocalColorsOnly) {
        const localSizeEst = 2e3;
        return _encodeLocal(frames, spec, localSizeEst, localPalettes);
      }
      const globalSizeEst = 2e3;
      return _encodeGlobal(frames, spec, globalSizeEst, colorInfo);
    }
    _getSizeEstimateGlobal(globalPalette, frames) {
      if (this._testInitialBufferSize > 0) {
        return this._testInitialBufferSize;
      }
      let sizeEst = PER_GIF_OVERHEAD + 3 * 256;
      const pixelBitWidth = _getPixelBitWidth(globalPalette);
      frames.forEach((frame) => {
        sizeEst += _getFrameSizeEst(frame, pixelBitWidth);
      });
      return sizeEst;
    }
    _getSizeEstimateLocal(palettes, frames) {
      if (this._testInitialBufferSize > 0) {
        return this._testInitialBufferSize;
      }
      let sizeEst = PER_GIF_OVERHEAD;
      for (let i = 0; i < frames.length; ++i) {
        const palette = palettes[i];
        const pixelBitWidth = _getPixelBitWidth(palette);
        sizeEst += _getFrameSizeEst(frames[i], pixelBitWidth);
      }
      return sizeEst;
    }
  }
  gifcodec.GifCodec = GifCodec2;
  function _colorLookupLinear(colors, color) {
    const index = colors.indexOf(color);
    return index === -1 ? null : index;
  }
  function _colorLookupBinary(colors, color) {
    var lo = 0, hi = colors.length - 1, mid;
    while (lo <= hi) {
      mid = Math.floor((lo + hi) / 2);
      if (colors[mid] > color)
        hi = mid - 1;
      else if (colors[mid] < color)
        lo = mid + 1;
      else
        return mid;
    }
    return null;
  }
  function _encodeGlobal(frames, spec, bufferSizeEst, globalPalette) {
    const extendedGlobalPalette = {
      colors: globalPalette.colors.slice(),
      usesTransparency: globalPalette.usesTransparency
    };
    _extendPaletteToPowerOf2(extendedGlobalPalette);
    const options = {
      palette: extendedGlobalPalette.colors,
      loop: spec.loops
    };
    let buffer = new Buffer(bufferSizeEst);
    let gifWriter;
    try {
      gifWriter = new Omggif.GifWriter(
        buffer,
        spec.width,
        spec.height,
        options
      );
    } catch (err) {
      throw new GifError3(err);
    }
    for (let i = 0; i < frames.length; ++i) {
      buffer = _writeFrame(gifWriter, i, frames[i], globalPalette, false);
    }
    return new Gif3(buffer.slice(0, gifWriter.end()), frames, spec);
  }
  function _encodeLocal(frames, spec, bufferSizeEst, localPalettes) {
    const options = {
      loop: spec.loops
    };
    let buffer = new Buffer(bufferSizeEst);
    let gifWriter;
    try {
      gifWriter = new Omggif.GifWriter(
        buffer,
        spec.width,
        spec.height,
        options
      );
    } catch (err) {
      throw new GifError3(err);
    }
    for (let i = 0; i < frames.length; ++i) {
      buffer = _writeFrame(gifWriter, i, frames[i], localPalettes[i], true);
    }
    return new Gif3(buffer.slice(0, gifWriter.end()), frames, spec);
  }
  function _extendPaletteToPowerOf2(palette) {
    const colors = palette.colors;
    if (palette.usesTransparency) {
      colors.push(0);
    }
    const colorCount = colors.length;
    let powerOf2 = 2;
    while (colorCount > powerOf2) {
      powerOf2 <<= 1;
    }
    colors.length = powerOf2;
    colors.fill(0, colorCount);
  }
  function _getFrameSizeEst(frame, pixelBitWidth) {
    let byteLength = frame.bitmap.width * frame.bitmap.height;
    byteLength = Math.ceil(byteLength * pixelBitWidth / 8);
    byteLength += Math.ceil(byteLength / 255);
    return PER_FRAME_OVERHEAD + byteLength + 3 * 256;
  }
  function _getIndexedImage(frameIndex, frame, palette) {
    const colors = palette.colors;
    const colorToIndexFunc = colors.length <= 8 ? (
      // guess at the break-even
      _colorLookupLinear
    ) : _colorLookupBinary;
    const colorBuffer = frame.bitmap.data;
    const indexBuffer = new Buffer(colorBuffer.length / 4);
    let transparentIndex = colors.length;
    let i = 0, j = 0;
    while (i < colorBuffer.length) {
      if (colorBuffer[i + 3] !== 0) {
        const color = colorBuffer.readUInt32BE(i, true) >> 8 & 16777215;
        indexBuffer[j] = colorToIndexFunc(colors, color);
      } else {
        indexBuffer[j] = transparentIndex;
      }
      i += 4;
      ++j;
    }
    if (palette.usesTransparency) {
      if (transparentIndex === 256) {
        throw new GifError3(`Frame ${frameIndex} already has 256 colorsand so can't use transparency`);
      }
    } else {
      transparentIndex = null;
    }
    return { buffer: indexBuffer, transparentIndex };
  }
  function _getPixelBitWidth(palette) {
    let indexCount = palette.indexCount;
    let pixelBitWidth = 0;
    --indexCount;
    while (indexCount) {
      ++pixelBitWidth;
      indexCount >>= 1;
    }
    return pixelBitWidth > 0 ? pixelBitWidth : 1;
  }
  function _writeFrame(gifWriter, frameIndex, frame, palette, isLocalPalette) {
    if (frame.interlaced) {
      throw new GifError3("writing interlaced GIFs is not supported");
    }
    const frameInfo = _getIndexedImage(frameIndex, frame, palette);
    const options = {
      delay: frame.delayCentisecs,
      disposal: frame.disposalMethod,
      transparent: frameInfo.transparentIndex
    };
    if (isLocalPalette) {
      _extendPaletteToPowerOf2(palette);
      options.palette = palette.colors;
    }
    try {
      let buffer = gifWriter.getOutputBuffer();
      let startOfFrame = gifWriter.getOutputBufferPosition();
      let endOfFrame;
      let tryAgain = true;
      while (tryAgain) {
        endOfFrame = gifWriter.addFrame(
          frame.xOffset,
          frame.yOffset,
          frame.bitmap.width,
          frame.bitmap.height,
          frameInfo.buffer,
          options
        );
        tryAgain = false;
        if (endOfFrame >= buffer.length - 1) {
          const biggerBuffer = new Buffer(buffer.length * 1.5);
          buffer.copy(biggerBuffer);
          gifWriter.setOutputBuffer(biggerBuffer);
          gifWriter.setOutputBufferPosition(startOfFrame);
          buffer = biggerBuffer;
          tryAgain = true;
        }
      }
      return buffer;
    } catch (err) {
      throw new GifError3(err);
    }
  }
  return gifcodec;
}
const BitmapImage = bitmapimage;
const { Gif, GifError: GifError$1 } = gif$1;
const { GifCodec } = requireGifcodec();
const { GifFrame } = gifframe;
const GifUtil = requireGifutil();
var src = {
  BitmapImage,
  Gif,
  GifCodec,
  GifFrame,
  GifUtil,
  GifError: GifError$1
};
function gif() {
  return {
    mime: "image/gif",
    encode: async (bitmap) => {
      const gif2 = new src.BitmapImage(bitmap);
      src.GifUtil.quantizeDekker(gif2, 256);
      const newFrame = new src.GifFrame(bitmap);
      const gifCodec = new src.GifCodec();
      const newGif = await gifCodec.encodeGif([newFrame], {});
      return newGif.buffer;
    },
    decode: (data) => {
      const gifObj = new omggif.GifReader(data);
      const gifData = Buffer.alloc(gifObj.width * gifObj.height * 4);
      gifObj.decodeAndBlitFrameRGBA(0, gifData);
      return {
        data: gifData,
        width: gifObj.width,
        height: gifObj.height
      };
    }
  };
}
var encoder = { exports: {} };
(function(module) {
  function JPEGEncoder(quality) {
    var ffloor = Math.floor;
    var YTable = new Array(64);
    var UVTable = new Array(64);
    var fdtbl_Y = new Array(64);
    var fdtbl_UV = new Array(64);
    var YDC_HT;
    var UVDC_HT;
    var YAC_HT;
    var UVAC_HT;
    var bitcode = new Array(65535);
    var category = new Array(65535);
    var outputfDCTQuant = new Array(64);
    var DU = new Array(64);
    var byteout = [];
    var bytenew = 0;
    var bytepos = 7;
    var YDU = new Array(64);
    var UDU = new Array(64);
    var VDU = new Array(64);
    var clt = new Array(256);
    var RGB_YUV_TABLE = new Array(2048);
    var currentQuality;
    var ZigZag = [
      0,
      1,
      5,
      6,
      14,
      15,
      27,
      28,
      2,
      4,
      7,
      13,
      16,
      26,
      29,
      42,
      3,
      8,
      12,
      17,
      25,
      30,
      41,
      43,
      9,
      11,
      18,
      24,
      31,
      40,
      44,
      53,
      10,
      19,
      23,
      32,
      39,
      45,
      52,
      54,
      20,
      22,
      33,
      38,
      46,
      51,
      55,
      60,
      21,
      34,
      37,
      47,
      50,
      56,
      59,
      61,
      35,
      36,
      48,
      49,
      57,
      58,
      62,
      63
    ];
    var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
    var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
    var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
    var std_ac_luminance_values = [
      1,
      2,
      3,
      0,
      4,
      17,
      5,
      18,
      33,
      49,
      65,
      6,
      19,
      81,
      97,
      7,
      34,
      113,
      20,
      50,
      129,
      145,
      161,
      8,
      35,
      66,
      177,
      193,
      21,
      82,
      209,
      240,
      36,
      51,
      98,
      114,
      130,
      9,
      10,
      22,
      23,
      24,
      25,
      26,
      37,
      38,
      39,
      40,
      41,
      42,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      67,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      99,
      100,
      101,
      102,
      103,
      104,
      105,
      106,
      115,
      116,
      117,
      118,
      119,
      120,
      121,
      122,
      131,
      132,
      133,
      134,
      135,
      136,
      137,
      138,
      146,
      147,
      148,
      149,
      150,
      151,
      152,
      153,
      154,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      225,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      241,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250
    ];
    var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
    var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
    var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
    var std_ac_chrominance_values = [
      0,
      1,
      2,
      3,
      17,
      4,
      5,
      33,
      49,
      6,
      18,
      65,
      81,
      7,
      97,
      113,
      19,
      34,
      50,
      129,
      8,
      20,
      66,
      145,
      161,
      177,
      193,
      9,
      35,
      51,
      82,
      240,
      21,
      98,
      114,
      209,
      10,
      22,
      36,
      52,
      225,
      37,
      241,
      23,
      24,
      25,
      26,
      38,
      39,
      40,
      41,
      42,
      53,
      54,
      55,
      56,
      57,
      58,
      67,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      99,
      100,
      101,
      102,
      103,
      104,
      105,
      106,
      115,
      116,
      117,
      118,
      119,
      120,
      121,
      122,
      130,
      131,
      132,
      133,
      134,
      135,
      136,
      137,
      138,
      146,
      147,
      148,
      149,
      150,
      151,
      152,
      153,
      154,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250
    ];
    function initQuantTables(sf) {
      var YQT = [
        16,
        11,
        10,
        16,
        24,
        40,
        51,
        61,
        12,
        12,
        14,
        19,
        26,
        58,
        60,
        55,
        14,
        13,
        16,
        24,
        40,
        57,
        69,
        56,
        14,
        17,
        22,
        29,
        51,
        87,
        80,
        62,
        18,
        22,
        37,
        56,
        68,
        109,
        103,
        77,
        24,
        35,
        55,
        64,
        81,
        104,
        113,
        92,
        49,
        64,
        78,
        87,
        103,
        121,
        120,
        101,
        72,
        92,
        95,
        98,
        112,
        100,
        103,
        99
      ];
      for (var i = 0; i < 64; i++) {
        var t = ffloor((YQT[i] * sf + 50) / 100);
        if (t < 1) {
          t = 1;
        } else if (t > 255) {
          t = 255;
        }
        YTable[ZigZag[i]] = t;
      }
      var UVQT = [
        17,
        18,
        24,
        47,
        99,
        99,
        99,
        99,
        18,
        21,
        26,
        66,
        99,
        99,
        99,
        99,
        24,
        26,
        56,
        99,
        99,
        99,
        99,
        99,
        47,
        66,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99
      ];
      for (var j = 0; j < 64; j++) {
        var u = ffloor((UVQT[j] * sf + 50) / 100);
        if (u < 1) {
          u = 1;
        } else if (u > 255) {
          u = 255;
        }
        UVTable[ZigZag[j]] = u;
      }
      var aasf = [
        1,
        1.387039845,
        1.306562965,
        1.175875602,
        1,
        0.785694958,
        0.5411961,
        0.275899379
      ];
      var k = 0;
      for (var row = 0; row < 8; row++) {
        for (var col = 0; col < 8; col++) {
          fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
          fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
          k++;
        }
      }
    }
    function computeHuffmanTbl(nrcodes, std_table) {
      var codevalue = 0;
      var pos_in_table = 0;
      var HT = new Array();
      for (var k = 1; k <= 16; k++) {
        for (var j = 1; j <= nrcodes[k]; j++) {
          HT[std_table[pos_in_table]] = [];
          HT[std_table[pos_in_table]][0] = codevalue;
          HT[std_table[pos_in_table]][1] = k;
          pos_in_table++;
          codevalue++;
        }
        codevalue *= 2;
      }
      return HT;
    }
    function initHuffmanTbl() {
      YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
      UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
      YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
      UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
    }
    function initCategoryNumber() {
      var nrlower = 1;
      var nrupper = 2;
      for (var cat = 1; cat <= 15; cat++) {
        for (var nr = nrlower; nr < nrupper; nr++) {
          category[32767 + nr] = cat;
          bitcode[32767 + nr] = [];
          bitcode[32767 + nr][1] = cat;
          bitcode[32767 + nr][0] = nr;
        }
        for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
          category[32767 + nrneg] = cat;
          bitcode[32767 + nrneg] = [];
          bitcode[32767 + nrneg][1] = cat;
          bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
        }
        nrlower <<= 1;
        nrupper <<= 1;
      }
    }
    function initRGBYUVTable() {
      for (var i = 0; i < 256; i++) {
        RGB_YUV_TABLE[i] = 19595 * i;
        RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;
        RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 32768;
        RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;
        RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;
        RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 8421375;
        RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;
        RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
      }
    }
    function writeBits(bs) {
      var value = bs[0];
      var posval = bs[1] - 1;
      while (posval >= 0) {
        if (value & 1 << posval) {
          bytenew |= 1 << bytepos;
        }
        posval--;
        bytepos--;
        if (bytepos < 0) {
          if (bytenew == 255) {
            writeByte(255);
            writeByte(0);
          } else {
            writeByte(bytenew);
          }
          bytepos = 7;
          bytenew = 0;
        }
      }
    }
    function writeByte(value) {
      byteout.push(value);
    }
    function writeWord(value) {
      writeByte(value >> 8 & 255);
      writeByte(value & 255);
    }
    function fDCTQuant(data, fdtbl) {
      var d0, d1, d2, d3, d4, d5, d6, d7;
      var dataOff = 0;
      var i;
      var I8 = 8;
      var I64 = 64;
      for (i = 0; i < I8; ++i) {
        d0 = data[dataOff];
        d1 = data[dataOff + 1];
        d2 = data[dataOff + 2];
        d3 = data[dataOff + 3];
        d4 = data[dataOff + 4];
        d5 = data[dataOff + 5];
        d6 = data[dataOff + 6];
        d7 = data[dataOff + 7];
        var tmp0 = d0 + d7;
        var tmp7 = d0 - d7;
        var tmp1 = d1 + d6;
        var tmp6 = d1 - d6;
        var tmp2 = d2 + d5;
        var tmp5 = d2 - d5;
        var tmp3 = d3 + d4;
        var tmp4 = d3 - d4;
        var tmp10 = tmp0 + tmp3;
        var tmp13 = tmp0 - tmp3;
        var tmp11 = tmp1 + tmp2;
        var tmp12 = tmp1 - tmp2;
        data[dataOff] = tmp10 + tmp11;
        data[dataOff + 4] = tmp10 - tmp11;
        var z1 = (tmp12 + tmp13) * 0.707106781;
        data[dataOff + 2] = tmp13 + z1;
        data[dataOff + 6] = tmp13 - z1;
        tmp10 = tmp4 + tmp5;
        tmp11 = tmp5 + tmp6;
        tmp12 = tmp6 + tmp7;
        var z5 = (tmp10 - tmp12) * 0.382683433;
        var z2 = 0.5411961 * tmp10 + z5;
        var z4 = 1.306562965 * tmp12 + z5;
        var z3 = tmp11 * 0.707106781;
        var z11 = tmp7 + z3;
        var z13 = tmp7 - z3;
        data[dataOff + 5] = z13 + z2;
        data[dataOff + 3] = z13 - z2;
        data[dataOff + 1] = z11 + z4;
        data[dataOff + 7] = z11 - z4;
        dataOff += 8;
      }
      dataOff = 0;
      for (i = 0; i < I8; ++i) {
        d0 = data[dataOff];
        d1 = data[dataOff + 8];
        d2 = data[dataOff + 16];
        d3 = data[dataOff + 24];
        d4 = data[dataOff + 32];
        d5 = data[dataOff + 40];
        d6 = data[dataOff + 48];
        d7 = data[dataOff + 56];
        var tmp0p2 = d0 + d7;
        var tmp7p2 = d0 - d7;
        var tmp1p2 = d1 + d6;
        var tmp6p2 = d1 - d6;
        var tmp2p2 = d2 + d5;
        var tmp5p2 = d2 - d5;
        var tmp3p2 = d3 + d4;
        var tmp4p2 = d3 - d4;
        var tmp10p2 = tmp0p2 + tmp3p2;
        var tmp13p2 = tmp0p2 - tmp3p2;
        var tmp11p2 = tmp1p2 + tmp2p2;
        var tmp12p2 = tmp1p2 - tmp2p2;
        data[dataOff] = tmp10p2 + tmp11p2;
        data[dataOff + 32] = tmp10p2 - tmp11p2;
        var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
        data[dataOff + 16] = tmp13p2 + z1p2;
        data[dataOff + 48] = tmp13p2 - z1p2;
        tmp10p2 = tmp4p2 + tmp5p2;
        tmp11p2 = tmp5p2 + tmp6p2;
        tmp12p2 = tmp6p2 + tmp7p2;
        var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
        var z2p2 = 0.5411961 * tmp10p2 + z5p2;
        var z4p2 = 1.306562965 * tmp12p2 + z5p2;
        var z3p2 = tmp11p2 * 0.707106781;
        var z11p2 = tmp7p2 + z3p2;
        var z13p2 = tmp7p2 - z3p2;
        data[dataOff + 40] = z13p2 + z2p2;
        data[dataOff + 24] = z13p2 - z2p2;
        data[dataOff + 8] = z11p2 + z4p2;
        data[dataOff + 56] = z11p2 - z4p2;
        dataOff++;
      }
      var fDCTQuant2;
      for (i = 0; i < I64; ++i) {
        fDCTQuant2 = data[i] * fdtbl[i];
        outputfDCTQuant[i] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
      }
      return outputfDCTQuant;
    }
    function writeAPP0() {
      writeWord(65504);
      writeWord(16);
      writeByte(74);
      writeByte(70);
      writeByte(73);
      writeByte(70);
      writeByte(0);
      writeByte(1);
      writeByte(1);
      writeByte(0);
      writeWord(1);
      writeWord(1);
      writeByte(0);
      writeByte(0);
    }
    function writeAPP1(exifBuffer) {
      if (!exifBuffer) return;
      writeWord(65505);
      if (exifBuffer[0] === 69 && exifBuffer[1] === 120 && exifBuffer[2] === 105 && exifBuffer[3] === 102) {
        writeWord(exifBuffer.length + 2);
      } else {
        writeWord(exifBuffer.length + 5 + 2);
        writeByte(69);
        writeByte(120);
        writeByte(105);
        writeByte(102);
        writeByte(0);
      }
      for (var i = 0; i < exifBuffer.length; i++) {
        writeByte(exifBuffer[i]);
      }
    }
    function writeSOF0(width, height) {
      writeWord(65472);
      writeWord(17);
      writeByte(8);
      writeWord(height);
      writeWord(width);
      writeByte(3);
      writeByte(1);
      writeByte(17);
      writeByte(0);
      writeByte(2);
      writeByte(17);
      writeByte(1);
      writeByte(3);
      writeByte(17);
      writeByte(1);
    }
    function writeDQT() {
      writeWord(65499);
      writeWord(132);
      writeByte(0);
      for (var i = 0; i < 64; i++) {
        writeByte(YTable[i]);
      }
      writeByte(1);
      for (var j = 0; j < 64; j++) {
        writeByte(UVTable[j]);
      }
    }
    function writeDHT() {
      writeWord(65476);
      writeWord(418);
      writeByte(0);
      for (var i = 0; i < 16; i++) {
        writeByte(std_dc_luminance_nrcodes[i + 1]);
      }
      for (var j = 0; j <= 11; j++) {
        writeByte(std_dc_luminance_values[j]);
      }
      writeByte(16);
      for (var k = 0; k < 16; k++) {
        writeByte(std_ac_luminance_nrcodes[k + 1]);
      }
      for (var l = 0; l <= 161; l++) {
        writeByte(std_ac_luminance_values[l]);
      }
      writeByte(1);
      for (var m = 0; m < 16; m++) {
        writeByte(std_dc_chrominance_nrcodes[m + 1]);
      }
      for (var n = 0; n <= 11; n++) {
        writeByte(std_dc_chrominance_values[n]);
      }
      writeByte(17);
      for (var o = 0; o < 16; o++) {
        writeByte(std_ac_chrominance_nrcodes[o + 1]);
      }
      for (var p = 0; p <= 161; p++) {
        writeByte(std_ac_chrominance_values[p]);
      }
    }
    function writeCOM(comments) {
      if (typeof comments === "undefined" || comments.constructor !== Array) return;
      comments.forEach((e) => {
        if (typeof e !== "string") return;
        writeWord(65534);
        var l = e.length;
        writeWord(l + 2);
        var i;
        for (i = 0; i < l; i++)
          writeByte(e.charCodeAt(i));
      });
    }
    function writeSOS() {
      writeWord(65498);
      writeWord(12);
      writeByte(3);
      writeByte(1);
      writeByte(0);
      writeByte(2);
      writeByte(17);
      writeByte(3);
      writeByte(17);
      writeByte(0);
      writeByte(63);
      writeByte(0);
    }
    function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
      var EOB = HTAC[0];
      var M16zeroes = HTAC[240];
      var pos;
      var I16 = 16;
      var I63 = 63;
      var I64 = 64;
      var DU_DCT = fDCTQuant(CDU, fdtbl);
      for (var j = 0; j < I64; ++j) {
        DU[ZigZag[j]] = DU_DCT[j];
      }
      var Diff = DU[0] - DC;
      DC = DU[0];
      if (Diff == 0) {
        writeBits(HTDC[0]);
      } else {
        pos = 32767 + Diff;
        writeBits(HTDC[category[pos]]);
        writeBits(bitcode[pos]);
      }
      var end0pos = 63;
      for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {
      }
      if (end0pos == 0) {
        writeBits(EOB);
        return DC;
      }
      var i = 1;
      var lng;
      while (i <= end0pos) {
        var startpos = i;
        for (; DU[i] == 0 && i <= end0pos; ++i) {
        }
        var nrzeroes = i - startpos;
        if (nrzeroes >= I16) {
          lng = nrzeroes >> 4;
          for (var nrmarker = 1; nrmarker <= lng; ++nrmarker)
            writeBits(M16zeroes);
          nrzeroes = nrzeroes & 15;
        }
        pos = 32767 + DU[i];
        writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
        writeBits(bitcode[pos]);
        i++;
      }
      if (end0pos != I63) {
        writeBits(EOB);
      }
      return DC;
    }
    function initCharLookupTable() {
      var sfcc = String.fromCharCode;
      for (var i = 0; i < 256; i++) {
        clt[i] = sfcc(i);
      }
    }
    this.encode = function(image, quality2) {
      (/* @__PURE__ */ new Date()).getTime();
      if (quality2) setQuality(quality2);
      byteout = new Array();
      bytenew = 0;
      bytepos = 7;
      writeWord(65496);
      writeAPP0();
      writeCOM(image.comments);
      writeAPP1(image.exifBuffer);
      writeDQT();
      writeSOF0(image.width, image.height);
      writeDHT();
      writeSOS();
      var DCY = 0;
      var DCU = 0;
      var DCV = 0;
      bytenew = 0;
      bytepos = 7;
      this.encode.displayName = "_encode_";
      var imageData = image.data;
      var width = image.width;
      var height = image.height;
      var quadWidth = width * 4;
      var x2, y2 = 0;
      var r, g, b;
      var start, p, col, row, pos;
      while (y2 < height) {
        x2 = 0;
        while (x2 < quadWidth) {
          start = quadWidth * y2 + x2;
          p = start;
          col = -1;
          row = 0;
          for (pos = 0; pos < 64; pos++) {
            row = pos >> 3;
            col = (pos & 7) * 4;
            p = start + row * quadWidth + col;
            if (y2 + row >= height) {
              p -= quadWidth * (y2 + 1 + row - height);
            }
            if (x2 + col >= quadWidth) {
              p -= x2 + col - quadWidth + 4;
            }
            r = imageData[p++];
            g = imageData[p++];
            b = imageData[p++];
            YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
            UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
            VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
          }
          DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
          DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
          DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
          x2 += 32;
        }
        y2 += 8;
      }
      if (bytepos >= 0) {
        var fillbits = [];
        fillbits[1] = bytepos + 1;
        fillbits[0] = (1 << bytepos + 1) - 1;
        writeBits(fillbits);
      }
      writeWord(65497);
      return Buffer.from(byteout);
    };
    function setQuality(quality2) {
      if (quality2 <= 0) {
        quality2 = 1;
      }
      if (quality2 > 100) {
        quality2 = 100;
      }
      if (currentQuality == quality2) return;
      var sf = 0;
      if (quality2 < 50) {
        sf = Math.floor(5e3 / quality2);
      } else {
        sf = Math.floor(200 - quality2 * 2);
      }
      initQuantTables(sf);
      currentQuality = quality2;
    }
    function init() {
      var time_start = (/* @__PURE__ */ new Date()).getTime();
      if (!quality) quality = 50;
      initCharLookupTable();
      initHuffmanTbl();
      initCategoryNumber();
      initRGBYUVTable();
      setQuality(quality);
      (/* @__PURE__ */ new Date()).getTime() - time_start;
    }
    init();
  }
  {
    module.exports = encode2;
  }
  function encode2(imgData, qu) {
    if (typeof qu === "undefined") qu = 50;
    var encoder2 = new JPEGEncoder(qu);
    var data = encoder2.encode(imgData, qu);
    return {
      data,
      width: imgData.width,
      height: imgData.height
    };
  }
})(encoder);
var encoderExports = encoder.exports;
var decoder = { exports: {} };
(function(module) {
  var JpegImage = function jpegImage() {
    var dctZigZag = new Int32Array([
      0,
      1,
      8,
      16,
      9,
      2,
      3,
      10,
      17,
      24,
      32,
      25,
      18,
      11,
      4,
      5,
      12,
      19,
      26,
      33,
      40,
      48,
      41,
      34,
      27,
      20,
      13,
      6,
      7,
      14,
      21,
      28,
      35,
      42,
      49,
      56,
      57,
      50,
      43,
      36,
      29,
      22,
      15,
      23,
      30,
      37,
      44,
      51,
      58,
      59,
      52,
      45,
      38,
      31,
      39,
      46,
      53,
      60,
      61,
      54,
      47,
      55,
      62,
      63
    ]);
    var dctCos1 = 4017;
    var dctSin1 = 799;
    var dctCos3 = 3406;
    var dctSin3 = 2276;
    var dctCos6 = 1567;
    var dctSin6 = 3784;
    var dctSqrt2 = 5793;
    var dctSqrt1d2 = 2896;
    function constructor() {
    }
    function buildHuffmanTable(codeLengths, values) {
      var k = 0, code = [], i, j, length = 16;
      while (length > 0 && !codeLengths[length - 1])
        length--;
      code.push({ children: [], index: 0 });
      var p = code[0], q;
      for (i = 0; i < length; i++) {
        for (j = 0; j < codeLengths[i]; j++) {
          p = code.pop();
          p.children[p.index] = values[k];
          while (p.index > 0) {
            if (code.length === 0)
              throw new Error("Could not recreate Huffman Table");
            p = code.pop();
          }
          p.index++;
          code.push(p);
          while (code.length <= i) {
            code.push(q = { children: [], index: 0 });
            p.children[p.index] = q.children;
            p = q;
          }
          k++;
        }
        if (i + 1 < length) {
          code.push(q = { children: [], index: 0 });
          p.children[p.index] = q.children;
          p = q;
        }
      }
      return code[0].children;
    }
    function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
      frame.precision;
      frame.samplesPerLine;
      frame.scanLines;
      var mcusPerLine = frame.mcusPerLine;
      var progressive = frame.progressive;
      frame.maxH;
      frame.maxV;
      var startOffset = offset, bitsData = 0, bitsCount = 0;
      function readBit() {
        if (bitsCount > 0) {
          bitsCount--;
          return bitsData >> bitsCount & 1;
        }
        bitsData = data[offset++];
        if (bitsData == 255) {
          var nextByte = data[offset++];
          if (nextByte) {
            throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
          }
        }
        bitsCount = 7;
        return bitsData >>> 7;
      }
      function decodeHuffman(tree) {
        var node = tree, bit;
        while ((bit = readBit()) !== null) {
          node = node[bit];
          if (typeof node === "number")
            return node;
          if (typeof node !== "object")
            throw new Error("invalid huffman sequence");
        }
        return null;
      }
      function receive(length) {
        var n2 = 0;
        while (length > 0) {
          var bit = readBit();
          if (bit === null) return;
          n2 = n2 << 1 | bit;
          length--;
        }
        return n2;
      }
      function receiveAndExtend(length) {
        var n2 = receive(length);
        if (n2 >= 1 << length - 1)
          return n2;
        return n2 + (-1 << length) + 1;
      }
      function decodeBaseline(component2, zz) {
        var t = decodeHuffman(component2.huffmanTableDC);
        var diff = t === 0 ? 0 : receiveAndExtend(t);
        zz[0] = component2.pred += diff;
        var k2 = 1;
        while (k2 < 64) {
          var rs = decodeHuffman(component2.huffmanTableAC);
          var s = rs & 15, r = rs >> 4;
          if (s === 0) {
            if (r < 15)
              break;
            k2 += 16;
            continue;
          }
          k2 += r;
          var z2 = dctZigZag[k2];
          zz[z2] = receiveAndExtend(s);
          k2++;
        }
      }
      function decodeDCFirst(component2, zz) {
        var t = decodeHuffman(component2.huffmanTableDC);
        var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
        zz[0] = component2.pred += diff;
      }
      function decodeDCSuccessive(component2, zz) {
        zz[0] |= readBit() << successive;
      }
      var eobrun = 0;
      function decodeACFirst(component2, zz) {
        if (eobrun > 0) {
          eobrun--;
          return;
        }
        var k2 = spectralStart, e = spectralEnd;
        while (k2 <= e) {
          var rs = decodeHuffman(component2.huffmanTableAC);
          var s = rs & 15, r = rs >> 4;
          if (s === 0) {
            if (r < 15) {
              eobrun = receive(r) + (1 << r) - 1;
              break;
            }
            k2 += 16;
            continue;
          }
          k2 += r;
          var z2 = dctZigZag[k2];
          zz[z2] = receiveAndExtend(s) * (1 << successive);
          k2++;
        }
      }
      var successiveACState = 0, successiveACNextValue;
      function decodeACSuccessive(component2, zz) {
        var k2 = spectralStart, e = spectralEnd, r = 0;
        while (k2 <= e) {
          var z2 = dctZigZag[k2];
          var direction = zz[z2] < 0 ? -1 : 1;
          switch (successiveACState) {
            case 0:
              var rs = decodeHuffman(component2.huffmanTableAC);
              var s = rs & 15, r = rs >> 4;
              if (s === 0) {
                if (r < 15) {
                  eobrun = receive(r) + (1 << r);
                  successiveACState = 4;
                } else {
                  r = 16;
                  successiveACState = 1;
                }
              } else {
                if (s !== 1)
                  throw new Error("invalid ACn encoding");
                successiveACNextValue = receiveAndExtend(s);
                successiveACState = r ? 2 : 3;
              }
              continue;
            case 1:
            case 2:
              if (zz[z2])
                zz[z2] += (readBit() << successive) * direction;
              else {
                r--;
                if (r === 0)
                  successiveACState = successiveACState == 2 ? 3 : 0;
              }
              break;
            case 3:
              if (zz[z2])
                zz[z2] += (readBit() << successive) * direction;
              else {
                zz[z2] = successiveACNextValue << successive;
                successiveACState = 0;
              }
              break;
            case 4:
              if (zz[z2])
                zz[z2] += (readBit() << successive) * direction;
              break;
          }
          k2++;
        }
        if (successiveACState === 4) {
          eobrun--;
          if (eobrun === 0)
            successiveACState = 0;
        }
      }
      function decodeMcu(component2, decode3, mcu2, row, col) {
        var mcuRow = mcu2 / mcusPerLine | 0;
        var mcuCol = mcu2 % mcusPerLine;
        var blockRow = mcuRow * component2.v + row;
        var blockCol = mcuCol * component2.h + col;
        if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
          return;
        decode3(component2, component2.blocks[blockRow][blockCol]);
      }
      function decodeBlock(component2, decode3, mcu2) {
        var blockRow = mcu2 / component2.blocksPerLine | 0;
        var blockCol = mcu2 % component2.blocksPerLine;
        if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
          return;
        decode3(component2, component2.blocks[blockRow][blockCol]);
      }
      var componentsLength = components.length;
      var component, i, j, k, n;
      var decodeFn;
      if (progressive) {
        if (spectralStart === 0)
          decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
        else
          decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
      } else {
        decodeFn = decodeBaseline;
      }
      var mcu = 0, marker;
      var mcuExpected;
      if (componentsLength == 1) {
        mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
      } else {
        mcuExpected = mcusPerLine * frame.mcusPerColumn;
      }
      if (!resetInterval) resetInterval = mcuExpected;
      var h, v;
      while (mcu < mcuExpected) {
        for (i = 0; i < componentsLength; i++)
          components[i].pred = 0;
        eobrun = 0;
        if (componentsLength == 1) {
          component = components[0];
          for (n = 0; n < resetInterval; n++) {
            decodeBlock(component, decodeFn, mcu);
            mcu++;
          }
        } else {
          for (n = 0; n < resetInterval; n++) {
            for (i = 0; i < componentsLength; i++) {
              component = components[i];
              h = component.h;
              v = component.v;
              for (j = 0; j < v; j++) {
                for (k = 0; k < h; k++) {
                  decodeMcu(component, decodeFn, mcu, j, k);
                }
              }
            }
            mcu++;
            if (mcu === mcuExpected) break;
          }
        }
        if (mcu === mcuExpected) {
          do {
            if (data[offset] === 255) {
              if (data[offset + 1] !== 0) {
                break;
              }
            }
            offset += 1;
          } while (offset < data.length - 2);
        }
        bitsCount = 0;
        marker = data[offset] << 8 | data[offset + 1];
        if (marker < 65280) {
          throw new Error("marker was not found");
        }
        if (marker >= 65488 && marker <= 65495) {
          offset += 2;
        } else
          break;
      }
      return offset - startOffset;
    }
    function buildComponentData(frame, component) {
      var lines = [];
      var blocksPerLine = component.blocksPerLine;
      var blocksPerColumn = component.blocksPerColumn;
      var samplesPerLine = blocksPerLine << 3;
      var R = new Int32Array(64), r = new Uint8Array(64);
      function quantizeAndInverse(zz, dataOut, dataIn) {
        var qt = component.quantizationTable;
        var v0, v1, v2, v3, v4, v5, v6, v7, t;
        var p = dataIn;
        var i2;
        for (i2 = 0; i2 < 64; i2++)
          p[i2] = zz[i2] * qt[i2];
        for (i2 = 0; i2 < 8; ++i2) {
          var row = 8 * i2;
          if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
            t = dctSqrt2 * p[0 + row] + 512 >> 10;
            p[0 + row] = t;
            p[1 + row] = t;
            p[2 + row] = t;
            p[3 + row] = t;
            p[4 + row] = t;
            p[5 + row] = t;
            p[6 + row] = t;
            p[7 + row] = t;
            continue;
          }
          v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
          v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
          v2 = p[2 + row];
          v3 = p[6 + row];
          v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
          v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
          v5 = p[3 + row] << 4;
          v6 = p[5 + row] << 4;
          t = v0 - v1 + 1 >> 1;
          v0 = v0 + v1 + 1 >> 1;
          v1 = t;
          t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
          v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
          v3 = t;
          t = v4 - v6 + 1 >> 1;
          v4 = v4 + v6 + 1 >> 1;
          v6 = t;
          t = v7 + v5 + 1 >> 1;
          v5 = v7 - v5 + 1 >> 1;
          v7 = t;
          t = v0 - v3 + 1 >> 1;
          v0 = v0 + v3 + 1 >> 1;
          v3 = t;
          t = v1 - v2 + 1 >> 1;
          v1 = v1 + v2 + 1 >> 1;
          v2 = t;
          t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
          v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
          v7 = t;
          t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
          v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
          v6 = t;
          p[0 + row] = v0 + v7;
          p[7 + row] = v0 - v7;
          p[1 + row] = v1 + v6;
          p[6 + row] = v1 - v6;
          p[2 + row] = v2 + v5;
          p[5 + row] = v2 - v5;
          p[3 + row] = v3 + v4;
          p[4 + row] = v3 - v4;
        }
        for (i2 = 0; i2 < 8; ++i2) {
          var col = i2;
          if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
            t = dctSqrt2 * dataIn[i2 + 0] + 8192 >> 14;
            p[0 * 8 + col] = t;
            p[1 * 8 + col] = t;
            p[2 * 8 + col] = t;
            p[3 * 8 + col] = t;
            p[4 * 8 + col] = t;
            p[5 * 8 + col] = t;
            p[6 * 8 + col] = t;
            p[7 * 8 + col] = t;
            continue;
          }
          v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
          v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
          v2 = p[2 * 8 + col];
          v3 = p[6 * 8 + col];
          v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
          v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
          v5 = p[3 * 8 + col];
          v6 = p[5 * 8 + col];
          t = v0 - v1 + 1 >> 1;
          v0 = v0 + v1 + 1 >> 1;
          v1 = t;
          t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
          v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
          v3 = t;
          t = v4 - v6 + 1 >> 1;
          v4 = v4 + v6 + 1 >> 1;
          v6 = t;
          t = v7 + v5 + 1 >> 1;
          v5 = v7 - v5 + 1 >> 1;
          v7 = t;
          t = v0 - v3 + 1 >> 1;
          v0 = v0 + v3 + 1 >> 1;
          v3 = t;
          t = v1 - v2 + 1 >> 1;
          v1 = v1 + v2 + 1 >> 1;
          v2 = t;
          t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
          v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
          v7 = t;
          t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
          v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
          v6 = t;
          p[0 * 8 + col] = v0 + v7;
          p[7 * 8 + col] = v0 - v7;
          p[1 * 8 + col] = v1 + v6;
          p[6 * 8 + col] = v1 - v6;
          p[2 * 8 + col] = v2 + v5;
          p[5 * 8 + col] = v2 - v5;
          p[3 * 8 + col] = v3 + v4;
          p[4 * 8 + col] = v3 - v4;
        }
        for (i2 = 0; i2 < 64; ++i2) {
          var sample2 = 128 + (p[i2] + 8 >> 4);
          dataOut[i2] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
        }
      }
      requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
      var i, j;
      for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
        var scanLine = blockRow << 3;
        for (i = 0; i < 8; i++)
          lines.push(new Uint8Array(samplesPerLine));
        for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
          quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
          var offset = 0, sample = blockCol << 3;
          for (j = 0; j < 8; j++) {
            var line = lines[scanLine + j];
            for (i = 0; i < 8; i++)
              line[sample + i] = r[offset++];
          }
        }
      }
      return lines;
    }
    function clampTo8bit(a) {
      return a < 0 ? 0 : a > 255 ? 255 : a;
    }
    constructor.prototype = {
      load: function load(path2) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", path2, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = (function() {
          var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
          this.parse(data);
          if (this.onload)
            this.onload();
        }).bind(this);
        xhr.send(null);
      },
      parse: function parse2(data) {
        var maxResolutionInPixels = this.opts.maxResolutionInMP * 1e3 * 1e3;
        var offset = 0;
        data.length;
        function readUint16() {
          var value = data[offset] << 8 | data[offset + 1];
          offset += 2;
          return value;
        }
        function readDataBlock() {
          var length = readUint16();
          var array2 = data.subarray(offset, offset + length - 2);
          offset += array2.length;
          return array2;
        }
        function prepareComponents(frame2) {
          var maxH = 1, maxV = 1;
          var component2, componentId2;
          for (componentId2 in frame2.components) {
            if (frame2.components.hasOwnProperty(componentId2)) {
              component2 = frame2.components[componentId2];
              if (maxH < component2.h) maxH = component2.h;
              if (maxV < component2.v) maxV = component2.v;
            }
          }
          var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH);
          var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV);
          for (componentId2 in frame2.components) {
            if (frame2.components.hasOwnProperty(componentId2)) {
              component2 = frame2.components[componentId2];
              var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH);
              var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV);
              var blocksPerLineForMcu = mcusPerLine * component2.h;
              var blocksPerColumnForMcu = mcusPerColumn * component2.v;
              var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
              var blocks = [];
              requestMemoryAllocation(blocksToAllocate * 256);
              for (var i2 = 0; i2 < blocksPerColumnForMcu; i2++) {
                var row = [];
                for (var j2 = 0; j2 < blocksPerLineForMcu; j2++)
                  row.push(new Int32Array(64));
                blocks.push(row);
              }
              component2.blocksPerLine = blocksPerLine;
              component2.blocksPerColumn = blocksPerColumn;
              component2.blocks = blocks;
            }
          }
          frame2.maxH = maxH;
          frame2.maxV = maxV;
          frame2.mcusPerLine = mcusPerLine;
          frame2.mcusPerColumn = mcusPerColumn;
        }
        var jfif = null;
        var adobe = null;
        var frame, resetInterval;
        var quantizationTables = [], frames = [];
        var huffmanTablesAC = [], huffmanTablesDC = [];
        var fileMarker = readUint16();
        var malformedDataOffset = -1;
        this.comments = [];
        if (fileMarker != 65496) {
          throw new Error("SOI not found");
        }
        fileMarker = readUint16();
        while (fileMarker != 65497) {
          var i, j;
          switch (fileMarker) {
            case 65280:
              break;
            case 65504:
            case 65505:
            case 65506:
            case 65507:
            case 65508:
            case 65509:
            case 65510:
            case 65511:
            case 65512:
            case 65513:
            case 65514:
            case 65515:
            case 65516:
            case 65517:
            case 65518:
            case 65519:
            case 65534:
              var appData = readDataBlock();
              if (fileMarker === 65534) {
                var comment = String.fromCharCode.apply(null, appData);
                this.comments.push(comment);
              }
              if (fileMarker === 65504) {
                if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                  jfif = {
                    version: { major: appData[5], minor: appData[6] },
                    densityUnits: appData[7],
                    xDensity: appData[8] << 8 | appData[9],
                    yDensity: appData[10] << 8 | appData[11],
                    thumbWidth: appData[12],
                    thumbHeight: appData[13],
                    thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                  };
                }
              }
              if (fileMarker === 65505) {
                if (appData[0] === 69 && appData[1] === 120 && appData[2] === 105 && appData[3] === 102 && appData[4] === 0) {
                  this.exifBuffer = appData.subarray(5, appData.length);
                }
              }
              if (fileMarker === 65518) {
                if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                  adobe = {
                    version: appData[6],
                    flags0: appData[7] << 8 | appData[8],
                    flags1: appData[9] << 8 | appData[10],
                    transformCode: appData[11]
                  };
                }
              }
              break;
            case 65499:
              var quantizationTablesLength = readUint16();
              var quantizationTablesEnd = quantizationTablesLength + offset - 2;
              while (offset < quantizationTablesEnd) {
                var quantizationTableSpec = data[offset++];
                requestMemoryAllocation(64 * 4);
                var tableData = new Int32Array(64);
                if (quantizationTableSpec >> 4 === 0) {
                  for (j = 0; j < 64; j++) {
                    var z2 = dctZigZag[j];
                    tableData[z2] = data[offset++];
                  }
                } else if (quantizationTableSpec >> 4 === 1) {
                  for (j = 0; j < 64; j++) {
                    var z2 = dctZigZag[j];
                    tableData[z2] = readUint16();
                  }
                } else
                  throw new Error("DQT: invalid table spec");
                quantizationTables[quantizationTableSpec & 15] = tableData;
              }
              break;
            case 65472:
            case 65473:
            case 65474:
              readUint16();
              frame = {};
              frame.extended = fileMarker === 65473;
              frame.progressive = fileMarker === 65474;
              frame.precision = data[offset++];
              frame.scanLines = readUint16();
              frame.samplesPerLine = readUint16();
              frame.components = {};
              frame.componentsOrder = [];
              var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
              if (pixelsInFrame > maxResolutionInPixels) {
                var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
              }
              var componentsCount = data[offset++], componentId;
              for (i = 0; i < componentsCount; i++) {
                componentId = data[offset];
                var h = data[offset + 1] >> 4;
                var v = data[offset + 1] & 15;
                var qId = data[offset + 2];
                if (h <= 0 || v <= 0) {
                  throw new Error("Invalid sampling factor, expected values above 0");
                }
                frame.componentsOrder.push(componentId);
                frame.components[componentId] = {
                  h,
                  v,
                  quantizationIdx: qId
                };
                offset += 3;
              }
              prepareComponents(frame);
              frames.push(frame);
              break;
            case 65476:
              var huffmanLength = readUint16();
              for (i = 2; i < huffmanLength; ) {
                var huffmanTableSpec = data[offset++];
                var codeLengths = new Uint8Array(16);
                var codeLengthSum = 0;
                for (j = 0; j < 16; j++, offset++) {
                  codeLengthSum += codeLengths[j] = data[offset];
                }
                requestMemoryAllocation(16 + codeLengthSum);
                var huffmanValues = new Uint8Array(codeLengthSum);
                for (j = 0; j < codeLengthSum; j++, offset++)
                  huffmanValues[j] = data[offset];
                i += 17 + codeLengthSum;
                (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
              }
              break;
            case 65501:
              readUint16();
              resetInterval = readUint16();
              break;
            case 65500:
              readUint16();
              readUint16();
              break;
            case 65498:
              readUint16();
              var selectorsCount = data[offset++];
              var components = [], component;
              for (i = 0; i < selectorsCount; i++) {
                component = frame.components[data[offset++]];
                var tableSpec = data[offset++];
                component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                components.push(component);
              }
              var spectralStart = data[offset++];
              var spectralEnd = data[offset++];
              var successiveApproximation = data[offset++];
              var processed = decodeScan(
                data,
                offset,
                frame,
                components,
                resetInterval,
                spectralStart,
                spectralEnd,
                successiveApproximation >> 4,
                successiveApproximation & 15,
                this.opts
              );
              offset += processed;
              break;
            case 65535:
              if (data[offset] !== 255) {
                offset--;
              }
              break;
            default:
              if (data[offset - 3] == 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                offset -= 3;
                break;
              } else if (fileMarker === 224 || fileMarker == 225) {
                if (malformedDataOffset !== -1) {
                  throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);
                }
                malformedDataOffset = offset - 1;
                const nextOffset = readUint16();
                if (data[offset + nextOffset - 2] === 255) {
                  offset += nextOffset - 2;
                  break;
                }
              }
              throw new Error("unknown JPEG marker " + fileMarker.toString(16));
          }
          fileMarker = readUint16();
        }
        if (frames.length != 1)
          throw new Error("only single frame JPEGs supported");
        for (var i = 0; i < frames.length; i++) {
          var cp = frames[i].components;
          for (var j in cp) {
            cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
            delete cp[j].quantizationIdx;
          }
        }
        this.width = frame.samplesPerLine;
        this.height = frame.scanLines;
        this.jfif = jfif;
        this.adobe = adobe;
        this.components = [];
        for (var i = 0; i < frame.componentsOrder.length; i++) {
          var component = frame.components[frame.componentsOrder[i]];
          this.components.push({
            lines: buildComponentData(frame, component),
            scaleX: component.h / frame.maxH,
            scaleY: component.v / frame.maxV
          });
        }
      },
      getData: function getData(width, height) {
        var scaleX = this.width / width, scaleY = this.height / height;
        var component1, component2, component3, component4;
        var component1Line, component2Line, component3Line, component4Line;
        var x2, y2;
        var offset = 0;
        var Y2, Cb, Cr, K, C, M, Ye, R, G, B;
        var colorTransform;
        var dataLength = width * height * this.components.length;
        requestMemoryAllocation(dataLength);
        var data = new Uint8Array(dataLength);
        switch (this.components.length) {
          case 1:
            component1 = this.components[0];
            for (y2 = 0; y2 < height; y2++) {
              component1Line = component1.lines[0 | y2 * component1.scaleY * scaleY];
              for (x2 = 0; x2 < width; x2++) {
                Y2 = component1Line[0 | x2 * component1.scaleX * scaleX];
                data[offset++] = Y2;
              }
            }
            break;
          case 2:
            component1 = this.components[0];
            component2 = this.components[1];
            for (y2 = 0; y2 < height; y2++) {
              component1Line = component1.lines[0 | y2 * component1.scaleY * scaleY];
              component2Line = component2.lines[0 | y2 * component2.scaleY * scaleY];
              for (x2 = 0; x2 < width; x2++) {
                Y2 = component1Line[0 | x2 * component1.scaleX * scaleX];
                data[offset++] = Y2;
                Y2 = component2Line[0 | x2 * component2.scaleX * scaleX];
                data[offset++] = Y2;
              }
            }
            break;
          case 3:
            colorTransform = true;
            if (this.adobe && this.adobe.transformCode)
              colorTransform = true;
            else if (typeof this.opts.colorTransform !== "undefined")
              colorTransform = !!this.opts.colorTransform;
            component1 = this.components[0];
            component2 = this.components[1];
            component3 = this.components[2];
            for (y2 = 0; y2 < height; y2++) {
              component1Line = component1.lines[0 | y2 * component1.scaleY * scaleY];
              component2Line = component2.lines[0 | y2 * component2.scaleY * scaleY];
              component3Line = component3.lines[0 | y2 * component3.scaleY * scaleY];
              for (x2 = 0; x2 < width; x2++) {
                if (!colorTransform) {
                  R = component1Line[0 | x2 * component1.scaleX * scaleX];
                  G = component2Line[0 | x2 * component2.scaleX * scaleX];
                  B = component3Line[0 | x2 * component3.scaleX * scaleX];
                } else {
                  Y2 = component1Line[0 | x2 * component1.scaleX * scaleX];
                  Cb = component2Line[0 | x2 * component2.scaleX * scaleX];
                  Cr = component3Line[0 | x2 * component3.scaleX * scaleX];
                  R = clampTo8bit(Y2 + 1.402 * (Cr - 128));
                  G = clampTo8bit(Y2 - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                  B = clampTo8bit(Y2 + 1.772 * (Cb - 128));
                }
                data[offset++] = R;
                data[offset++] = G;
                data[offset++] = B;
              }
            }
            break;
          case 4:
            if (!this.adobe)
              throw new Error("Unsupported color mode (4 components)");
            colorTransform = false;
            if (this.adobe && this.adobe.transformCode)
              colorTransform = true;
            else if (typeof this.opts.colorTransform !== "undefined")
              colorTransform = !!this.opts.colorTransform;
            component1 = this.components[0];
            component2 = this.components[1];
            component3 = this.components[2];
            component4 = this.components[3];
            for (y2 = 0; y2 < height; y2++) {
              component1Line = component1.lines[0 | y2 * component1.scaleY * scaleY];
              component2Line = component2.lines[0 | y2 * component2.scaleY * scaleY];
              component3Line = component3.lines[0 | y2 * component3.scaleY * scaleY];
              component4Line = component4.lines[0 | y2 * component4.scaleY * scaleY];
              for (x2 = 0; x2 < width; x2++) {
                if (!colorTransform) {
                  C = component1Line[0 | x2 * component1.scaleX * scaleX];
                  M = component2Line[0 | x2 * component2.scaleX * scaleX];
                  Ye = component3Line[0 | x2 * component3.scaleX * scaleX];
                  K = component4Line[0 | x2 * component4.scaleX * scaleX];
                } else {
                  Y2 = component1Line[0 | x2 * component1.scaleX * scaleX];
                  Cb = component2Line[0 | x2 * component2.scaleX * scaleX];
                  Cr = component3Line[0 | x2 * component3.scaleX * scaleX];
                  K = component4Line[0 | x2 * component4.scaleX * scaleX];
                  C = 255 - clampTo8bit(Y2 + 1.402 * (Cr - 128));
                  M = 255 - clampTo8bit(Y2 - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                  Ye = 255 - clampTo8bit(Y2 + 1.772 * (Cb - 128));
                }
                data[offset++] = 255 - C;
                data[offset++] = 255 - M;
                data[offset++] = 255 - Ye;
                data[offset++] = 255 - K;
              }
            }
            break;
          default:
            throw new Error("Unsupported color mode");
        }
        return data;
      },
      copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
        var width = imageData.width, height = imageData.height;
        var imageDataArray = imageData.data;
        var data = this.getData(width, height);
        var i = 0, j = 0, x2, y2;
        var Y2, K, C, M, R, G, B;
        switch (this.components.length) {
          case 1:
            for (y2 = 0; y2 < height; y2++) {
              for (x2 = 0; x2 < width; x2++) {
                Y2 = data[i++];
                imageDataArray[j++] = Y2;
                imageDataArray[j++] = Y2;
                imageDataArray[j++] = Y2;
                if (formatAsRGBA) {
                  imageDataArray[j++] = 255;
                }
              }
            }
            break;
          case 3:
            for (y2 = 0; y2 < height; y2++) {
              for (x2 = 0; x2 < width; x2++) {
                R = data[i++];
                G = data[i++];
                B = data[i++];
                imageDataArray[j++] = R;
                imageDataArray[j++] = G;
                imageDataArray[j++] = B;
                if (formatAsRGBA) {
                  imageDataArray[j++] = 255;
                }
              }
            }
            break;
          case 4:
            for (y2 = 0; y2 < height; y2++) {
              for (x2 = 0; x2 < width; x2++) {
                C = data[i++];
                M = data[i++];
                Y2 = data[i++];
                K = data[i++];
                R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                B = 255 - clampTo8bit(Y2 * (1 - K / 255) + K);
                imageDataArray[j++] = R;
                imageDataArray[j++] = G;
                imageDataArray[j++] = B;
                if (formatAsRGBA) {
                  imageDataArray[j++] = 255;
                }
              }
            }
            break;
          default:
            throw new Error("Unsupported color mode");
        }
      }
    };
    var totalBytesAllocated = 0;
    var maxMemoryUsageBytes = 0;
    function requestMemoryAllocation(increaseAmount = 0) {
      var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
      if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
        var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
        throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
      }
      totalBytesAllocated = totalMemoryImpactBytes;
    }
    constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
      totalBytesAllocated = 0;
      maxMemoryUsageBytes = maxMemoryUsageBytes_;
    };
    constructor.getBytesAllocated = function() {
      return totalBytesAllocated;
    };
    constructor.requestMemoryAllocation = requestMemoryAllocation;
    return constructor;
  }();
  {
    module.exports = decode2;
  }
  function decode2(jpegData, userOpts = {}) {
    var defaultOpts = {
      // "undefined" means "Choose whether to transform colors based on the images color model."
      colorTransform: void 0,
      useTArray: false,
      formatAsRGBA: true,
      tolerantDecoding: true,
      maxResolutionInMP: 100,
      // Don't decode more than 100 megapixels
      maxMemoryUsageInMB: 512
      // Don't decode if memory footprint is more than 512MB
    };
    var opts = { ...defaultOpts, ...userOpts };
    var arr = new Uint8Array(jpegData);
    var decoder2 = new JpegImage();
    decoder2.opts = opts;
    JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
    decoder2.parse(arr);
    var channels = opts.formatAsRGBA ? 4 : 3;
    var bytesNeeded = decoder2.width * decoder2.height * channels;
    try {
      JpegImage.requestMemoryAllocation(bytesNeeded);
      var image = {
        width: decoder2.width,
        height: decoder2.height,
        exifBuffer: decoder2.exifBuffer,
        data: opts.useTArray ? new Uint8Array(bytesNeeded) : Buffer.alloc(bytesNeeded)
      };
      if (decoder2.comments.length > 0) {
        image["comments"] = decoder2.comments;
      }
    } catch (err) {
      if (err instanceof RangeError) {
        throw new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded);
      }
      if (err instanceof ReferenceError) {
        if (err.message === "Buffer is not defined") {
          throw new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true");
        }
      }
      throw err;
    }
    decoder2.copyToImageData(image, opts.formatAsRGBA);
    return image;
  }
})(decoder);
var decoderExports = decoder.exports;
var encode = encoderExports, decode = decoderExports;
var jpegJs = {
  encode,
  decode
};
const JPEG = /* @__PURE__ */ getDefaultExportFromCjs(jpegJs);
function jpeg$2() {
  return {
    mime: "image/jpeg",
    encode: (bitmap, { quality = 100 } = {}) => JPEG.encode(bitmap, quality).data,
    decode: (data, options) => JPEG.decode(data, options)
  };
}
var parserAsync = { exports: {} };
var chunkstream = { exports: {} };
let util$l = require$$0;
let Stream$2 = require$$1$1;
let ChunkStream$2 = chunkstream.exports = function() {
  Stream$2.call(this);
  this._buffers = [];
  this._buffered = 0;
  this._reads = [];
  this._paused = false;
  this._encoding = "utf8";
  this.writable = true;
};
util$l.inherits(ChunkStream$2, Stream$2);
ChunkStream$2.prototype.read = function(length, callback) {
  this._reads.push({
    length: Math.abs(length),
    // if length < 0 then at most this length
    allowLess: length < 0,
    func: callback
  });
  process.nextTick(
    (function() {
      this._process();
      if (this._paused && this._reads && this._reads.length > 0) {
        this._paused = false;
        this.emit("drain");
      }
    }).bind(this)
  );
};
ChunkStream$2.prototype.write = function(data, encoding) {
  if (!this.writable) {
    this.emit("error", new Error("Stream not writable"));
    return false;
  }
  let dataBuffer;
  if (Buffer.isBuffer(data)) {
    dataBuffer = data;
  } else {
    dataBuffer = Buffer.from(data, encoding || this._encoding);
  }
  this._buffers.push(dataBuffer);
  this._buffered += dataBuffer.length;
  this._process();
  if (this._reads && this._reads.length === 0) {
    this._paused = true;
  }
  return this.writable && !this._paused;
};
ChunkStream$2.prototype.end = function(data, encoding) {
  if (data) {
    this.write(data, encoding);
  }
  this.writable = false;
  if (!this._buffers) {
    return;
  }
  if (this._buffers.length === 0) {
    this._end();
  } else {
    this._buffers.push(null);
    this._process();
  }
};
ChunkStream$2.prototype.destroySoon = ChunkStream$2.prototype.end;
ChunkStream$2.prototype._end = function() {
  if (this._reads.length > 0) {
    this.emit("error", new Error("Unexpected end of input"));
  }
  this.destroy();
};
ChunkStream$2.prototype.destroy = function() {
  if (!this._buffers) {
    return;
  }
  this.writable = false;
  this._reads = null;
  this._buffers = null;
  this.emit("close");
};
ChunkStream$2.prototype._processReadAllowingLess = function(read) {
  this._reads.shift();
  let smallerBuf = this._buffers[0];
  if (smallerBuf.length > read.length) {
    this._buffered -= read.length;
    this._buffers[0] = smallerBuf.slice(read.length);
    read.func.call(this, smallerBuf.slice(0, read.length));
  } else {
    this._buffered -= smallerBuf.length;
    this._buffers.shift();
    read.func.call(this, smallerBuf);
  }
};
ChunkStream$2.prototype._processRead = function(read) {
  this._reads.shift();
  let pos = 0;
  let count = 0;
  let data = Buffer.alloc(read.length);
  while (pos < read.length) {
    let buf = this._buffers[count++];
    let len = Math.min(buf.length, read.length - pos);
    buf.copy(data, pos, 0, len);
    pos += len;
    if (len !== buf.length) {
      this._buffers[--count] = buf.slice(len);
    }
  }
  if (count > 0) {
    this._buffers.splice(0, count);
  }
  this._buffered -= read.length;
  read.func.call(this, data);
};
ChunkStream$2.prototype._process = function() {
  try {
    while (this._buffered > 0 && this._reads && this._reads.length > 0) {
      let read = this._reads[0];
      if (read.allowLess) {
        this._processReadAllowingLess(read);
      } else if (this._buffered >= read.length) {
        this._processRead(read);
      } else {
        break;
      }
    }
    if (this._buffers && !this.writable) {
      this._end();
    }
  } catch (ex) {
    this.emit("error", ex);
  }
};
var chunkstreamExports = chunkstream.exports;
var filterParseAsync = { exports: {} };
var filterParse = { exports: {} };
var interlace = {};
let imagePasses = [
  {
    // pass 1 - 1px
    x: [0],
    y: [0]
  },
  {
    // pass 2 - 1px
    x: [4],
    y: [0]
  },
  {
    // pass 3 - 2px
    x: [0, 4],
    y: [4]
  },
  {
    // pass 4 - 4px
    x: [2, 6],
    y: [0, 4]
  },
  {
    // pass 5 - 8px
    x: [0, 2, 4, 6],
    y: [2, 6]
  },
  {
    // pass 6 - 16px
    x: [1, 3, 5, 7],
    y: [0, 2, 4, 6]
  },
  {
    // pass 7 - 32px
    x: [0, 1, 2, 3, 4, 5, 6, 7],
    y: [1, 3, 5, 7]
  }
];
interlace.getImagePasses = function(width, height) {
  let images = [];
  let xLeftOver = width % 8;
  let yLeftOver = height % 8;
  let xRepeats = (width - xLeftOver) / 8;
  let yRepeats = (height - yLeftOver) / 8;
  for (let i = 0; i < imagePasses.length; i++) {
    let pass = imagePasses[i];
    let passWidth = xRepeats * pass.x.length;
    let passHeight = yRepeats * pass.y.length;
    for (let j = 0; j < pass.x.length; j++) {
      if (pass.x[j] < xLeftOver) {
        passWidth++;
      } else {
        break;
      }
    }
    for (let j = 0; j < pass.y.length; j++) {
      if (pass.y[j] < yLeftOver) {
        passHeight++;
      } else {
        break;
      }
    }
    if (passWidth > 0 && passHeight > 0) {
      images.push({ width: passWidth, height: passHeight, index: i });
    }
  }
  return images;
};
interlace.getInterlaceIterator = function(width) {
  return function(x2, y2, pass) {
    let outerXLeftOver = x2 % imagePasses[pass].x.length;
    let outerX = (x2 - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
    let outerYLeftOver = y2 % imagePasses[pass].y.length;
    let outerY = (y2 - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
    return outerX * 4 + outerY * width * 4;
  };
};
var paethPredictor$2 = function paethPredictor2(left, above, upLeft) {
  let paeth = left + above - upLeft;
  let pLeft = Math.abs(paeth - left);
  let pAbove = Math.abs(paeth - above);
  let pUpLeft = Math.abs(paeth - upLeft);
  if (pLeft <= pAbove && pLeft <= pUpLeft) {
    return left;
  }
  if (pAbove <= pUpLeft) {
    return above;
  }
  return upLeft;
};
let interlaceUtils$1 = interlace;
let paethPredictor$1 = paethPredictor$2;
function getByteWidth(width, bpp, depth) {
  let byteWidth = width * bpp;
  if (depth !== 8) {
    byteWidth = Math.ceil(byteWidth / (8 / depth));
  }
  return byteWidth;
}
let Filter$2 = filterParse.exports = function(bitmapInfo, dependencies) {
  let width = bitmapInfo.width;
  let height = bitmapInfo.height;
  let interlace2 = bitmapInfo.interlace;
  let bpp = bitmapInfo.bpp;
  let depth = bitmapInfo.depth;
  this.read = dependencies.read;
  this.write = dependencies.write;
  this.complete = dependencies.complete;
  this._imageIndex = 0;
  this._images = [];
  if (interlace2) {
    let passes = interlaceUtils$1.getImagePasses(width, height);
    for (let i = 0; i < passes.length; i++) {
      this._images.push({
        byteWidth: getByteWidth(passes[i].width, bpp, depth),
        height: passes[i].height,
        lineIndex: 0
      });
    }
  } else {
    this._images.push({
      byteWidth: getByteWidth(width, bpp, depth),
      height,
      lineIndex: 0
    });
  }
  if (depth === 8) {
    this._xComparison = bpp;
  } else if (depth === 16) {
    this._xComparison = bpp * 2;
  } else {
    this._xComparison = 1;
  }
};
Filter$2.prototype.start = function() {
  this.read(
    this._images[this._imageIndex].byteWidth + 1,
    this._reverseFilterLine.bind(this)
  );
};
Filter$2.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
  let xComparison = this._xComparison;
  let xBiggerThan = xComparison - 1;
  for (let x2 = 0; x2 < byteWidth; x2++) {
    let rawByte = rawData[1 + x2];
    let f1Left = x2 > xBiggerThan ? unfilteredLine[x2 - xComparison] : 0;
    unfilteredLine[x2] = rawByte + f1Left;
  }
};
Filter$2.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
  let lastLine = this._lastLine;
  for (let x2 = 0; x2 < byteWidth; x2++) {
    let rawByte = rawData[1 + x2];
    let f2Up = lastLine ? lastLine[x2] : 0;
    unfilteredLine[x2] = rawByte + f2Up;
  }
};
Filter$2.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
  let xComparison = this._xComparison;
  let xBiggerThan = xComparison - 1;
  let lastLine = this._lastLine;
  for (let x2 = 0; x2 < byteWidth; x2++) {
    let rawByte = rawData[1 + x2];
    let f3Up = lastLine ? lastLine[x2] : 0;
    let f3Left = x2 > xBiggerThan ? unfilteredLine[x2 - xComparison] : 0;
    let f3Add = Math.floor((f3Left + f3Up) / 2);
    unfilteredLine[x2] = rawByte + f3Add;
  }
};
Filter$2.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
  let xComparison = this._xComparison;
  let xBiggerThan = xComparison - 1;
  let lastLine = this._lastLine;
  for (let x2 = 0; x2 < byteWidth; x2++) {
    let rawByte = rawData[1 + x2];
    let f4Up = lastLine ? lastLine[x2] : 0;
    let f4Left = x2 > xBiggerThan ? unfilteredLine[x2 - xComparison] : 0;
    let f4UpLeft = x2 > xBiggerThan && lastLine ? lastLine[x2 - xComparison] : 0;
    let f4Add = paethPredictor$1(f4Left, f4Up, f4UpLeft);
    unfilteredLine[x2] = rawByte + f4Add;
  }
};
Filter$2.prototype._reverseFilterLine = function(rawData) {
  let filter2 = rawData[0];
  let unfilteredLine;
  let currentImage = this._images[this._imageIndex];
  let byteWidth = currentImage.byteWidth;
  if (filter2 === 0) {
    unfilteredLine = rawData.slice(1, byteWidth + 1);
  } else {
    unfilteredLine = Buffer.alloc(byteWidth);
    switch (filter2) {
      case 1:
        this._unFilterType1(rawData, unfilteredLine, byteWidth);
        break;
      case 2:
        this._unFilterType2(rawData, unfilteredLine, byteWidth);
        break;
      case 3:
        this._unFilterType3(rawData, unfilteredLine, byteWidth);
        break;
      case 4:
        this._unFilterType4(rawData, unfilteredLine, byteWidth);
        break;
      default:
        throw new Error("Unrecognised filter type - " + filter2);
    }
  }
  this.write(unfilteredLine);
  currentImage.lineIndex++;
  if (currentImage.lineIndex >= currentImage.height) {
    this._lastLine = null;
    this._imageIndex++;
    currentImage = this._images[this._imageIndex];
  } else {
    this._lastLine = unfilteredLine;
  }
  if (currentImage) {
    this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
  } else {
    this._lastLine = null;
    this.complete();
  }
};
var filterParseExports = filterParse.exports;
let util$k = require$$0;
let ChunkStream$1 = chunkstreamExports;
let Filter$1 = filterParseExports;
let FilterAsync$1 = filterParseAsync.exports = function(bitmapInfo) {
  ChunkStream$1.call(this);
  let buffers = [];
  let that = this;
  this._filter = new Filter$1(bitmapInfo, {
    read: this.read.bind(this),
    write: function(buffer) {
      buffers.push(buffer);
    },
    complete: function() {
      that.emit("complete", Buffer.concat(buffers));
    }
  });
  this._filter.start();
};
util$k.inherits(FilterAsync$1, ChunkStream$1);
var filterParseAsyncExports = filterParseAsync.exports;
var parser$1 = { exports: {} };
var constants$6 = {
  PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
  TYPE_IHDR: 1229472850,
  TYPE_IEND: 1229278788,
  TYPE_IDAT: 1229209940,
  TYPE_PLTE: 1347179589,
  TYPE_tRNS: 1951551059,
  // eslint-disable-line camelcase
  TYPE_gAMA: 1732332865,
  // eslint-disable-line camelcase
  // color-type bits
  COLORTYPE_GRAYSCALE: 0,
  COLORTYPE_PALETTE: 1,
  COLORTYPE_COLOR: 2,
  COLORTYPE_ALPHA: 4,
  // e.g. grayscale and alpha
  // color-type combinations
  COLORTYPE_PALETTE_COLOR: 3,
  COLORTYPE_COLOR_ALPHA: 6,
  COLORTYPE_TO_BPP_MAP: {
    0: 1,
    2: 3,
    3: 1,
    4: 2,
    6: 4
  },
  GAMMA_DIVISION: 1e5
};
var crc = { exports: {} };
let crcTable = [];
(function() {
  for (let i = 0; i < 256; i++) {
    let currentCrc = i;
    for (let j = 0; j < 8; j++) {
      if (currentCrc & 1) {
        currentCrc = 3988292384 ^ currentCrc >>> 1;
      } else {
        currentCrc = currentCrc >>> 1;
      }
    }
    crcTable[i] = currentCrc;
  }
})();
let CrcCalculator$1 = crc.exports = function() {
  this._crc = -1;
};
CrcCalculator$1.prototype.write = function(data) {
  for (let i = 0; i < data.length; i++) {
    this._crc = crcTable[(this._crc ^ data[i]) & 255] ^ this._crc >>> 8;
  }
  return true;
};
CrcCalculator$1.prototype.crc32 = function() {
  return this._crc ^ -1;
};
CrcCalculator$1.crc32 = function(buf) {
  let crc2 = -1;
  for (let i = 0; i < buf.length; i++) {
    crc2 = crcTable[(crc2 ^ buf[i]) & 255] ^ crc2 >>> 8;
  }
  return crc2 ^ -1;
};
var crcExports = crc.exports;
let constants$5 = constants$6;
let CrcCalculator = crcExports;
let Parser$5 = parser$1.exports = function(options, dependencies) {
  this._options = options;
  options.checkCRC = options.checkCRC !== false;
  this._hasIHDR = false;
  this._hasIEND = false;
  this._emittedHeadersFinished = false;
  this._palette = [];
  this._colorType = 0;
  this._chunks = {};
  this._chunks[constants$5.TYPE_IHDR] = this._handleIHDR.bind(this);
  this._chunks[constants$5.TYPE_IEND] = this._handleIEND.bind(this);
  this._chunks[constants$5.TYPE_IDAT] = this._handleIDAT.bind(this);
  this._chunks[constants$5.TYPE_PLTE] = this._handlePLTE.bind(this);
  this._chunks[constants$5.TYPE_tRNS] = this._handleTRNS.bind(this);
  this._chunks[constants$5.TYPE_gAMA] = this._handleGAMA.bind(this);
  this.read = dependencies.read;
  this.error = dependencies.error;
  this.metadata = dependencies.metadata;
  this.gamma = dependencies.gamma;
  this.transColor = dependencies.transColor;
  this.palette = dependencies.palette;
  this.parsed = dependencies.parsed;
  this.inflateData = dependencies.inflateData;
  this.finished = dependencies.finished;
  this.simpleTransparency = dependencies.simpleTransparency;
  this.headersFinished = dependencies.headersFinished || function() {
  };
};
Parser$5.prototype.start = function() {
  this.read(constants$5.PNG_SIGNATURE.length, this._parseSignature.bind(this));
};
Parser$5.prototype._parseSignature = function(data) {
  let signature = constants$5.PNG_SIGNATURE;
  for (let i = 0; i < signature.length; i++) {
    if (data[i] !== signature[i]) {
      this.error(new Error("Invalid file signature"));
      return;
    }
  }
  this.read(8, this._parseChunkBegin.bind(this));
};
Parser$5.prototype._parseChunkBegin = function(data) {
  let length = data.readUInt32BE(0);
  let type = data.readUInt32BE(4);
  let name = "";
  for (let i = 4; i < 8; i++) {
    name += String.fromCharCode(data[i]);
  }
  let ancillary = Boolean(data[4] & 32);
  if (!this._hasIHDR && type !== constants$5.TYPE_IHDR) {
    this.error(new Error("Expected IHDR on beggining"));
    return;
  }
  this._crc = new CrcCalculator();
  this._crc.write(Buffer.from(name));
  if (this._chunks[type]) {
    return this._chunks[type](length);
  }
  if (!ancillary) {
    this.error(new Error("Unsupported critical chunk type " + name));
    return;
  }
  this.read(length + 4, this._skipChunk.bind(this));
};
Parser$5.prototype._skipChunk = function() {
  this.read(8, this._parseChunkBegin.bind(this));
};
Parser$5.prototype._handleChunkEnd = function() {
  this.read(4, this._parseChunkEnd.bind(this));
};
Parser$5.prototype._parseChunkEnd = function(data) {
  let fileCrc = data.readInt32BE(0);
  let calcCrc = this._crc.crc32();
  if (this._options.checkCRC && calcCrc !== fileCrc) {
    this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
    return;
  }
  if (!this._hasIEND) {
    this.read(8, this._parseChunkBegin.bind(this));
  }
};
Parser$5.prototype._handleIHDR = function(length) {
  this.read(length, this._parseIHDR.bind(this));
};
Parser$5.prototype._parseIHDR = function(data) {
  this._crc.write(data);
  let width = data.readUInt32BE(0);
  let height = data.readUInt32BE(4);
  let depth = data[8];
  let colorType = data[9];
  let compr = data[10];
  let filter2 = data[11];
  let interlace2 = data[12];
  if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
    this.error(new Error("Unsupported bit depth " + depth));
    return;
  }
  if (!(colorType in constants$5.COLORTYPE_TO_BPP_MAP)) {
    this.error(new Error("Unsupported color type"));
    return;
  }
  if (compr !== 0) {
    this.error(new Error("Unsupported compression method"));
    return;
  }
  if (filter2 !== 0) {
    this.error(new Error("Unsupported filter method"));
    return;
  }
  if (interlace2 !== 0 && interlace2 !== 1) {
    this.error(new Error("Unsupported interlace method"));
    return;
  }
  this._colorType = colorType;
  let bpp = constants$5.COLORTYPE_TO_BPP_MAP[this._colorType];
  this._hasIHDR = true;
  this.metadata({
    width,
    height,
    depth,
    interlace: Boolean(interlace2),
    palette: Boolean(colorType & constants$5.COLORTYPE_PALETTE),
    color: Boolean(colorType & constants$5.COLORTYPE_COLOR),
    alpha: Boolean(colorType & constants$5.COLORTYPE_ALPHA),
    bpp,
    colorType
  });
  this._handleChunkEnd();
};
Parser$5.prototype._handlePLTE = function(length) {
  this.read(length, this._parsePLTE.bind(this));
};
Parser$5.prototype._parsePLTE = function(data) {
  this._crc.write(data);
  let entries = Math.floor(data.length / 3);
  for (let i = 0; i < entries; i++) {
    this._palette.push([data[i * 3], data[i * 3 + 1], data[i * 3 + 2], 255]);
  }
  this.palette(this._palette);
  this._handleChunkEnd();
};
Parser$5.prototype._handleTRNS = function(length) {
  this.simpleTransparency();
  this.read(length, this._parseTRNS.bind(this));
};
Parser$5.prototype._parseTRNS = function(data) {
  this._crc.write(data);
  if (this._colorType === constants$5.COLORTYPE_PALETTE_COLOR) {
    if (this._palette.length === 0) {
      this.error(new Error("Transparency chunk must be after palette"));
      return;
    }
    if (data.length > this._palette.length) {
      this.error(new Error("More transparent colors than palette size"));
      return;
    }
    for (let i = 0; i < data.length; i++) {
      this._palette[i][3] = data[i];
    }
    this.palette(this._palette);
  }
  if (this._colorType === constants$5.COLORTYPE_GRAYSCALE) {
    this.transColor([data.readUInt16BE(0)]);
  }
  if (this._colorType === constants$5.COLORTYPE_COLOR) {
    this.transColor([
      data.readUInt16BE(0),
      data.readUInt16BE(2),
      data.readUInt16BE(4)
    ]);
  }
  this._handleChunkEnd();
};
Parser$5.prototype._handleGAMA = function(length) {
  this.read(length, this._parseGAMA.bind(this));
};
Parser$5.prototype._parseGAMA = function(data) {
  this._crc.write(data);
  this.gamma(data.readUInt32BE(0) / constants$5.GAMMA_DIVISION);
  this._handleChunkEnd();
};
Parser$5.prototype._handleIDAT = function(length) {
  if (!this._emittedHeadersFinished) {
    this._emittedHeadersFinished = true;
    this.headersFinished();
  }
  this.read(-length, this._parseIDAT.bind(this, length));
};
Parser$5.prototype._parseIDAT = function(length, data) {
  this._crc.write(data);
  if (this._colorType === constants$5.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
    throw new Error("Expected palette not found");
  }
  this.inflateData(data);
  let leftOverLength = length - data.length;
  if (leftOverLength > 0) {
    this._handleIDAT(leftOverLength);
  } else {
    this._handleChunkEnd();
  }
};
Parser$5.prototype._handleIEND = function(length) {
  this.read(length, this._parseIEND.bind(this));
};
Parser$5.prototype._parseIEND = function(data) {
  this._crc.write(data);
  this._hasIEND = true;
  this._handleChunkEnd();
  if (this.finished) {
    this.finished();
  }
};
var parserExports = parser$1.exports;
var bitmapper$2 = {};
let interlaceUtils = interlace;
let pixelBppMapper = [
  // 0 - dummy entry
  function() {
  },
  // 1 - L
  // 0: 0, 1: 0, 2: 0, 3: 0xff
  function(pxData, data, pxPos, rawPos) {
    if (rawPos === data.length) {
      throw new Error("Ran out of data");
    }
    let pixel = data[rawPos];
    pxData[pxPos] = pixel;
    pxData[pxPos + 1] = pixel;
    pxData[pxPos + 2] = pixel;
    pxData[pxPos + 3] = 255;
  },
  // 2 - LA
  // 0: 0, 1: 0, 2: 0, 3: 1
  function(pxData, data, pxPos, rawPos) {
    if (rawPos + 1 >= data.length) {
      throw new Error("Ran out of data");
    }
    let pixel = data[rawPos];
    pxData[pxPos] = pixel;
    pxData[pxPos + 1] = pixel;
    pxData[pxPos + 2] = pixel;
    pxData[pxPos + 3] = data[rawPos + 1];
  },
  // 3 - RGB
  // 0: 0, 1: 1, 2: 2, 3: 0xff
  function(pxData, data, pxPos, rawPos) {
    if (rawPos + 2 >= data.length) {
      throw new Error("Ran out of data");
    }
    pxData[pxPos] = data[rawPos];
    pxData[pxPos + 1] = data[rawPos + 1];
    pxData[pxPos + 2] = data[rawPos + 2];
    pxData[pxPos + 3] = 255;
  },
  // 4 - RGBA
  // 0: 0, 1: 1, 2: 2, 3: 3
  function(pxData, data, pxPos, rawPos) {
    if (rawPos + 3 >= data.length) {
      throw new Error("Ran out of data");
    }
    pxData[pxPos] = data[rawPos];
    pxData[pxPos + 1] = data[rawPos + 1];
    pxData[pxPos + 2] = data[rawPos + 2];
    pxData[pxPos + 3] = data[rawPos + 3];
  }
];
let pixelBppCustomMapper = [
  // 0 - dummy entry
  function() {
  },
  // 1 - L
  // 0: 0, 1: 0, 2: 0, 3: 0xff
  function(pxData, pixelData, pxPos, maxBit) {
    let pixel = pixelData[0];
    pxData[pxPos] = pixel;
    pxData[pxPos + 1] = pixel;
    pxData[pxPos + 2] = pixel;
    pxData[pxPos + 3] = maxBit;
  },
  // 2 - LA
  // 0: 0, 1: 0, 2: 0, 3: 1
  function(pxData, pixelData, pxPos) {
    let pixel = pixelData[0];
    pxData[pxPos] = pixel;
    pxData[pxPos + 1] = pixel;
    pxData[pxPos + 2] = pixel;
    pxData[pxPos + 3] = pixelData[1];
  },
  // 3 - RGB
  // 0: 0, 1: 1, 2: 2, 3: 0xff
  function(pxData, pixelData, pxPos, maxBit) {
    pxData[pxPos] = pixelData[0];
    pxData[pxPos + 1] = pixelData[1];
    pxData[pxPos + 2] = pixelData[2];
    pxData[pxPos + 3] = maxBit;
  },
  // 4 - RGBA
  // 0: 0, 1: 1, 2: 2, 3: 3
  function(pxData, pixelData, pxPos) {
    pxData[pxPos] = pixelData[0];
    pxData[pxPos + 1] = pixelData[1];
    pxData[pxPos + 2] = pixelData[2];
    pxData[pxPos + 3] = pixelData[3];
  }
];
function bitRetriever(data, depth) {
  let leftOver = [];
  let i = 0;
  function split() {
    if (i === data.length) {
      throw new Error("Ran out of data");
    }
    let byte = data[i];
    i++;
    let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
    switch (depth) {
      default:
        throw new Error("unrecognised depth");
      case 16:
        byte2 = data[i];
        i++;
        leftOver.push((byte << 8) + byte2);
        break;
      case 4:
        byte2 = byte & 15;
        byte1 = byte >> 4;
        leftOver.push(byte1, byte2);
        break;
      case 2:
        byte4 = byte & 3;
        byte3 = byte >> 2 & 3;
        byte2 = byte >> 4 & 3;
        byte1 = byte >> 6 & 3;
        leftOver.push(byte1, byte2, byte3, byte4);
        break;
      case 1:
        byte8 = byte & 1;
        byte7 = byte >> 1 & 1;
        byte6 = byte >> 2 & 1;
        byte5 = byte >> 3 & 1;
        byte4 = byte >> 4 & 1;
        byte3 = byte >> 5 & 1;
        byte2 = byte >> 6 & 1;
        byte1 = byte >> 7 & 1;
        leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
        break;
    }
  }
  return {
    get: function(count) {
      while (leftOver.length < count) {
        split();
      }
      let returner = leftOver.slice(0, count);
      leftOver = leftOver.slice(count);
      return returner;
    },
    resetAfterLine: function() {
      leftOver.length = 0;
    },
    end: function() {
      if (i !== data.length) {
        throw new Error("extra data found");
      }
    }
  };
}
function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
  let imageWidth = image.width;
  let imageHeight = image.height;
  let imagePass = image.index;
  for (let y2 = 0; y2 < imageHeight; y2++) {
    for (let x2 = 0; x2 < imageWidth; x2++) {
      let pxPos = getPxPos(x2, y2, imagePass);
      pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
      rawPos += bpp;
    }
  }
  return rawPos;
}
function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
  let imageWidth = image.width;
  let imageHeight = image.height;
  let imagePass = image.index;
  for (let y2 = 0; y2 < imageHeight; y2++) {
    for (let x2 = 0; x2 < imageWidth; x2++) {
      let pixelData = bits.get(bpp);
      let pxPos = getPxPos(x2, y2, imagePass);
      pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
    }
    bits.resetAfterLine();
  }
}
bitmapper$2.dataToBitMap = function(data, bitmapInfo) {
  let width = bitmapInfo.width;
  let height = bitmapInfo.height;
  let depth = bitmapInfo.depth;
  let bpp = bitmapInfo.bpp;
  let interlace2 = bitmapInfo.interlace;
  let bits;
  if (depth !== 8) {
    bits = bitRetriever(data, depth);
  }
  let pxData;
  if (depth <= 8) {
    pxData = Buffer.alloc(width * height * 4);
  } else {
    pxData = new Uint16Array(width * height * 4);
  }
  let maxBit = Math.pow(2, depth) - 1;
  let rawPos = 0;
  let images;
  let getPxPos;
  if (interlace2) {
    images = interlaceUtils.getImagePasses(width, height);
    getPxPos = interlaceUtils.getInterlaceIterator(width, height);
  } else {
    let nonInterlacedPxPos = 0;
    getPxPos = function() {
      let returner = nonInterlacedPxPos;
      nonInterlacedPxPos += 4;
      return returner;
    };
    images = [{ width, height }];
  }
  for (let imageIndex = 0; imageIndex < images.length; imageIndex++) {
    if (depth === 8) {
      rawPos = mapImage8Bit(
        images[imageIndex],
        pxData,
        getPxPos,
        bpp,
        data,
        rawPos
      );
    } else {
      mapImageCustomBit(
        images[imageIndex],
        pxData,
        getPxPos,
        bpp,
        bits,
        maxBit
      );
    }
  }
  if (depth === 8) {
    if (rawPos !== data.length) {
      throw new Error("extra data found");
    }
  } else {
    bits.end();
  }
  return pxData;
};
function dePalette(indata, outdata, width, height, palette) {
  let pxPos = 0;
  for (let y2 = 0; y2 < height; y2++) {
    for (let x2 = 0; x2 < width; x2++) {
      let color = palette[indata[pxPos]];
      if (!color) {
        throw new Error("index " + indata[pxPos] + " not in palette");
      }
      for (let i = 0; i < 4; i++) {
        outdata[pxPos + i] = color[i];
      }
      pxPos += 4;
    }
  }
}
function replaceTransparentColor(indata, outdata, width, height, transColor) {
  let pxPos = 0;
  for (let y2 = 0; y2 < height; y2++) {
    for (let x2 = 0; x2 < width; x2++) {
      let makeTrans = false;
      if (transColor.length === 1) {
        if (transColor[0] === indata[pxPos]) {
          makeTrans = true;
        }
      } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
        makeTrans = true;
      }
      if (makeTrans) {
        for (let i = 0; i < 4; i++) {
          outdata[pxPos + i] = 0;
        }
      }
      pxPos += 4;
    }
  }
}
function scaleDepth(indata, outdata, width, height, depth) {
  let maxOutSample = 255;
  let maxInSample = Math.pow(2, depth) - 1;
  let pxPos = 0;
  for (let y2 = 0; y2 < height; y2++) {
    for (let x2 = 0; x2 < width; x2++) {
      for (let i = 0; i < 4; i++) {
        outdata[pxPos + i] = Math.floor(
          indata[pxPos + i] * maxOutSample / maxInSample + 0.5
        );
      }
      pxPos += 4;
    }
  }
}
var formatNormaliser$2 = function(indata, imageData, skipRescale = false) {
  let depth = imageData.depth;
  let width = imageData.width;
  let height = imageData.height;
  let colorType = imageData.colorType;
  let transColor = imageData.transColor;
  let palette = imageData.palette;
  let outdata = indata;
  if (colorType === 3) {
    dePalette(indata, outdata, width, height, palette);
  } else {
    if (transColor) {
      replaceTransparentColor(indata, outdata, width, height, transColor);
    }
    if (depth !== 8 && !skipRescale) {
      if (depth === 16) {
        outdata = Buffer.alloc(width * height * 4);
      }
      scaleDepth(indata, outdata, width, height, depth);
    }
  }
  return outdata;
};
let util$j = require$$0;
let zlib$3 = require$$1$2;
let ChunkStream = chunkstreamExports;
let FilterAsync = filterParseAsyncExports;
let Parser$4 = parserExports;
let bitmapper$1 = bitmapper$2;
let formatNormaliser$1 = formatNormaliser$2;
let ParserAsync = parserAsync.exports = function(options) {
  ChunkStream.call(this);
  this._parser = new Parser$4(options, {
    read: this.read.bind(this),
    error: this._handleError.bind(this),
    metadata: this._handleMetaData.bind(this),
    gamma: this.emit.bind(this, "gamma"),
    palette: this._handlePalette.bind(this),
    transColor: this._handleTransColor.bind(this),
    finished: this._finished.bind(this),
    inflateData: this._inflateData.bind(this),
    simpleTransparency: this._simpleTransparency.bind(this),
    headersFinished: this._headersFinished.bind(this)
  });
  this._options = options;
  this.writable = true;
  this._parser.start();
};
util$j.inherits(ParserAsync, ChunkStream);
ParserAsync.prototype._handleError = function(err) {
  this.emit("error", err);
  this.writable = false;
  this.destroy();
  if (this._inflate && this._inflate.destroy) {
    this._inflate.destroy();
  }
  if (this._filter) {
    this._filter.destroy();
    this._filter.on("error", function() {
    });
  }
  this.errord = true;
};
ParserAsync.prototype._inflateData = function(data) {
  if (!this._inflate) {
    if (this._bitmapInfo.interlace) {
      this._inflate = zlib$3.createInflate();
      this._inflate.on("error", this.emit.bind(this, "error"));
      this._filter.on("complete", this._complete.bind(this));
      this._inflate.pipe(this._filter);
    } else {
      let rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
      let imageSize = rowSize * this._bitmapInfo.height;
      let chunkSize = Math.max(imageSize, zlib$3.Z_MIN_CHUNK);
      this._inflate = zlib$3.createInflate({ chunkSize });
      let leftToInflate = imageSize;
      let emitError = this.emit.bind(this, "error");
      this._inflate.on("error", function(err) {
        if (!leftToInflate) {
          return;
        }
        emitError(err);
      });
      this._filter.on("complete", this._complete.bind(this));
      let filterWrite = this._filter.write.bind(this._filter);
      this._inflate.on("data", function(chunk) {
        if (!leftToInflate) {
          return;
        }
        if (chunk.length > leftToInflate) {
          chunk = chunk.slice(0, leftToInflate);
        }
        leftToInflate -= chunk.length;
        filterWrite(chunk);
      });
      this._inflate.on("end", this._filter.end.bind(this._filter));
    }
  }
  this._inflate.write(data);
};
ParserAsync.prototype._handleMetaData = function(metaData) {
  this._metaData = metaData;
  this._bitmapInfo = Object.create(metaData);
  this._filter = new FilterAsync(this._bitmapInfo);
};
ParserAsync.prototype._handleTransColor = function(transColor) {
  this._bitmapInfo.transColor = transColor;
};
ParserAsync.prototype._handlePalette = function(palette) {
  this._bitmapInfo.palette = palette;
};
ParserAsync.prototype._simpleTransparency = function() {
  this._metaData.alpha = true;
};
ParserAsync.prototype._headersFinished = function() {
  this.emit("metadata", this._metaData);
};
ParserAsync.prototype._finished = function() {
  if (this.errord) {
    return;
  }
  if (!this._inflate) {
    this.emit("error", "No Inflate block");
  } else {
    this._inflate.end();
  }
};
ParserAsync.prototype._complete = function(filteredData) {
  if (this.errord) {
    return;
  }
  let normalisedBitmapData;
  try {
    let bitmapData = bitmapper$1.dataToBitMap(filteredData, this._bitmapInfo);
    normalisedBitmapData = formatNormaliser$1(
      bitmapData,
      this._bitmapInfo,
      this._options.skipRescale
    );
    bitmapData = null;
  } catch (ex) {
    this._handleError(ex);
    return;
  }
  this.emit("parsed", normalisedBitmapData);
};
var parserAsyncExports = parserAsync.exports;
var packerAsync = { exports: {} };
var packer = { exports: {} };
let constants$4 = constants$6;
var bitpacker = function(dataIn, width, height, options) {
  let outHasAlpha = [constants$4.COLORTYPE_COLOR_ALPHA, constants$4.COLORTYPE_ALPHA].indexOf(
    options.colorType
  ) !== -1;
  if (options.colorType === options.inputColorType) {
    let bigEndian = function() {
      let buffer = new ArrayBuffer(2);
      new DataView(buffer).setInt16(
        0,
        256,
        true
        /* littleEndian */
      );
      return new Int16Array(buffer)[0] !== 256;
    }();
    if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {
      return dataIn;
    }
  }
  let data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
  let maxValue = 255;
  let inBpp = constants$4.COLORTYPE_TO_BPP_MAP[options.inputColorType];
  if (inBpp === 4 && !options.inputHasAlpha) {
    inBpp = 3;
  }
  let outBpp = constants$4.COLORTYPE_TO_BPP_MAP[options.colorType];
  if (options.bitDepth === 16) {
    maxValue = 65535;
    outBpp *= 2;
  }
  let outData = Buffer.alloc(width * height * outBpp);
  let inIndex = 0;
  let outIndex = 0;
  let bgColor = options.bgColor || {};
  if (bgColor.red === void 0) {
    bgColor.red = maxValue;
  }
  if (bgColor.green === void 0) {
    bgColor.green = maxValue;
  }
  if (bgColor.blue === void 0) {
    bgColor.blue = maxValue;
  }
  function getRGBA() {
    let red;
    let green;
    let blue;
    let alpha = maxValue;
    switch (options.inputColorType) {
      case constants$4.COLORTYPE_COLOR_ALPHA:
        alpha = data[inIndex + 3];
        red = data[inIndex];
        green = data[inIndex + 1];
        blue = data[inIndex + 2];
        break;
      case constants$4.COLORTYPE_COLOR:
        red = data[inIndex];
        green = data[inIndex + 1];
        blue = data[inIndex + 2];
        break;
      case constants$4.COLORTYPE_ALPHA:
        alpha = data[inIndex + 1];
        red = data[inIndex];
        green = red;
        blue = red;
        break;
      case constants$4.COLORTYPE_GRAYSCALE:
        red = data[inIndex];
        green = red;
        blue = red;
        break;
      default:
        throw new Error(
          "input color type:" + options.inputColorType + " is not supported at present"
        );
    }
    if (options.inputHasAlpha) {
      if (!outHasAlpha) {
        alpha /= maxValue;
        red = Math.min(
          Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0),
          maxValue
        );
        green = Math.min(
          Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0),
          maxValue
        );
        blue = Math.min(
          Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0),
          maxValue
        );
      }
    }
    return { red, green, blue, alpha };
  }
  for (let y2 = 0; y2 < height; y2++) {
    for (let x2 = 0; x2 < width; x2++) {
      let rgba = getRGBA();
      switch (options.colorType) {
        case constants$4.COLORTYPE_COLOR_ALPHA:
        case constants$4.COLORTYPE_COLOR:
          if (options.bitDepth === 8) {
            outData[outIndex] = rgba.red;
            outData[outIndex + 1] = rgba.green;
            outData[outIndex + 2] = rgba.blue;
            if (outHasAlpha) {
              outData[outIndex + 3] = rgba.alpha;
            }
          } else {
            outData.writeUInt16BE(rgba.red, outIndex);
            outData.writeUInt16BE(rgba.green, outIndex + 2);
            outData.writeUInt16BE(rgba.blue, outIndex + 4);
            if (outHasAlpha) {
              outData.writeUInt16BE(rgba.alpha, outIndex + 6);
            }
          }
          break;
        case constants$4.COLORTYPE_ALPHA:
        case constants$4.COLORTYPE_GRAYSCALE: {
          let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
          if (options.bitDepth === 8) {
            outData[outIndex] = grayscale;
            if (outHasAlpha) {
              outData[outIndex + 1] = rgba.alpha;
            }
          } else {
            outData.writeUInt16BE(grayscale, outIndex);
            if (outHasAlpha) {
              outData.writeUInt16BE(rgba.alpha, outIndex + 2);
            }
          }
          break;
        }
        default:
          throw new Error("unrecognised color Type " + options.colorType);
      }
      inIndex += inBpp;
      outIndex += outBpp;
    }
  }
  return outData;
};
let paethPredictor = paethPredictor$2;
function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
  for (let x2 = 0; x2 < byteWidth; x2++) {
    rawData[rawPos + x2] = pxData[pxPos + x2];
  }
}
function filterSumNone(pxData, pxPos, byteWidth) {
  let sum = 0;
  let length = pxPos + byteWidth;
  for (let i = pxPos; i < length; i++) {
    sum += Math.abs(pxData[i]);
  }
  return sum;
}
function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
  for (let x2 = 0; x2 < byteWidth; x2++) {
    let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
    let val = pxData[pxPos + x2] - left;
    rawData[rawPos + x2] = val;
  }
}
function filterSumSub(pxData, pxPos, byteWidth, bpp) {
  let sum = 0;
  for (let x2 = 0; x2 < byteWidth; x2++) {
    let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
    let val = pxData[pxPos + x2] - left;
    sum += Math.abs(val);
  }
  return sum;
}
function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
  for (let x2 = 0; x2 < byteWidth; x2++) {
    let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
    let val = pxData[pxPos + x2] - up;
    rawData[rawPos + x2] = val;
  }
}
function filterSumUp(pxData, pxPos, byteWidth) {
  let sum = 0;
  let length = pxPos + byteWidth;
  for (let x2 = pxPos; x2 < length; x2++) {
    let up = pxPos > 0 ? pxData[x2 - byteWidth] : 0;
    let val = pxData[x2] - up;
    sum += Math.abs(val);
  }
  return sum;
}
function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
  for (let x2 = 0; x2 < byteWidth; x2++) {
    let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
    let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
    let val = pxData[pxPos + x2] - (left + up >> 1);
    rawData[rawPos + x2] = val;
  }
}
function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
  let sum = 0;
  for (let x2 = 0; x2 < byteWidth; x2++) {
    let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
    let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
    let val = pxData[pxPos + x2] - (left + up >> 1);
    sum += Math.abs(val);
  }
  return sum;
}
function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
  for (let x2 = 0; x2 < byteWidth; x2++) {
    let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
    let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
    let upleft = pxPos > 0 && x2 >= bpp ? pxData[pxPos + x2 - (byteWidth + bpp)] : 0;
    let val = pxData[pxPos + x2] - paethPredictor(left, up, upleft);
    rawData[rawPos + x2] = val;
  }
}
function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
  let sum = 0;
  for (let x2 = 0; x2 < byteWidth; x2++) {
    let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
    let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
    let upleft = pxPos > 0 && x2 >= bpp ? pxData[pxPos + x2 - (byteWidth + bpp)] : 0;
    let val = pxData[pxPos + x2] - paethPredictor(left, up, upleft);
    sum += Math.abs(val);
  }
  return sum;
}
let filters = {
  0: filterNone,
  1: filterSub,
  2: filterUp,
  3: filterAvg,
  4: filterPaeth
};
let filterSums = {
  0: filterSumNone,
  1: filterSumSub,
  2: filterSumUp,
  3: filterSumAvg,
  4: filterSumPaeth
};
var filterPack = function(pxData, width, height, options, bpp) {
  let filterTypes;
  if (!("filterType" in options) || options.filterType === -1) {
    filterTypes = [0, 1, 2, 3, 4];
  } else if (typeof options.filterType === "number") {
    filterTypes = [options.filterType];
  } else {
    throw new Error("unrecognised filter types");
  }
  if (options.bitDepth === 16) {
    bpp *= 2;
  }
  let byteWidth = width * bpp;
  let rawPos = 0;
  let pxPos = 0;
  let rawData = Buffer.alloc((byteWidth + 1) * height);
  let sel = filterTypes[0];
  for (let y2 = 0; y2 < height; y2++) {
    if (filterTypes.length > 1) {
      let min = Infinity;
      for (let i = 0; i < filterTypes.length; i++) {
        let sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
        if (sum < min) {
          sel = filterTypes[i];
          min = sum;
        }
      }
    }
    rawData[rawPos] = sel;
    rawPos++;
    filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
    rawPos += byteWidth;
    pxPos += byteWidth;
  }
  return rawData;
};
let constants$3 = constants$6;
let CrcStream = crcExports;
let bitPacker = bitpacker;
let filter = filterPack;
let zlib$2 = require$$1$2;
let Packer$3 = packer.exports = function(options) {
  this._options = options;
  options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
  options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
  options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
  options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
  options.deflateFactory = options.deflateFactory || zlib$2.createDeflate;
  options.bitDepth = options.bitDepth || 8;
  options.colorType = typeof options.colorType === "number" ? options.colorType : constants$3.COLORTYPE_COLOR_ALPHA;
  options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants$3.COLORTYPE_COLOR_ALPHA;
  if ([
    constants$3.COLORTYPE_GRAYSCALE,
    constants$3.COLORTYPE_COLOR,
    constants$3.COLORTYPE_COLOR_ALPHA,
    constants$3.COLORTYPE_ALPHA
  ].indexOf(options.colorType) === -1) {
    throw new Error(
      "option color type:" + options.colorType + " is not supported at present"
    );
  }
  if ([
    constants$3.COLORTYPE_GRAYSCALE,
    constants$3.COLORTYPE_COLOR,
    constants$3.COLORTYPE_COLOR_ALPHA,
    constants$3.COLORTYPE_ALPHA
  ].indexOf(options.inputColorType) === -1) {
    throw new Error(
      "option input color type:" + options.inputColorType + " is not supported at present"
    );
  }
  if (options.bitDepth !== 8 && options.bitDepth !== 16) {
    throw new Error(
      "option bit depth:" + options.bitDepth + " is not supported at present"
    );
  }
};
Packer$3.prototype.getDeflateOptions = function() {
  return {
    chunkSize: this._options.deflateChunkSize,
    level: this._options.deflateLevel,
    strategy: this._options.deflateStrategy
  };
};
Packer$3.prototype.createDeflate = function() {
  return this._options.deflateFactory(this.getDeflateOptions());
};
Packer$3.prototype.filterData = function(data, width, height) {
  let packedData = bitPacker(data, width, height, this._options);
  let bpp = constants$3.COLORTYPE_TO_BPP_MAP[this._options.colorType];
  let filteredData = filter(packedData, width, height, this._options, bpp);
  return filteredData;
};
Packer$3.prototype._packChunk = function(type, data) {
  let len = data ? data.length : 0;
  let buf = Buffer.alloc(len + 12);
  buf.writeUInt32BE(len, 0);
  buf.writeUInt32BE(type, 4);
  if (data) {
    data.copy(buf, 8);
  }
  buf.writeInt32BE(
    CrcStream.crc32(buf.slice(4, buf.length - 4)),
    buf.length - 4
  );
  return buf;
};
Packer$3.prototype.packGAMA = function(gamma) {
  let buf = Buffer.alloc(4);
  buf.writeUInt32BE(Math.floor(gamma * constants$3.GAMMA_DIVISION), 0);
  return this._packChunk(constants$3.TYPE_gAMA, buf);
};
Packer$3.prototype.packIHDR = function(width, height) {
  let buf = Buffer.alloc(13);
  buf.writeUInt32BE(width, 0);
  buf.writeUInt32BE(height, 4);
  buf[8] = this._options.bitDepth;
  buf[9] = this._options.colorType;
  buf[10] = 0;
  buf[11] = 0;
  buf[12] = 0;
  return this._packChunk(constants$3.TYPE_IHDR, buf);
};
Packer$3.prototype.packIDAT = function(data) {
  return this._packChunk(constants$3.TYPE_IDAT, data);
};
Packer$3.prototype.packIEND = function() {
  return this._packChunk(constants$3.TYPE_IEND, null);
};
var packerExports = packer.exports;
let util$i = require$$0;
let Stream$1 = require$$1$1;
let constants$2 = constants$6;
let Packer$2 = packerExports;
let PackerAsync = packerAsync.exports = function(opt) {
  Stream$1.call(this);
  let options = opt || {};
  this._packer = new Packer$2(options);
  this._deflate = this._packer.createDeflate();
  this.readable = true;
};
util$i.inherits(PackerAsync, Stream$1);
PackerAsync.prototype.pack = function(data, width, height, gamma) {
  this.emit("data", Buffer.from(constants$2.PNG_SIGNATURE));
  this.emit("data", this._packer.packIHDR(width, height));
  if (gamma) {
    this.emit("data", this._packer.packGAMA(gamma));
  }
  let filteredData = this._packer.filterData(data, width, height);
  this._deflate.on("error", this.emit.bind(this, "error"));
  this._deflate.on(
    "data",
    (function(compressedData) {
      this.emit("data", this._packer.packIDAT(compressedData));
    }).bind(this)
  );
  this._deflate.on(
    "end",
    (function() {
      this.emit("data", this._packer.packIEND());
      this.emit("end");
    }).bind(this)
  );
  this._deflate.end(filteredData);
};
var packerAsyncExports = packerAsync.exports;
var pngSync = {};
var syncInflate = { exports: {} };
(function(module, exports) {
  let assert = require$$0$1.ok;
  let zlib2 = require$$1$2;
  let util2 = require$$0;
  let kMaxLength = require$$3.kMaxLength;
  function Inflate(opts) {
    if (!(this instanceof Inflate)) {
      return new Inflate(opts);
    }
    if (opts && opts.chunkSize < zlib2.Z_MIN_CHUNK) {
      opts.chunkSize = zlib2.Z_MIN_CHUNK;
    }
    zlib2.Inflate.call(this, opts);
    this._offset = this._offset === void 0 ? this._outOffset : this._offset;
    this._buffer = this._buffer || this._outBuffer;
    if (opts && opts.maxLength != null) {
      this._maxLength = opts.maxLength;
    }
  }
  function createInflate(opts) {
    return new Inflate(opts);
  }
  function _close(engine, callback) {
    if (!engine._handle) {
      return;
    }
    engine._handle.close();
    engine._handle = null;
  }
  Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
    if (typeof asyncCb === "function") {
      return zlib2.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
    }
    let self2 = this;
    let availInBefore = chunk && chunk.length;
    let availOutBefore = this._chunkSize - this._offset;
    let leftToInflate = this._maxLength;
    let inOff = 0;
    let buffers = [];
    let nread = 0;
    let error;
    this.on("error", function(err) {
      error = err;
    });
    function handleChunk(availInAfter, availOutAfter) {
      if (self2._hadError) {
        return;
      }
      let have = availOutBefore - availOutAfter;
      assert(have >= 0, "have should not go down");
      if (have > 0) {
        let out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (out.length > leftToInflate) {
          out = out.slice(0, leftToInflate);
        }
        buffers.push(out);
        nread += out.length;
        leftToInflate -= out.length;
        if (leftToInflate === 0) {
          return false;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        return true;
      }
      return false;
    }
    assert(this._handle, "zlib binding closed");
    let res;
    do {
      res = this._handle.writeSync(
        flushFlag,
        chunk,
        // in
        inOff,
        // in_off
        availInBefore,
        // in_len
        this._buffer,
        // out
        this._offset,
        //out_off
        availOutBefore
      );
      res = res || this._writeState;
    } while (!this._hadError && handleChunk(res[0], res[1]));
    if (this._hadError) {
      throw error;
    }
    if (nread >= kMaxLength) {
      _close(this);
      throw new RangeError(
        "Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes"
      );
    }
    let buf = Buffer.concat(buffers, nread);
    _close(this);
    return buf;
  };
  util2.inherits(Inflate, zlib2.Inflate);
  function zlibBufferSync(engine, buffer) {
    if (typeof buffer === "string") {
      buffer = Buffer.from(buffer);
    }
    if (!(buffer instanceof Buffer)) {
      throw new TypeError("Not a string or buffer");
    }
    let flushFlag = engine._finishFlushFlag;
    if (flushFlag == null) {
      flushFlag = zlib2.Z_FINISH;
    }
    return engine._processChunk(buffer, flushFlag);
  }
  function inflateSync2(buffer, opts) {
    return zlibBufferSync(new Inflate(opts), buffer);
  }
  module.exports = exports = inflateSync2;
  exports.Inflate = Inflate;
  exports.createInflate = createInflate;
  exports.inflateSync = inflateSync2;
})(syncInflate, syncInflate.exports);
var syncInflateExports = syncInflate.exports;
var syncReader = { exports: {} };
let SyncReader$2 = syncReader.exports = function(buffer) {
  this._buffer = buffer;
  this._reads = [];
};
SyncReader$2.prototype.read = function(length, callback) {
  this._reads.push({
    length: Math.abs(length),
    // if length < 0 then at most this length
    allowLess: length < 0,
    func: callback
  });
};
SyncReader$2.prototype.process = function() {
  while (this._reads.length > 0 && this._buffer.length) {
    let read = this._reads[0];
    if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
      this._reads.shift();
      let buf = this._buffer;
      this._buffer = buf.slice(read.length);
      read.func.call(this, buf.slice(0, read.length));
    } else {
      break;
    }
  }
  if (this._reads.length > 0) {
    throw new Error("There are some read requests waitng on finished stream");
  }
  if (this._buffer.length > 0) {
    throw new Error("unrecognised content at end of stream");
  }
};
var syncReaderExports = syncReader.exports;
var filterParseSync = {};
let SyncReader$1 = syncReaderExports;
let Filter = filterParseExports;
filterParseSync.process = function(inBuffer, bitmapInfo) {
  let outBuffers = [];
  let reader = new SyncReader$1(inBuffer);
  let filter2 = new Filter(bitmapInfo, {
    read: reader.read.bind(reader),
    write: function(bufferPart) {
      outBuffers.push(bufferPart);
    },
    complete: function() {
    }
  });
  filter2.start();
  reader.process();
  return Buffer.concat(outBuffers);
};
let hasSyncZlib$1 = true;
let zlib$1 = require$$1$2;
let inflateSync = syncInflateExports;
if (!zlib$1.deflateSync) {
  hasSyncZlib$1 = false;
}
let SyncReader = syncReaderExports;
let FilterSync = filterParseSync;
let Parser$3 = parserExports;
let bitmapper = bitmapper$2;
let formatNormaliser = formatNormaliser$2;
var parserSync = function(buffer, options) {
  if (!hasSyncZlib$1) {
    throw new Error(
      "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
    );
  }
  let err;
  function handleError(_err_) {
    err = _err_;
  }
  let metaData;
  function handleMetaData(_metaData_) {
    metaData = _metaData_;
  }
  function handleTransColor(transColor) {
    metaData.transColor = transColor;
  }
  function handlePalette(palette) {
    metaData.palette = palette;
  }
  function handleSimpleTransparency() {
    metaData.alpha = true;
  }
  let gamma;
  function handleGamma(_gamma_) {
    gamma = _gamma_;
  }
  let inflateDataList = [];
  function handleInflateData(inflatedData2) {
    inflateDataList.push(inflatedData2);
  }
  let reader = new SyncReader(buffer);
  let parser2 = new Parser$3(options, {
    read: reader.read.bind(reader),
    error: handleError,
    metadata: handleMetaData,
    gamma: handleGamma,
    palette: handlePalette,
    transColor: handleTransColor,
    inflateData: handleInflateData,
    simpleTransparency: handleSimpleTransparency
  });
  parser2.start();
  reader.process();
  if (err) {
    throw err;
  }
  let inflateData = Buffer.concat(inflateDataList);
  inflateDataList.length = 0;
  let inflatedData;
  if (metaData.interlace) {
    inflatedData = zlib$1.inflateSync(inflateData);
  } else {
    let rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
    let imageSize = rowSize * metaData.height;
    inflatedData = inflateSync(inflateData, {
      chunkSize: imageSize,
      maxLength: imageSize
    });
  }
  inflateData = null;
  if (!inflatedData || !inflatedData.length) {
    throw new Error("bad png - invalid inflate data response");
  }
  let unfilteredData = FilterSync.process(inflatedData, metaData);
  inflateData = null;
  let bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
  unfilteredData = null;
  let normalisedBitmapData = formatNormaliser(
    bitmapData,
    metaData,
    options.skipRescale
  );
  metaData.data = normalisedBitmapData;
  metaData.gamma = gamma || 0;
  return metaData;
};
let hasSyncZlib = true;
let zlib = require$$1$2;
if (!zlib.deflateSync) {
  hasSyncZlib = false;
}
let constants$1 = constants$6;
let Packer$1 = packerExports;
var packerSync = function(metaData, opt) {
  if (!hasSyncZlib) {
    throw new Error(
      "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
    );
  }
  let options = opt || {};
  let packer2 = new Packer$1(options);
  let chunks = [];
  chunks.push(Buffer.from(constants$1.PNG_SIGNATURE));
  chunks.push(packer2.packIHDR(metaData.width, metaData.height));
  if (metaData.gamma) {
    chunks.push(packer2.packGAMA(metaData.gamma));
  }
  let filteredData = packer2.filterData(
    metaData.data,
    metaData.width,
    metaData.height
  );
  let compressedData = zlib.deflateSync(
    filteredData,
    packer2.getDeflateOptions()
  );
  filteredData = null;
  if (!compressedData || !compressedData.length) {
    throw new Error("bad png - invalid compressed data response");
  }
  chunks.push(packer2.packIDAT(compressedData));
  chunks.push(packer2.packIEND());
  return Buffer.concat(chunks);
};
let parse = parserSync;
let pack = packerSync;
pngSync.read = function(buffer, options) {
  return parse(buffer, options || {});
};
pngSync.write = function(png2, options) {
  return pack(png2, options);
};
var PNG_1;
let util$h = require$$0;
let Stream = require$$1$1;
let Parser$2 = parserAsyncExports;
let Packer = packerAsyncExports;
let PNGSync = pngSync;
let PNG = PNG_1 = function(options) {
  Stream.call(this);
  options = options || {};
  this.width = options.width | 0;
  this.height = options.height | 0;
  this.data = this.width > 0 && this.height > 0 ? Buffer.alloc(4 * this.width * this.height) : null;
  if (options.fill && this.data) {
    this.data.fill(0);
  }
  this.gamma = 0;
  this.readable = this.writable = true;
  this._parser = new Parser$2(options);
  this._parser.on("error", this.emit.bind(this, "error"));
  this._parser.on("close", this._handleClose.bind(this));
  this._parser.on("metadata", this._metadata.bind(this));
  this._parser.on("gamma", this._gamma.bind(this));
  this._parser.on(
    "parsed",
    (function(data) {
      this.data = data;
      this.emit("parsed", data);
    }).bind(this)
  );
  this._packer = new Packer(options);
  this._packer.on("data", this.emit.bind(this, "data"));
  this._packer.on("end", this.emit.bind(this, "end"));
  this._parser.on("close", this._handleClose.bind(this));
  this._packer.on("error", this.emit.bind(this, "error"));
};
util$h.inherits(PNG, Stream);
PNG.sync = PNGSync;
PNG.prototype.pack = function() {
  if (!this.data || !this.data.length) {
    this.emit("error", "No data provided");
    return this;
  }
  process.nextTick(
    (function() {
      this._packer.pack(this.data, this.width, this.height, this.gamma);
    }).bind(this)
  );
  return this;
};
PNG.prototype.parse = function(data, callback) {
  if (callback) {
    let onParsed, onError;
    onParsed = (function(parsedData) {
      this.removeListener("error", onError);
      this.data = parsedData;
      callback(null, this);
    }).bind(this);
    onError = (function(err) {
      this.removeListener("parsed", onParsed);
      callback(err, null);
    }).bind(this);
    this.once("parsed", onParsed);
    this.once("error", onError);
  }
  this.end(data);
  return this;
};
PNG.prototype.write = function(data) {
  this._parser.write(data);
  return true;
};
PNG.prototype.end = function(data) {
  this._parser.end(data);
};
PNG.prototype._metadata = function(metadata) {
  this.width = metadata.width;
  this.height = metadata.height;
  this.emit("metadata", metadata);
};
PNG.prototype._gamma = function(gamma) {
  this.gamma = gamma;
};
PNG.prototype._handleClose = function() {
  if (!this._parser.writable && !this._packer.readable) {
    this.emit("close");
  }
};
PNG.bitblt = function(src2, dst, srcX, srcY, width, height, deltaX, deltaY) {
  srcX |= 0;
  srcY |= 0;
  width |= 0;
  height |= 0;
  deltaX |= 0;
  deltaY |= 0;
  if (srcX > src2.width || srcY > src2.height || srcX + width > src2.width || srcY + height > src2.height) {
    throw new Error("bitblt reading outside image");
  }
  if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
    throw new Error("bitblt writing outside image");
  }
  for (let y2 = 0; y2 < height; y2++) {
    src2.data.copy(
      dst.data,
      (deltaY + y2) * dst.width + deltaX << 2,
      (srcY + y2) * src2.width + srcX << 2,
      (srcY + y2) * src2.width + srcX + width << 2
    );
  }
};
PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
  PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
  return this;
};
PNG.adjustGamma = function(src2) {
  if (src2.gamma) {
    for (let y2 = 0; y2 < src2.height; y2++) {
      for (let x2 = 0; x2 < src2.width; x2++) {
        let idx = src2.width * y2 + x2 << 2;
        for (let i = 0; i < 3; i++) {
          let sample = src2.data[idx + i] / 255;
          sample = Math.pow(sample, 1 / 2.2 / src2.gamma);
          src2.data[idx + i] = Math.round(sample * 255);
        }
      }
    }
    src2.gamma = 0;
  }
};
PNG.prototype.adjustGamma = function() {
  PNG.adjustGamma(this);
};
var PNGFilterType;
(function(PNGFilterType2) {
  PNGFilterType2[PNGFilterType2["AUTO"] = -1] = "AUTO";
  PNGFilterType2[PNGFilterType2["NONE"] = 0] = "NONE";
  PNGFilterType2[PNGFilterType2["SUB"] = 1] = "SUB";
  PNGFilterType2[PNGFilterType2["UP"] = 2] = "UP";
  PNGFilterType2[PNGFilterType2["AVERAGE"] = 3] = "AVERAGE";
  PNGFilterType2[PNGFilterType2["PATH"] = 4] = "PATH";
})(PNGFilterType || (PNGFilterType = {}));
var PNGColorType;
(function(PNGColorType2) {
  PNGColorType2[PNGColorType2["GRAYSCALE"] = 0] = "GRAYSCALE";
  PNGColorType2[PNGColorType2["COLOR"] = 2] = "COLOR";
  PNGColorType2[PNGColorType2["GRAYSCALE_ALPHA"] = 4] = "GRAYSCALE_ALPHA";
  PNGColorType2[PNGColorType2["COLOR_ALPHA"] = 6] = "COLOR_ALPHA";
})(PNGColorType || (PNGColorType = {}));
function png() {
  return {
    mime: "image/png",
    hasAlpha: true,
    encode: (bitmap, { deflateLevel = 9, deflateStrategy = 3, filterType = PNGFilterType.AUTO, colorType, inputHasAlpha = true, ...options } = {}) => {
      const png2 = new PNG_1({
        width: bitmap.width,
        height: bitmap.height
      });
      png2.data = bitmap.data;
      return PNG_1.sync.write(png2, {
        ...options,
        deflateLevel,
        deflateStrategy,
        filterType,
        colorType: typeof colorType !== "undefined" ? colorType : inputHasAlpha ? PNGColorType.COLOR_ALPHA : PNGColorType.COLOR,
        inputHasAlpha
      });
    },
    decode: (data, options) => {
      const result = PNG_1.sync.read(data, options);
      return {
        data: result.data,
        width: result.width,
        height: result.height
      };
    }
  };
}
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var UTIF = { exports: {} };
var common = {};
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  (function(exports) {
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src2, src_offs, len, dest_offs) {
        if (src2.subarray && dest.subarray) {
          dest.set(src2.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src2[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src2, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src2[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  })(common);
  return common;
}
var deflate$1 = {};
var deflate = {};
var trees = {};
var hasRequiredTrees;
function requireTrees() {
  if (hasRequiredTrees) return trees;
  hasRequiredTrees = 1;
  var utils = requireCommon();
  var Z_FIXED = 4;
  var Z_BINARY = 0;
  var Z_TEXT = 1;
  var Z_UNKNOWN = 2;
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = (
    /* extra bits for each length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
  );
  var extra_dbits = (
    /* extra bits for each distance code */
    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
  );
  var extra_blbits = (
    /* extra bits for each bit length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
  );
  var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  var static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  var base_length = new Array(LENGTH_CODES);
  zero(base_length);
  var base_dist = new Array(D_CODES);
  zero(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  function d_code(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  }
  function put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  function send_bits(s, value, length) {
    if (s.bi_valid > Buf_size - length) {
      s.bi_buf |= value << s.bi_valid & 65535;
      put_short(s, s.bi_buf);
      s.bi_buf = value >> Buf_size - s.bi_valid;
      s.bi_valid += length - Buf_size;
    } else {
      s.bi_buf |= value << s.bi_valid & 65535;
      s.bi_valid += length;
    }
  }
  function send_code(s, c2, tree) {
    send_bits(
      s,
      tree[c2 * 2],
      tree[c2 * 2 + 1]
      /*.Len*/
    );
  }
  function bi_reverse(code, len) {
    var res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  function bi_flush(s) {
    if (s.bi_valid === 16) {
      put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  function gen_bitlen(s, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h;
    var n, m;
    var bits;
    var xbits;
    var f;
    var overflow = 0;
    for (bits = 0; bits <= MAX_BITS; bits++) {
      s.bl_count[bits] = 0;
    }
    tree[s.heap[s.heap_max] * 2 + 1] = 0;
    for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
      n = s.heap[h];
      bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n * 2 + 1] = bits;
      if (n > max_code) {
        continue;
      }
      s.bl_count[bits]++;
      xbits = 0;
      if (n >= base) {
        xbits = extra[n - base];
      }
      f = tree[n * 2];
      s.opt_len += f * (bits + xbits);
      if (has_stree) {
        s.static_len += f * (stree[n * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s.bl_count[bits] === 0) {
        bits--;
      }
      s.bl_count[bits]--;
      s.bl_count[bits + 1] += 2;
      s.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length; bits !== 0; bits--) {
      n = s.bl_count[bits];
      while (n !== 0) {
        m = s.heap[--h];
        if (m > max_code) {
          continue;
        }
        if (tree[m * 2 + 1] !== bits) {
          s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
          tree[m * 2 + 1] = bits;
        }
        n--;
      }
    }
  }
  function gen_codes(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS + 1);
    var code = 0;
    var bits;
    var n;
    for (bits = 1; bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      var len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = bi_reverse(next_code[len]++, len);
    }
  }
  function tr_static_init() {
    var n;
    var bits;
    var length;
    var code;
    var dist;
    var bl_count = new Array(MAX_BITS + 1);
    length = 0;
    for (code = 0; code < LENGTH_CODES - 1; code++) {
      base_length[code] = length;
      for (n = 0; n < 1 << extra_lbits[code]; n++) {
        _length_code[length++] = code;
      }
    }
    _length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      base_dist[code] = dist;
      for (n = 0; n < 1 << extra_dbits[code]; n++) {
        _dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < D_CODES; code++) {
      base_dist[code] = dist << 7;
      for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
        _dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for (n = 0; n < D_CODES; n++) {
      static_dtree[n * 2 + 1] = 5;
      static_dtree[n * 2] = bi_reverse(n, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  }
  function init_block(s) {
    var n;
    for (n = 0; n < L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  function bi_windup(s) {
    if (s.bi_valid > 8) {
      put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  function copy_block(s, buf, len, header) {
    bi_windup(s);
    {
      put_short(s, len);
      put_short(s, ~len);
    }
    utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
    s.pending += len;
  }
  function smaller(tree, n, m, depth) {
    var _n2 = n * 2;
    var _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  function pqdownheap(s, tree, k) {
    var v = s.heap[k];
    var j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  function compress_block(s, ltree, dtree) {
    var dist;
    var lc;
    var lx = 0;
    var code;
    var extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          send_code(s, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s, code + LITERALS + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s, lc, extra);
          }
          dist--;
          code = d_code(dist);
          send_code(s, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist -= base_dist[code];
            send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    send_code(s, END_BLOCK, ltree);
  }
  function build_tree(s, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n, m;
    var max_code = -1;
    var node;
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[
        1
        /*SMALLEST*/
      ];
      s.heap[
        1
        /*SMALLEST*/
      ] = s.heap[s.heap_len--];
      pqdownheap(
        s,
        tree,
        1
        /*SMALLEST*/
      );
      m = s.heap[
        1
        /*SMALLEST*/
      ];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[
        1
        /*SMALLEST*/
      ] = node++;
      pqdownheap(
        s,
        tree,
        1
        /*SMALLEST*/
      );
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[
      1
      /*SMALLEST*/
    ];
    gen_bitlen(s, desc);
    gen_codes(tree, max_code, s.bl_count);
  }
  function scan_tree(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function send_tree(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s, curlen, s.bl_tree);
          count--;
        }
        send_code(s, REP_3_6, s.bl_tree);
        send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        send_code(s, REPZ_3_10, s.bl_tree);
        send_bits(s, count - 3, 3);
      } else {
        send_code(s, REPZ_11_138, s.bl_tree);
        send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function build_bl_tree(s) {
    var max_blindex;
    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    build_tree(s, s.bl_desc);
    for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  function send_all_trees(s, lcodes, dcodes, blcodes) {
    var rank;
    send_bits(s, lcodes - 257, 5);
    send_bits(s, dcodes - 1, 5);
    send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
    }
    send_tree(s, s.dyn_ltree, lcodes - 1);
    send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  function detect_data_type(s) {
    var black_mask = 4093624447;
    var n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT;
    }
    for (n = 32; n < LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return Z_TEXT;
      }
    }
    return Z_BINARY;
  }
  var static_init_done = false;
  function _tr_init(s) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    init_block(s);
  }
  function _tr_stored_block(s, buf, stored_len, last) {
    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    copy_block(s, buf, stored_len);
  }
  function _tr_align(s) {
    send_bits(s, STATIC_TREES << 1, 3);
    send_code(s, END_BLOCK, static_ltree);
    bi_flush(s);
  }
  function _tr_flush_block(s, buf, stored_len, last) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === Z_UNKNOWN) {
        s.strm.data_type = detect_data_type(s);
      }
      build_tree(s, s.l_desc);
      build_tree(s, s.d_desc);
      max_blindex = build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
      send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s, static_ltree, static_dtree);
    } else {
      send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    init_block(s);
    if (last) {
      bi_windup(s);
    }
  }
  function _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
      s.dyn_dtree[d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
  trees._tr_init = _tr_init;
  trees._tr_stored_block = _tr_stored_block;
  trees._tr_flush_block = _tr_flush_block;
  trees._tr_tally = _tr_tally;
  trees._tr_align = _tr_align;
  return trees;
}
var adler32_1;
var hasRequiredAdler32;
function requireAdler32() {
  if (hasRequiredAdler32) return adler32_1;
  hasRequiredAdler32 = 1;
  function adler32(adler, buf, len, pos) {
    var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
  adler32_1 = adler32;
  return adler32_1;
}
var crc32_1;
var hasRequiredCrc32;
function requireCrc32() {
  if (hasRequiredCrc32) return crc32_1;
  hasRequiredCrc32 = 1;
  function makeTable() {
    var c2, table = [];
    for (var n = 0; n < 256; n++) {
      c2 = n;
      for (var k = 0; k < 8; k++) {
        c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
      }
      table[n] = c2;
    }
    return table;
  }
  var crcTable2 = makeTable();
  function crc32(crc2, buf, len, pos) {
    var t = crcTable2, end = pos + len;
    crc2 ^= -1;
    for (var i = pos; i < end; i++) {
      crc2 = crc2 >>> 8 ^ t[(crc2 ^ buf[i]) & 255];
    }
    return crc2 ^ -1;
  }
  crc32_1 = crc32;
  return crc32_1;
}
var messages;
var hasRequiredMessages;
function requireMessages() {
  if (hasRequiredMessages) return messages;
  hasRequiredMessages = 1;
  messages = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  };
  return messages;
}
var hasRequiredDeflate$1;
function requireDeflate$1() {
  if (hasRequiredDeflate$1) return deflate;
  hasRequiredDeflate$1 = 1;
  var utils = requireCommon();
  var trees2 = requireTrees();
  var adler32 = requireAdler32();
  var crc32 = requireCrc32();
  var msg = requireMessages();
  var Z_NO_FLUSH = 0;
  var Z_PARTIAL_FLUSH = 1;
  var Z_FULL_FLUSH = 3;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_BUF_ERROR = -5;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_FILTERED = 1;
  var Z_HUFFMAN_ONLY = 2;
  var Z_RLE = 3;
  var Z_FIXED = 4;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_UNKNOWN = 2;
  var Z_DEFLATED = 8;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  function err(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
  }
  function rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  function flush_pending(strm) {
    var s = strm.state;
    var len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  function flush_block_only(s, last) {
    trees2._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    flush_pending(s.strm);
  }
  function put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  function putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  function read_buf(strm, buf, start, size) {
    var len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    utils.arraySet(buf, strm.input, strm.next_in, len, start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  function longest_match(s, cur_match) {
    var chain_length = s.max_chain_length;
    var scan2 = s.strstart;
    var match;
    var len;
    var best_len = s.prev_length;
    var nice_match = s.nice_match;
    var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
    var _win = s.window;
    var wmask = s.w_mask;
    var prev = s.prev;
    var strend = s.strstart + MAX_MATCH;
    var scan_end1 = _win[scan2 + best_len - 1];
    var scan_end = _win[scan2 + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan2] || _win[++match] !== _win[scan2 + 1]) {
        continue;
      }
      scan2 += 2;
      match++;
      do {
      } while (_win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && scan2 < strend);
      len = MAX_MATCH - (strend - scan2);
      scan2 = strend - MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan2 + best_len - 1];
        scan_end = _win[scan2 + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  function fill_window(s) {
    var _w_size = s.w_size;
    var p, n, m, more, str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
        while (s.insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  function deflate_stored(s, flush) {
    var max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        fill_window(s);
        if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      var max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_NEED_MORE;
  }
  function deflate_fast(s, flush) {
    var hash_head;
    var bflush;
    for (; ; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees2._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
          s.match_length--;
          do {
            s.strstart++;
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          } while (--s.match_length !== 0);
          s.strstart++;
        } else {
          s.strstart += s.match_length;
          s.match_length = 0;
          s.ins_h = s.window[s.strstart];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
        }
      } else {
        bflush = trees2._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_slow(s, flush) {
    var hash_head;
    var bflush;
    var max_insert;
    for (; ; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - MIN_MATCH;
        bflush = trees2._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = trees2._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = trees2._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_rle(s, flush) {
    var bflush;
    var prev;
    var scan2, strend;
    var _win = s.window;
    for (; ; ) {
      if (s.lookahead <= MAX_MATCH) {
        fill_window(s);
        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
        scan2 = s.strstart - 1;
        prev = _win[scan2];
        if (prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2]) {
          strend = s.strstart + MAX_MATCH;
          do {
          } while (prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && scan2 < strend);
          s.match_length = MAX_MATCH - (strend - scan2);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees2._tr_tally(s, 1, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = trees2._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_huff(s, flush) {
    var bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        fill_window(s);
        if (s.lookahead === 0) {
          if (flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = trees2._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  var configuration_table;
  configuration_table = [
    /*      good lazy nice chain */
    new Config(0, 0, 0, 0, deflate_stored),
    /* 0 store only */
    new Config(4, 4, 8, 4, deflate_fast),
    /* 1 max speed, no lazy matches */
    new Config(4, 5, 16, 8, deflate_fast),
    /* 2 */
    new Config(4, 6, 32, 32, deflate_fast),
    /* 3 */
    new Config(4, 4, 16, 16, deflate_slow),
    /* 4 lazy matches */
    new Config(8, 16, 32, 32, deflate_slow),
    /* 5 */
    new Config(8, 16, 128, 128, deflate_slow),
    /* 6 */
    new Config(8, 32, 128, 256, deflate_slow),
    /* 7 */
    new Config(32, 128, 258, 1024, deflate_slow),
    /* 8 */
    new Config(32, 258, 258, 4096, deflate_slow)
    /* 9 max compression */
  ];
  function lm_init(s) {
    s.window_size = 2 * s.w_size;
    zero(s.head);
    s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils.Buf16(MAX_BITS + 1);
    this.heap = new utils.Buf16(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils.Buf16(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  function deflateResetKeep(strm) {
    var s;
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = Z_NO_FLUSH;
    trees2._tr_init(s);
    return Z_OK;
  }
  function deflateReset(strm) {
    var ret = deflateResetKeep(strm);
    if (ret === Z_OK) {
      lm_init(strm.state);
    }
    return ret;
  }
  function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return Z_OK;
  }
  function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    var wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
      return err(strm, Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    var s = new DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s.window = new utils.Buf8(s.w_size * 2);
    s.head = new utils.Buf16(s.hash_size);
    s.prev = new utils.Buf16(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new utils.Buf8(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return deflateReset(strm);
  }
  function deflateInit(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
  }
  function deflate$12(strm, flush) {
    var old_flush, s;
    var beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
    }
    s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
    }
    s.strm = strm;
    old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
        } else {
          put_byte(
            s,
            (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
          );
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      } else {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = BUSY_STATE;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
        s.status = NAME_STATE;
      }
    }
    if (s.status === NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
        s.status = COMMENT_STATE;
      }
    }
    if (s.status === COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
        s.status = HCRC_STATE;
      }
    }
    if (s.status === HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = BUSY_STATE;
        }
      } else {
        s.status = BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
      return err(strm, Z_BUF_ERROR);
    }
    if (s.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
      var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return Z_OK;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          trees2._tr_align(s);
        } else if (flush !== Z_BLOCK) {
          trees2._tr_stored_block(s, 0, 0, false);
          if (flush === Z_FULL_FLUSH) {
            zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
    }
    if (flush !== Z_FINISH) {
      return Z_OK;
    }
    if (s.wrap <= 0) {
      return Z_STREAM_END;
    }
    if (s.wrap === 2) {
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      put_byte(s, strm.adler >> 16 & 255);
      put_byte(s, strm.adler >> 24 & 255);
      put_byte(s, strm.total_in & 255);
      put_byte(s, strm.total_in >> 8 & 255);
      put_byte(s, strm.total_in >> 16 & 255);
      put_byte(s, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? Z_OK : Z_STREAM_END;
  }
  function deflateEnd(strm) {
    var status;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
  }
  function deflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var s;
    var str, n;
    var wrap;
    var avail;
    var next;
    var input;
    var tmpDict;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    s = strm.state;
    wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
      return Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      tmpDict = new utils.Buf8(s.w_size);
      utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    avail = strm.avail_in;
    next = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);
    while (s.lookahead >= MIN_MATCH) {
      str = s.strstart;
      n = s.lookahead - (MIN_MATCH - 1);
      do {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = MIN_MATCH - 1;
      fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return Z_OK;
  }
  deflate.deflateInit = deflateInit;
  deflate.deflateInit2 = deflateInit2;
  deflate.deflateReset = deflateReset;
  deflate.deflateResetKeep = deflateResetKeep;
  deflate.deflateSetHeader = deflateSetHeader;
  deflate.deflate = deflate$12;
  deflate.deflateEnd = deflateEnd;
  deflate.deflateSetDictionary = deflateSetDictionary;
  deflate.deflateInfo = "pako deflate (from Nodeca project)";
  return deflate;
}
var strings = {};
var hasRequiredStrings;
function requireStrings() {
  if (hasRequiredStrings) return strings;
  hasRequiredStrings = 1;
  var utils = requireCommon();
  var STR_APPLY_OK = true;
  var STR_APPLY_UIA_OK = true;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch (__) {
    STR_APPLY_OK = false;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (__) {
    STR_APPLY_UIA_OK = false;
  }
  var _utf8len = new utils.Buf8(256);
  for (var q = 0; q < 256; q++) {
    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
  }
  _utf8len[254] = _utf8len[254] = 1;
  strings.string2buf = function(str) {
    var buf, c2, c22, m_pos, i, str_len = str.length, buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c2 = str.charCodeAt(m_pos);
      if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
    }
    buf = new utils.Buf8(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c2 = str.charCodeAt(m_pos);
      if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      if (c2 < 128) {
        buf[i++] = c2;
      } else if (c2 < 2048) {
        buf[i++] = 192 | c2 >>> 6;
        buf[i++] = 128 | c2 & 63;
      } else if (c2 < 65536) {
        buf[i++] = 224 | c2 >>> 12;
        buf[i++] = 128 | c2 >>> 6 & 63;
        buf[i++] = 128 | c2 & 63;
      } else {
        buf[i++] = 240 | c2 >>> 18;
        buf[i++] = 128 | c2 >>> 12 & 63;
        buf[i++] = 128 | c2 >>> 6 & 63;
        buf[i++] = 128 | c2 & 63;
      }
    }
    return buf;
  };
  function buf2binstring(buf, len) {
    if (len < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
        return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
      }
    }
    var result = "";
    for (var i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  strings.buf2binstring = function(buf) {
    return buf2binstring(buf, buf.length);
  };
  strings.binstring2buf = function(str) {
    var buf = new utils.Buf8(str.length);
    for (var i = 0, len = buf.length; i < len; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  };
  strings.buf2string = function(buf, max) {
    var i, out, c2, c_len;
    var len = max || buf.length;
    var utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      c2 = buf[i++];
      if (c2 < 128) {
        utf16buf[out++] = c2;
        continue;
      }
      c_len = _utf8len[c2];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c2 = c2 << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c2 < 65536) {
        utf16buf[out++] = c2;
      } else {
        c2 -= 65536;
        utf16buf[out++] = 55296 | c2 >> 10 & 1023;
        utf16buf[out++] = 56320 | c2 & 1023;
      }
    }
    return buf2binstring(utf16buf, out);
  };
  strings.utf8border = function(buf, max) {
    var pos;
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + _utf8len[buf[pos]] > max ? pos : max;
  };
  return strings;
}
var zstream;
var hasRequiredZstream;
function requireZstream() {
  if (hasRequiredZstream) return zstream;
  hasRequiredZstream = 1;
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  zstream = ZStream;
  return zstream;
}
var hasRequiredDeflate;
function requireDeflate() {
  if (hasRequiredDeflate) return deflate$1;
  hasRequiredDeflate = 1;
  var zlib_deflate = requireDeflate$1();
  var utils = requireCommon();
  var strings2 = requireStrings();
  var msg = requireMessages();
  var ZStream = requireZstream();
  var toString2 = Object.prototype.toString;
  var Z_NO_FLUSH = 0;
  var Z_FINISH = 4;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_SYNC_FLUSH = 2;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_DEFLATED = 8;
  function Deflate(options) {
    if (!(this instanceof Deflate)) return new Deflate(options);
    this.options = utils.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream();
    this.strm.avail_out = 0;
    var status = zlib_deflate.deflateInit2(
      this.strm,
      opt.level,
      opt.method,
      opt.windowBits,
      opt.memLevel,
      opt.strategy
    );
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      var dict;
      if (typeof opt.dictionary === "string") {
        dict = strings2.string2buf(opt.dictionary);
      } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this._dict_set = true;
    }
  }
  Deflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var status, _mode;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (typeof data === "string") {
      strm.input = strings2.string2buf(data);
    } else if (toString2.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_deflate.deflate(strm, _mode);
      if (status !== Z_STREAM_END && status !== Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          this.onData(strings2.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
    if (_mode === Z_FINISH) {
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }
    if (_mode === Z_SYNC_FLUSH) {
      this.onEnd(Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Deflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Deflate.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function deflate2(input, options) {
    var deflator = new Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || msg[deflator.err];
    }
    return deflator.result;
  }
  function deflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return deflate2(input, options);
  }
  function gzip(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate2(input, options);
  }
  deflate$1.Deflate = Deflate;
  deflate$1.deflate = deflate2;
  deflate$1.deflateRaw = deflateRaw;
  deflate$1.gzip = gzip;
  return deflate$1;
}
var inflate$1 = {};
var inflate = {};
var inffast;
var hasRequiredInffast;
function requireInffast() {
  if (hasRequiredInffast) return inffast;
  hasRequiredInffast = 1;
  var BAD = 30;
  var TYPE = 12;
  inffast = function inflate_fast(strm, start) {
    var state;
    var _in;
    var last;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist;
    var from;
    var from_source;
    var input, output;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    if (dist > dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
  return inffast;
}
var inftrees;
var hasRequiredInftrees;
function requireInftrees() {
  if (hasRequiredInftrees) return inftrees;
  hasRequiredInftrees = 1;
  var utils = requireCommon();
  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = [
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  var lext = [
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ];
  var dbase = [
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ];
  var dext = [
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  inftrees = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    var bits = opts.bits;
    var len = 0;
    var sym = 0;
    var min = 0, max = 0;
    var root = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill;
    var low;
    var mask;
    var next;
    var base = null;
    var base_index = 0;
    var end;
    var count = new utils.Buf16(MAXBITS + 1);
    var offs = new utils.Buf16(MAXBITS + 1);
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    for (len = 0; len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === CODES) {
      base = extra = work;
      end = 19;
    } else if (type === LENS) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = dbase;
      extra = dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  };
  return inftrees;
}
var hasRequiredInflate$1;
function requireInflate$1() {
  if (hasRequiredInflate$1) return inflate;
  hasRequiredInflate$1 = 1;
  var utils = requireCommon();
  var adler32 = requireAdler32();
  var crc32 = requireCrc32();
  var inflate_fast = requireInffast();
  var inflate_table = requireInftrees();
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_TREES = 6;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_NEED_DICT = 2;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_MEM_ERROR = -4;
  var Z_BUF_ERROR = -5;
  var Z_DEFLATED = 8;
  var HEAD = 1;
  var FLAGS = 2;
  var TIME = 3;
  var OS = 4;
  var EXLEN = 5;
  var EXTRA = 6;
  var NAME = 7;
  var COMMENT = 8;
  var HCRC = 9;
  var DICTID = 10;
  var DICT = 11;
  var TYPE = 12;
  var TYPEDO = 13;
  var STORED = 14;
  var COPY_ = 15;
  var COPY = 16;
  var TABLE = 17;
  var LENLENS = 18;
  var CODELENS = 19;
  var LEN_ = 20;
  var LEN = 21;
  var LENEXT = 22;
  var DIST = 23;
  var DISTEXT = 24;
  var MATCH = 25;
  var LIT = 26;
  var CHECK = 27;
  var LENGTH = 28;
  var DONE = 29;
  var BAD = 30;
  var MEM = 31;
  var SYNC = 32;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  function zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils.Buf16(320);
    this.work = new utils.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  function inflateResetKeep(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
    state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK;
  }
  function inflateReset(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  }
  function inflateReset2(strm, windowBits) {
    var wrap;
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  }
  function inflateInit2(strm, windowBits) {
    var ret;
    var state;
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    state = new InflateState();
    strm.state = state;
    state.window = null;
    ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  function inflateInit(strm) {
    return inflateInit2(strm, DEF_WBITS);
  }
  var virgin = true;
  var lenfix, distfix;
  function fixedtables(state) {
    if (virgin) {
      var sym;
      lenfix = new utils.Buf32(512);
      distfix = new utils.Buf32(32);
      sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  }
  function updatewindow(strm, src2, end, copy) {
    var dist;
    var state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new utils.Buf8(state.wsize);
    }
    if (copy >= state.wsize) {
      utils.arraySet(state.window, src2, end - state.wsize, state.wsize, 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      utils.arraySet(state.window, src2, end - copy, dist, state.wnext);
      copy -= dist;
      if (copy) {
        utils.arraySet(state.window, src2, end - copy, copy, 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  function inflate$12(strm, flush) {
    var state;
    var input, output;
    var next;
    var put;
    var have, left;
    var hold;
    var bits;
    var _in, _out;
    var copy;
    var from;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len;
    var ret;
    var hbuf = new utils.Buf8(4);
    var opts;
    var n;
    var order = (
      /* permutation of code lengths */
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    );
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === TYPE) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || /* check if zlib header allowed */
            (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(
                    state.head.extra,
                    input,
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    copy,
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                }
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  }
  function inflateEnd(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    var state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK;
  }
  function inflateGetHeader(strm, head) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return Z_OK;
  }
  function inflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var state;
    var dictid;
    var ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
    state.havedict = 1;
    return Z_OK;
  }
  inflate.inflateReset = inflateReset;
  inflate.inflateReset2 = inflateReset2;
  inflate.inflateResetKeep = inflateResetKeep;
  inflate.inflateInit = inflateInit;
  inflate.inflateInit2 = inflateInit2;
  inflate.inflate = inflate$12;
  inflate.inflateEnd = inflateEnd;
  inflate.inflateGetHeader = inflateGetHeader;
  inflate.inflateSetDictionary = inflateSetDictionary;
  inflate.inflateInfo = "pako inflate (from Nodeca project)";
  return inflate;
}
var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  constants = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };
  return constants;
}
var gzheader;
var hasRequiredGzheader;
function requireGzheader() {
  if (hasRequiredGzheader) return gzheader;
  hasRequiredGzheader = 1;
  function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
  gzheader = GZheader;
  return gzheader;
}
var hasRequiredInflate;
function requireInflate() {
  if (hasRequiredInflate) return inflate$1;
  hasRequiredInflate = 1;
  var zlib_inflate = requireInflate$1();
  var utils = requireCommon();
  var strings2 = requireStrings();
  var c2 = requireConstants();
  var msg = requireMessages();
  var ZStream = requireZstream();
  var GZheader = requireGzheader();
  var toString2 = Object.prototype.toString;
  function Inflate(options) {
    if (!(this instanceof Inflate)) return new Inflate(options);
    this.options = utils.assign({
      chunkSize: 16384,
      windowBits: 0,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream();
    this.strm.avail_out = 0;
    var status = zlib_inflate.inflateInit2(
      this.strm,
      opt.windowBits
    );
    if (status !== c2.Z_OK) {
      throw new Error(msg[status]);
    }
    this.header = new GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = strings2.string2buf(opt.dictionary);
      } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== c2.Z_OK) {
          throw new Error(msg[status]);
        }
      }
    }
  }
  Inflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var dictionary = this.options.dictionary;
    var status, _mode;
    var next_out_utf8, tail, utf8str;
    var allowBufError = false;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? c2.Z_FINISH : c2.Z_NO_FLUSH;
    if (typeof data === "string") {
      strm.input = strings2.binstring2buf(data);
    } else if (toString2.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, c2.Z_NO_FLUSH);
      if (status === c2.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
      }
      if (status === c2.Z_BUF_ERROR && allowBufError === true) {
        status = c2.Z_OK;
        allowBufError = false;
      }
      if (status !== c2.Z_STREAM_END && status !== c2.Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === c2.Z_STREAM_END || strm.avail_in === 0 && (_mode === c2.Z_FINISH || _mode === c2.Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            next_out_utf8 = strings2.utf8border(strm.output, strm.next_out);
            tail = strm.next_out - next_out_utf8;
            utf8str = strings2.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) {
              utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
            }
            this.onData(utf8str);
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      }
      if (strm.avail_in === 0 && strm.avail_out === 0) {
        allowBufError = true;
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c2.Z_STREAM_END);
    if (status === c2.Z_STREAM_END) {
      _mode = c2.Z_FINISH;
    }
    if (_mode === c2.Z_FINISH) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === c2.Z_OK;
    }
    if (_mode === c2.Z_SYNC_FLUSH) {
      this.onEnd(c2.Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Inflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Inflate.prototype.onEnd = function(status) {
    if (status === c2.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function inflate2(input, options) {
    var inflator = new Inflate(options);
    inflator.push(input, true);
    if (inflator.err) {
      throw inflator.msg || msg[inflator.err];
    }
    return inflator.result;
  }
  function inflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return inflate2(input, options);
  }
  inflate$1.Inflate = Inflate;
  inflate$1.inflate = inflate2;
  inflate$1.inflateRaw = inflateRaw;
  inflate$1.ungzip = inflate2;
  return inflate$1;
}
var pako_1;
var hasRequiredPako;
function requirePako() {
  if (hasRequiredPako) return pako_1;
  hasRequiredPako = 1;
  var assign = requireCommon().assign;
  var deflate2 = requireDeflate();
  var inflate2 = requireInflate();
  var constants2 = requireConstants();
  var pako = {};
  assign(pako, deflate2, inflate2, constants2);
  pako_1 = pako;
  return pako_1;
}
(function(module) {
  (function() {
    var UTIF2 = {};
    {
      module.exports = UTIF2;
    }
    var pako = typeof commonjsRequire === "function" ? requirePako() : self.pako;
    function log() {
      if (typeof process == "undefined" || process.env.NODE_ENV == "development") console.log.apply(console, arguments);
    }
    (function(UTIF22, pako2) {
      (function() {
        var W = function a1() {
          function W2(p) {
            this.message = "JPEG error: " + p;
          }
          W2.prototype = new Error();
          W2.prototype.name = "JpegError";
          W2.constructor = W2;
          return W2;
        }(), ak = function ag() {
          var p = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), t = 4017, ac = 799, ah = 3406, ao = 2276, ar = 1567, ai = 3784, s = 5793, ad = 2896;
          function ak2(Q) {
            if (Q == null) Q = {};
            if (Q.w == null) Q.w = -1;
            this.V = Q.n;
            this.N = Q.w;
          }
          function a5(Q, h) {
            var f = 0, G = [], n, E, a = 16, F;
            while (a > 0 && !Q[a - 1]) {
              a--;
            }
            G.push({ children: [], index: 0 });
            var C = G[0];
            for (n = 0; n < a; n++) {
              for (E = 0; E < Q[n]; E++) {
                C = G.pop();
                C.children[C.index] = h[f];
                while (C.index > 0) {
                  C = G.pop();
                }
                C.index++;
                G.push(C);
                while (G.length <= n) {
                  G.push(F = { children: [], index: 0 });
                  C.children[C.index] = F.children;
                  C = F;
                }
                f++;
              }
              if (n + 1 < a) {
                G.push(F = { children: [], index: 0 });
                C.children[C.index] = F.children;
                C = F;
              }
            }
            return G[0].children;
          }
          function a2(Q, h, f) {
            return 64 * ((Q.P + 1) * h + f);
          }
          function a7(Q, h, f, G, n, E, a, C, F, d) {
            if (d == null) d = false;
            var T = f.m, U = f.Z, z2 = h, J = 0, V = 0, r = 0, D = 0, a8, q = 0, X, O, _, N, e, K, x2 = 0, k, g, R, c2;
            function Y2() {
              if (V > 0) {
                V--;
                return J >> V & 1;
              }
              J = Q[h++];
              if (J === 255) {
                var I = Q[h++];
                if (I) {
                  if (I === 220 && d) {
                    h += 2;
                    var l = Z(Q, h);
                    h += 2;
                    if (l > 0 && l !== f.s) {
                      throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", l);
                    }
                  } else if (I === 217) {
                    if (d) {
                      var M = q * 8;
                      if (M > 0 && M < f.s / 10) {
                        throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", M);
                      }
                    }
                    throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
                  }
                  throw new W("unexpected marker");
                }
              }
              V = 7;
              return J >>> 7;
            }
            function u(I) {
              var l = I;
              while (true) {
                l = l[Y2()];
                switch (typeof l) {
                  case "number":
                    return l;
                  case "object":
                    continue;
                }
                throw new W("invalid huffman sequence");
              }
            }
            function m(I) {
              var e2 = 0;
              while (I > 0) {
                e2 = e2 << 1 | Y2();
                I--;
              }
              return e2;
            }
            function j(I) {
              if (I === 1) {
                return Y2() === 1 ? 1 : -1;
              }
              var e2 = m(I);
              if (e2 >= 1 << I - 1) {
                return e2;
              }
              return e2 + (-1 << I) + 1;
            }
            function v(X2, I) {
              var l = u(X2.J), M = l === 0 ? 0 : j(l), N2 = 1;
              X2.D[I] = X2.Q += M;
              while (N2 < 64) {
                var S = u(X2.i), i = S & 15, A = S >> 4;
                if (i === 0) {
                  if (A < 15) {
                    break;
                  }
                  N2 += 16;
                  continue;
                }
                N2 += A;
                var o = p[N2];
                X2.D[I + o] = j(i);
                N2++;
              }
            }
            function $(X2, I) {
              var l = u(X2.J), M = l === 0 ? 0 : j(l) << F;
              X2.D[I] = X2.Q += M;
            }
            function b(X2, I) {
              X2.D[I] |= Y2() << F;
            }
            function P(X2, I) {
              if (r > 0) {
                r--;
                return;
              }
              var N2 = E, l = a;
              while (N2 <= l) {
                var M = u(X2.i), S = M & 15, i = M >> 4;
                if (S === 0) {
                  if (i < 15) {
                    r = m(i) + (1 << i) - 1;
                    break;
                  }
                  N2 += 16;
                  continue;
                }
                N2 += i;
                var A = p[N2];
                X2.D[I + A] = j(S) * (1 << F);
                N2++;
              }
            }
            function a4(X2, I) {
              var N2 = E, l = a, M = 0, S, i;
              while (N2 <= l) {
                var A = I + p[N2], o = X2.D[A] < 0 ? -1 : 1;
                switch (D) {
                  case 0:
                    i = u(X2.i);
                    S = i & 15;
                    M = i >> 4;
                    if (S === 0) {
                      if (M < 15) {
                        r = m(M) + (1 << M);
                        D = 4;
                      } else {
                        M = 16;
                        D = 1;
                      }
                    } else {
                      if (S !== 1) {
                        throw new W("invalid ACn encoding");
                      }
                      a8 = j(S);
                      D = M ? 2 : 3;
                    }
                    continue;
                  case 1:
                  case 2:
                    if (X2.D[A]) {
                      X2.D[A] += o * (Y2() << F);
                    } else {
                      M--;
                      if (M === 0) {
                        D = D === 2 ? 3 : 0;
                      }
                    }
                    break;
                  case 3:
                    if (X2.D[A]) {
                      X2.D[A] += o * (Y2() << F);
                    } else {
                      X2.D[A] = a8 << F;
                      D = 0;
                    }
                    break;
                  case 4:
                    if (X2.D[A]) {
                      X2.D[A] += o * (Y2() << F);
                    }
                    break;
                }
                N2++;
              }
              if (D === 4) {
                r--;
                if (r === 0) {
                  D = 0;
                }
              }
            }
            function H(X2, I, x22, l, M) {
              var S = x22 / T | 0, i = x22 % T;
              q = S * X2.A + l;
              var A = i * X2.h + M, o = a2(X2, q, A);
              I(X2, o);
            }
            function w(X2, I, x22) {
              q = x22 / X2.P | 0;
              var l = x22 % X2.P, M = a2(X2, q, l);
              I(X2, M);
            }
            var y2 = G.length;
            if (U) {
              if (E === 0) {
                K = C === 0 ? $ : b;
              } else {
                K = C === 0 ? P : a4;
              }
            } else {
              K = v;
            }
            if (y2 === 1) {
              g = G[0].P * G[0].c;
            } else {
              g = T * f.R;
            }
            while (x2 <= g) {
              var L = n ? Math.min(g - x2, n) : g;
              if (L > 0) {
                for (O = 0; O < y2; O++) {
                  G[O].Q = 0;
                }
                r = 0;
                if (y2 === 1) {
                  X = G[0];
                  for (e = 0; e < L; e++) {
                    w(X, K, x2);
                    x2++;
                  }
                } else {
                  for (e = 0; e < L; e++) {
                    for (O = 0; O < y2; O++) {
                      X = G[O];
                      R = X.h;
                      c2 = X.A;
                      for (_ = 0; _ < c2; _++) {
                        for (N = 0; N < R; N++) {
                          H(X, K, x2, _, N);
                        }
                      }
                    }
                    x2++;
                  }
                }
              }
              V = 0;
              k = an(Q, h);
              if (!k) {
                break;
              }
              if (k.u) {
                h = k.offset;
              }
              if (k.M >= 65488 && k.M <= 65495) {
                h += 2;
              } else {
                break;
              }
            }
            return h - z2;
          }
          function al(Q, h, f) {
            var G = Q.$, n = Q.D, E, a, C, F, d, T, U, z2, J, V, Y2, u, m, j, v, $, b;
            if (!G) {
              throw new W("missing required Quantization Table.");
            }
            for (var r = 0; r < 64; r += 8) {
              J = n[h + r];
              V = n[h + r + 1];
              Y2 = n[h + r + 2];
              u = n[h + r + 3];
              m = n[h + r + 4];
              j = n[h + r + 5];
              v = n[h + r + 6];
              $ = n[h + r + 7];
              J *= G[r];
              if ((V | Y2 | u | m | j | v | $) === 0) {
                b = s * J + 512 >> 10;
                f[r] = b;
                f[r + 1] = b;
                f[r + 2] = b;
                f[r + 3] = b;
                f[r + 4] = b;
                f[r + 5] = b;
                f[r + 6] = b;
                f[r + 7] = b;
                continue;
              }
              V *= G[r + 1];
              Y2 *= G[r + 2];
              u *= G[r + 3];
              m *= G[r + 4];
              j *= G[r + 5];
              v *= G[r + 6];
              $ *= G[r + 7];
              E = s * J + 128 >> 8;
              a = s * m + 128 >> 8;
              C = Y2;
              F = v;
              d = ad * (V - $) + 128 >> 8;
              z2 = ad * (V + $) + 128 >> 8;
              T = u << 4;
              U = j << 4;
              E = E + a + 1 >> 1;
              a = E - a;
              b = C * ai + F * ar + 128 >> 8;
              C = C * ar - F * ai + 128 >> 8;
              F = b;
              d = d + U + 1 >> 1;
              U = d - U;
              z2 = z2 + T + 1 >> 1;
              T = z2 - T;
              E = E + F + 1 >> 1;
              F = E - F;
              a = a + C + 1 >> 1;
              C = a - C;
              b = d * ao + z2 * ah + 2048 >> 12;
              d = d * ah - z2 * ao + 2048 >> 12;
              z2 = b;
              b = T * ac + U * t + 2048 >> 12;
              T = T * t - U * ac + 2048 >> 12;
              U = b;
              f[r] = E + z2;
              f[r + 7] = E - z2;
              f[r + 1] = a + U;
              f[r + 6] = a - U;
              f[r + 2] = C + T;
              f[r + 5] = C - T;
              f[r + 3] = F + d;
              f[r + 4] = F - d;
            }
            for (var P = 0; P < 8; ++P) {
              J = f[P];
              V = f[P + 8];
              Y2 = f[P + 16];
              u = f[P + 24];
              m = f[P + 32];
              j = f[P + 40];
              v = f[P + 48];
              $ = f[P + 56];
              if ((V | Y2 | u | m | j | v | $) === 0) {
                b = s * J + 8192 >> 14;
                if (b < -2040) {
                  b = 0;
                } else if (b >= 2024) {
                  b = 255;
                } else {
                  b = b + 2056 >> 4;
                }
                n[h + P] = b;
                n[h + P + 8] = b;
                n[h + P + 16] = b;
                n[h + P + 24] = b;
                n[h + P + 32] = b;
                n[h + P + 40] = b;
                n[h + P + 48] = b;
                n[h + P + 56] = b;
                continue;
              }
              E = s * J + 2048 >> 12;
              a = s * m + 2048 >> 12;
              C = Y2;
              F = v;
              d = ad * (V - $) + 2048 >> 12;
              z2 = ad * (V + $) + 2048 >> 12;
              T = u;
              U = j;
              E = (E + a + 1 >> 1) + 4112;
              a = E - a;
              b = C * ai + F * ar + 2048 >> 12;
              C = C * ar - F * ai + 2048 >> 12;
              F = b;
              d = d + U + 1 >> 1;
              U = d - U;
              z2 = z2 + T + 1 >> 1;
              T = z2 - T;
              E = E + F + 1 >> 1;
              F = E - F;
              a = a + C + 1 >> 1;
              C = a - C;
              b = d * ao + z2 * ah + 2048 >> 12;
              d = d * ah - z2 * ao + 2048 >> 12;
              z2 = b;
              b = T * ac + U * t + 2048 >> 12;
              T = T * t - U * ac + 2048 >> 12;
              U = b;
              J = E + z2;
              $ = E - z2;
              V = a + U;
              v = a - U;
              Y2 = C + T;
              j = C - T;
              u = F + d;
              m = F - d;
              if (J < 16) {
                J = 0;
              } else if (J >= 4080) {
                J = 255;
              } else {
                J >>= 4;
              }
              if (V < 16) {
                V = 0;
              } else if (V >= 4080) {
                V = 255;
              } else {
                V >>= 4;
              }
              if (Y2 < 16) {
                Y2 = 0;
              } else if (Y2 >= 4080) {
                Y2 = 255;
              } else {
                Y2 >>= 4;
              }
              if (u < 16) {
                u = 0;
              } else if (u >= 4080) {
                u = 255;
              } else {
                u >>= 4;
              }
              if (m < 16) {
                m = 0;
              } else if (m >= 4080) {
                m = 255;
              } else {
                m >>= 4;
              }
              if (j < 16) {
                j = 0;
              } else if (j >= 4080) {
                j = 255;
              } else {
                j >>= 4;
              }
              if (v < 16) {
                v = 0;
              } else if (v >= 4080) {
                v = 255;
              } else {
                v >>= 4;
              }
              if ($ < 16) {
                $ = 0;
              } else if ($ >= 4080) {
                $ = 255;
              } else {
                $ >>= 4;
              }
              n[h + P] = J;
              n[h + P + 8] = V;
              n[h + P + 16] = Y2;
              n[h + P + 24] = u;
              n[h + P + 32] = m;
              n[h + P + 40] = j;
              n[h + P + 48] = v;
              n[h + P + 56] = $;
            }
          }
          function a0(Q, h) {
            var f = h.P, G = h.c, n = new Int16Array(64);
            for (var E = 0; E < G; E++) {
              for (var a = 0; a < f; a++) {
                var C = a2(h, E, a);
                al(h, C, n);
              }
            }
            return h.D;
          }
          function an(Q, h, f) {
            if (f == null) f = h;
            var G = Q.length - 1, n = f < h ? f : h;
            if (h >= G) {
              return null;
            }
            var E = Z(Q, h);
            if (E >= 65472 && E <= 65534) {
              return { u: null, M: E, offset: h };
            }
            var a = Z(Q, n);
            while (!(a >= 65472 && a <= 65534)) {
              if (++n >= G) {
                return null;
              }
              a = Z(Q, n);
            }
            return { u: E.toString(16), M: a, offset: n };
          }
          ak2.prototype = { parse(Q, h) {
            if (h == null) h = {};
            var f = h.F, E = 0, a = null, C = null, F, d, T = 0;
            function G() {
              var o = Z(Q, E);
              E += 2;
              var B = E + o - 2, V2 = an(Q, B, E);
              if (V2 && V2.u) {
                B = V2.offset;
              }
              var ab = Q.subarray(E, B);
              E += ab.length;
              return ab;
            }
            function n(F2) {
              var o = Math.ceil(F2.o / 8 / F2.X), B = Math.ceil(F2.s / 8 / F2.B);
              for (var Y22 = 0; Y22 < F2.W.length; Y22++) {
                R = F2.W[Y22];
                var ab = Math.ceil(Math.ceil(F2.o / 8) * R.h / F2.X), af = Math.ceil(Math.ceil(F2.s / 8) * R.A / F2.B), ap = o * R.h, aq = B * R.A, ae = 64 * aq * (ap + 1);
                R.D = new Int16Array(ae);
                R.P = ab;
                R.c = af;
              }
              F2.m = o;
              F2.R = B;
            }
            var U = [], z2 = [], J = [], V = Z(Q, E);
            E += 2;
            if (V !== 65496) {
              throw new W("SOI not found");
            }
            V = Z(Q, E);
            E += 2;
            markerLoop: while (V !== 65497) {
              var Y2, u, m;
              switch (V) {
                case 65504:
                case 65505:
                case 65506:
                case 65507:
                case 65508:
                case 65509:
                case 65510:
                case 65511:
                case 65512:
                case 65513:
                case 65514:
                case 65515:
                case 65516:
                case 65517:
                case 65518:
                case 65519:
                case 65534:
                  var j = G();
                  if (V === 65504) {
                    if (j[0] === 74 && j[1] === 70 && j[2] === 73 && j[3] === 70 && j[4] === 0) {
                      a = { version: { d: j[5], T: j[6] }, K: j[7], j: j[8] << 8 | j[9], H: j[10] << 8 | j[11], S: j[12], I: j[13], C: j.subarray(14, 14 + 3 * j[12] * j[13]) };
                    }
                  }
                  if (V === 65518) {
                    if (j[0] === 65 && j[1] === 100 && j[2] === 111 && j[3] === 98 && j[4] === 101) {
                      C = { version: j[5] << 8 | j[6], k: j[7] << 8 | j[8], q: j[9] << 8 | j[10], a: j[11] };
                    }
                  }
                  break;
                case 65499:
                  var v = Z(Q, E), b;
                  E += 2;
                  var $ = v + E - 2;
                  while (E < $) {
                    var r = Q[E++], P = new Uint16Array(64);
                    if (r >> 4 === 0) {
                      for (u = 0; u < 64; u++) {
                        b = p[u];
                        P[b] = Q[E++];
                      }
                    } else if (r >> 4 === 1) {
                      for (u = 0; u < 64; u++) {
                        b = p[u];
                        P[b] = Z(Q, E);
                        E += 2;
                      }
                    } else {
                      throw new W("DQT - invalid table spec");
                    }
                    U[r & 15] = P;
                  }
                  break;
                case 65472:
                case 65473:
                case 65474:
                  if (F) {
                    throw new W("Only single frame JPEGs supported");
                  }
                  E += 2;
                  F = {};
                  F.G = V === 65473;
                  F.Z = V === 65474;
                  F.precision = Q[E++];
                  var D = Z(Q, E), a4, q = 0, H = 0;
                  E += 2;
                  F.s = f || D;
                  F.o = Z(Q, E);
                  E += 2;
                  F.W = [];
                  F._ = {};
                  var a8 = Q[E++];
                  for (Y2 = 0; Y2 < a8; Y2++) {
                    a4 = Q[E];
                    var w = Q[E + 1] >> 4, y2 = Q[E + 1] & 15;
                    if (q < w) {
                      q = w;
                    }
                    if (H < y2) {
                      H = y2;
                    }
                    var X = Q[E + 2];
                    m = F.W.push({ h: w, A: y2, L: X, $: null });
                    F._[a4] = m - 1;
                    E += 3;
                  }
                  F.X = q;
                  F.B = H;
                  n(F);
                  break;
                case 65476:
                  var O = Z(Q, E);
                  E += 2;
                  for (Y2 = 2; Y2 < O; ) {
                    var _ = Q[E++], N = new Uint8Array(16), e = 0;
                    for (u = 0; u < 16; u++, E++) {
                      e += N[u] = Q[E];
                    }
                    var K = new Uint8Array(e);
                    for (u = 0; u < e; u++, E++) {
                      K[u] = Q[E];
                    }
                    Y2 += 17 + e;
                    (_ >> 4 === 0 ? J : z2)[_ & 15] = a5(N, K);
                  }
                  break;
                case 65501:
                  E += 2;
                  d = Z(Q, E);
                  E += 2;
                  break;
                case 65498:
                  var x2 = ++T === 1 && !f, R;
                  E += 2;
                  var k = Q[E++], g = [];
                  for (Y2 = 0; Y2 < k; Y2++) {
                    var c2 = Q[E++], L = F._[c2];
                    R = F.W[L];
                    R.index = c2;
                    var a6 = Q[E++];
                    R.J = J[a6 >> 4];
                    R.i = z2[a6 & 15];
                    g.push(R);
                  }
                  var I = Q[E++], l = Q[E++], M = Q[E++];
                  try {
                    var S = a7(Q, E, F, g, d, I, l, M >> 4, M & 15, x2);
                    E += S;
                  } catch (ex) {
                    if (ex instanceof DNLMarkerError) {
                      return this.parse(Q, { F: ex.s });
                    } else if (ex instanceof EOIMarkerError) {
                      break markerLoop;
                    }
                    throw ex;
                  }
                  break;
                case 65500:
                  E += 4;
                  break;
                case 65535:
                  if (Q[E] !== 255) {
                    E--;
                  }
                  break;
                default:
                  var i = an(Q, E - 2, E - 3);
                  if (i && i.u) {
                    E = i.offset;
                    break;
                  }
                  if (E >= Q.length - 1) {
                    break markerLoop;
                  }
                  throw new W("JpegImage.parse - unknown marker: " + V.toString(16));
              }
              V = Z(Q, E);
              E += 2;
            }
            this.width = F.o;
            this.height = F.s;
            this.g = a;
            this.b = C;
            this.W = [];
            for (Y2 = 0; Y2 < F.W.length; Y2++) {
              R = F.W[Y2];
              var A = U[R.L];
              if (A) {
                R.$ = A;
              }
              this.W.push({ index: R.index, e: a0(F, R), l: R.h / F.X, t: R.A / F.B, P: R.P, c: R.c });
            }
            this.p = this.W.length;
            return void 0;
          }, Y(Q, h, f) {
            if (f == null) f = false;
            var G = this.width / Q, n = this.height / h, E, a, C, F, d, T, U, z2, J, V, Y2 = 0, u, m = this.W.length, j = Q * h * m, v = new Uint8ClampedArray(j), $ = new Uint32Array(Q), b = 4294967288, r;
            for (U = 0; U < m; U++) {
              E = this.W[U];
              a = E.l * G;
              C = E.t * n;
              Y2 = U;
              u = E.e;
              F = E.P + 1 << 3;
              if (a !== r) {
                for (d = 0; d < Q; d++) {
                  z2 = 0 | d * a;
                  $[d] = (z2 & b) << 3 | z2 & 7;
                }
                r = a;
              }
              for (T = 0; T < h; T++) {
                z2 = 0 | T * C;
                V = F * (z2 & b) | (z2 & 7) << 3;
                for (d = 0; d < Q; d++) {
                  v[Y2] = u[V + $[d]];
                  Y2 += m;
                }
              }
            }
            var P = this.V;
            if (!f && m === 4 && !P) {
              P = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]);
            }
            if (P) {
              for (U = 0; U < j; ) {
                for (z2 = 0, J = 0; z2 < m; z2++, U++, J += 2) {
                  v[U] = (v[U] * P[J] >> 8) + P[J + 1];
                }
              }
            }
            return v;
          }, get f() {
            if (this.b) {
              return !!this.b.a;
            }
            if (this.p === 3) {
              if (this.N === 0) {
                return false;
              } else if (this.W[0].index === 82 && this.W[1].index === 71 && this.W[2].index === 66) {
                return false;
              }
              return true;
            }
            if (this.N === 1) {
              return true;
            }
            return false;
          }, z: function aj(Q) {
            var h, f, G;
            for (var n = 0, E = Q.length; n < E; n += 3) {
              h = Q[n];
              f = Q[n + 1];
              G = Q[n + 2];
              Q[n] = h - 179.456 + 1.402 * G;
              Q[n + 1] = h + 135.459 - 0.344 * f - 0.714 * G;
              Q[n + 2] = h - 226.816 + 1.772 * f;
            }
            return Q;
          }, O: function aa(Q) {
            var h, f, G, n, E = 0;
            for (var a = 0, C = Q.length; a < C; a += 4) {
              h = Q[a];
              f = Q[a + 1];
              G = Q[a + 2];
              n = Q[a + 3];
              Q[E++] = -122.67195406894 + f * (-660635669420364e-19 * f + 437130475926232e-18 * G - 54080610064599e-18 * h + 48449797120281e-17 * n - 0.154362151871126) + G * (-957964378445773e-18 * G + 817076911346625e-18 * h - 0.00477271405408747 * n + 1.53380253221734) + h * (961250184130688e-18 * h - 0.00266257332283933 * n + 0.48357088451265) + n * (-336197177618394e-18 * n + 0.484791561490776);
              Q[E++] = 107.268039397724 + f * (219927104525741e-19 * f - 640992018297945e-18 * G + 659397001245577e-18 * h + 426105652938837e-18 * n - 0.176491792462875) + G * (-778269941513683e-18 * G + 0.00130872261408275 * h + 770482631801132e-18 * n - 0.151051492775562) + h * (0.00126935368114843 * h - 0.00265090189010898 * n + 0.25802910206845) + n * (-318913117588328e-18 * n - 0.213742400323665);
              Q[E++] = -20.810012546947 + f * (-570115196973677e-18 * f - 263409051004589e-19 * G + 0.0020741088115012 * h - 0.00288260236853442 * n + 0.814272968359295) + G * (-153496057440975e-19 * G - 132689043961446e-18 * h + 560833691242812e-18 * n - 0.195152027534049) + h * (0.00174418132927582 * h - 0.00255243321439347 * n + 0.116935020465145) + n * (-343531996510555e-18 * n + 0.24165260232407);
            }
            return Q.subarray(0, E);
          }, r: function a3(Q) {
            var h, f, G;
            for (var n = 0, E = Q.length; n < E; n += 4) {
              h = Q[n];
              f = Q[n + 1];
              G = Q[n + 2];
              Q[n] = 434.456 - h - 1.402 * G;
              Q[n + 1] = 119.541 - h + 0.344 * f + 0.714 * G;
              Q[n + 2] = 481.816 - h - 1.772 * f;
            }
            return Q;
          }, U: function as(Q) {
            var h, f, G, n, E = 0;
            for (var a = 0, C = Q.length; a < C; a += 4) {
              h = Q[a];
              f = Q[a + 1];
              G = Q[a + 2];
              n = Q[a + 3];
              Q[E++] = 255 + h * (-6747147073602441e-20 * h + 8379262121013727e-19 * f + 2894718188643294e-19 * G + 0.003264231057537806 * n - 1.1185611867203937) + f * (26374107616089405e-21 * f - 8626949158638572e-20 * G - 2748769067499491e-19 * n - 0.02155688794978967) + G * (-3878099212869363e-20 * G - 3267808279485286e-19 * n + 0.0686742238595345) - n * (3361971776183937e-19 * n + 0.7430659151342254);
              Q[E++] = 255 + h * (13596372813588848e-20 * h + 924537132573585e-18 * f + 10567359618683593e-20 * G + 4791864687436512e-19 * n - 0.3109689587515875) + f * (-23545346108370344e-20 * f + 2702845253534714e-19 * G + 0.0020200308977307156 * n - 0.7488052167015494) + G * (6834815998235662e-20 * G + 15168452363460973e-20 * n - 0.09751927774728933) - n * (3189131175883281e-19 * n + 0.7364883807733168);
              Q[E++] = 255 + h * (13598650411385307e-21 * h + 12423956175490851e-20 * f + 4751985097583589e-19 * G - 36729317476630422e-22 * n - 0.05562186980264034) + f * (16141380598724676e-20 * f + 9692239130725186e-19 * G + 7782692450036253e-19 * n - 0.44015232367526463) + G * (5068882914068769e-22 * G + 0.0017778369011375071 * n - 0.7591454649749609) - n * (3435319965105553e-19 * n + 0.7063770186160144);
            }
            return Q.subarray(0, E);
          }, getData: function(Q) {
            var h = Q.width, f = Q.height, G = Q.forceRGB, n = Q.isSourcePDF;
            if (this.p > 4) {
              throw new W("Unsupported color mode");
            }
            var E = this.Y(h, f, n);
            if (this.p === 1 && G) {
              var a = E.length, C = new Uint8ClampedArray(a * 3), F = 0;
              for (var d = 0; d < a; d++) {
                var T = E[d];
                C[F++] = T;
                C[F++] = T;
                C[F++] = T;
              }
              return C;
            } else if (this.p === 3 && this.f) {
              return this.z(E);
            } else if (this.p === 4) {
              if (this.f) {
                if (G) {
                  return this.O(E);
                }
                return this.r(E);
              } else if (G) {
                return this.U(E);
              }
            }
            return E;
          } };
          return ak2;
        }();
        function Z(p, t) {
          return p[t] << 8 | p[t + 1];
        }
        UTIF22.JpegDecoder = ak;
      })();
      UTIF22.encodeImage = function(rgba, w, h, metadata) {
        var idf = {
          "t256": [w],
          "t257": [h],
          "t258": [8, 8, 8, 8],
          "t259": [1],
          "t262": [2],
          "t273": [1e3],
          // strips offset
          "t277": [4],
          "t278": [h],
          /* rows per strip */
          "t279": [w * h * 4],
          // strip byte counts
          "t282": [[72, 1]],
          "t283": [[72, 1]],
          "t284": [1],
          "t286": [[0, 1]],
          "t287": [[0, 1]],
          "t296": [1],
          "t305": ["Photopea (UTIF.js)"],
          "t338": [1]
        };
        if (metadata) for (var i in metadata) idf[i] = metadata[i];
        var prfx = new Uint8Array(UTIF22.encode([idf]));
        var img = new Uint8Array(rgba);
        var data = new Uint8Array(1e3 + w * h * 4);
        for (var i = 0; i < prfx.length; i++) data[i] = prfx[i];
        for (var i = 0; i < img.length; i++) data[1e3 + i] = img[i];
        return data.buffer;
      };
      UTIF22.encode = function(ifds) {
        var data = new Uint8Array(2e4), offset = 4, bin = UTIF22._binBE;
        data[0] = data[1] = 77;
        bin.writeUshort(data, 2, 42);
        var ifdo = 8;
        bin.writeUint(data, offset, ifdo);
        offset += 4;
        for (var i = 0; i < ifds.length; i++) {
          var noffs = UTIF22._writeIFD(bin, UTIF22._types.basic, data, ifdo, ifds[i]);
          ifdo = noffs[1];
          if (i < ifds.length - 1) {
            if ((ifdo & 3) != 0) ifdo += 4 - (ifdo & 3);
            bin.writeUint(data, noffs[0], ifdo);
          }
        }
        return data.slice(0, ifdo).buffer;
      };
      UTIF22.decode = function(buff, prm) {
        if (prm == null) prm = { parseMN: true, debug: false };
        var data = new Uint8Array(buff), offset = 0;
        var id = UTIF22._binBE.readASCII(data, offset, 2);
        offset += 2;
        var bin = id == "II" ? UTIF22._binLE : UTIF22._binBE;
        bin.readUshort(data, offset);
        offset += 2;
        var ifdo = bin.readUint(data, offset);
        offset += 4;
        var ifds = [];
        while (true) {
          var cnt = bin.readUshort(data, ifdo), typ = bin.readUshort(data, ifdo + 4);
          if (cnt != 0) {
            if (typ < 1 || 13 < typ) {
              log("error in TIFF");
              break;
            }
          }
          UTIF22._readIFD(bin, data, ifdo, ifds, 0, prm);
          ifdo = bin.readUint(data, ifdo + 2 + cnt * 12);
          if (ifdo == 0) break;
        }
        return ifds;
      };
      UTIF22.decodeImage = function(buff, img, ifds) {
        if (img.data) return;
        var data = new Uint8Array(buff);
        var id = UTIF22._binBE.readASCII(data, 0, 2);
        if (img["t256"] == null) return;
        img.isLE = id == "II";
        img.width = img["t256"][0];
        img.height = img["t257"][0];
        var cmpr = img["t259"] ? img["t259"][0] : 1;
        var fo = img["t266"] ? img["t266"][0] : 1;
        if (img["t284"] && img["t284"][0] == 2) log("PlanarConfiguration 2 should not be used!");
        if (cmpr == 7 && img["t258"] && img["t258"].length > 3) img["t258"] = img["t258"].slice(0, 3);
        var spp = img["t277"] ? img["t277"][0] : 1;
        var bps = img["t258"] ? img["t258"][0] : 1;
        var bipp = bps * spp;
        if (cmpr == 1 && img["t279"] != null && img["t278"] && img["t262"][0] == 32803) {
          bipp = Math.round(img["t279"][0] * 8 / (img.width * img["t278"][0]));
        }
        if (img["t50885"] && img["t50885"][0] == 4) bipp = img["t258"][0] * 3;
        var bipl = Math.ceil(img.width * bipp / 8) * 8;
        var soff = img["t273"];
        if (soff == null || img["t322"]) soff = img["t324"];
        var bcnt = img["t279"];
        if (cmpr == 1 && soff.length == 1) bcnt = [img.height * (bipl >>> 3)];
        if (bcnt == null || img["t322"]) bcnt = img["t325"];
        var bytes = new Uint8Array(img.height * (bipl >>> 3)), bilen = 0;
        if (img["t322"] != null) {
          var tw = img["t322"][0], th = img["t323"][0];
          var tx = Math.floor((img.width + tw - 1) / tw);
          var ty = Math.floor((img.height + th - 1) / th);
          var tbuff = new Uint8Array(Math.ceil(tw * th * bipp / 8) | 0);
          console.log("====", tx, ty);
          for (var y2 = 0; y2 < ty; y2++)
            for (var x2 = 0; x2 < tx; x2++) {
              var i = y2 * tx + x2;
              tbuff.fill(0);
              UTIF22.decode._decompress(img, ifds, data, soff[i], bcnt[i], cmpr, tbuff, 0, fo, tw, th);
              if (cmpr == 6) bytes = tbuff;
              else UTIF22._copyTile(tbuff, Math.ceil(tw * bipp / 8) | 0, th, bytes, Math.ceil(img.width * bipp / 8) | 0, img.height, Math.ceil(x2 * tw * bipp / 8) | 0, y2 * th);
            }
          bilen = bytes.length * 8;
        } else {
          if (soff == null) return;
          var rps = img["t278"] ? img["t278"][0] : img.height;
          rps = Math.min(rps, img.height);
          for (var i = 0; i < soff.length; i++) {
            UTIF22.decode._decompress(img, ifds, data, soff[i], bcnt[i], cmpr, bytes, Math.ceil(bilen / 8) | 0, fo, img.width, rps);
            bilen += bipl * rps;
          }
          bilen = Math.min(bilen, bytes.length * 8);
        }
        img.data = new Uint8Array(bytes.buffer, 0, Math.ceil(bilen / 8) | 0);
      };
      UTIF22.decode._decompress = function(img, ifds, data, off, len, cmpr, tgt, toff, fo, w, h) {
        if (img["t271"] && img["t271"][0] == "Panasonic" && img["t45"] && img["t45"][0] == 6) cmpr = 34316;
        if (cmpr == 1) for (var j = 0; j < len; j++) tgt[toff + j] = data[off + j];
        else if (cmpr == 2) UTIF22.decode._decodeG2(data, off, len, tgt, toff, w, fo);
        else if (cmpr == 3) UTIF22.decode._decodeG3(data, off, len, tgt, toff, w, fo, img["t292"] ? (img["t292"][0] & 1) == 1 : false);
        else if (cmpr == 4) UTIF22.decode._decodeG4(data, off, len, tgt, toff, w, fo);
        else if (cmpr == 5) UTIF22.decode._decodeLZW(data, off, len, tgt, toff, 8);
        else if (cmpr == 6) UTIF22.decode._decodeOldJPEG(img, data, off, len, tgt, toff);
        else if (cmpr == 7 || cmpr == 34892) UTIF22.decode._decodeNewJPEG(img, data, off, len, tgt, toff);
        else if (cmpr == 8 || cmpr == 32946) {
          var src2 = new Uint8Array(data.buffer, off + 2, len - 6);
          var bin = pako2["inflateRaw"](src2);
          if (toff + bin.length <= tgt.length) tgt.set(bin, toff);
        } else if (cmpr == 9) UTIF22.decode._decodeVC5(data, off, len, tgt, toff, img["t33422"]);
        else if (cmpr == 32767) UTIF22.decode._decodeARW(img, data, off, len, tgt, toff);
        else if (cmpr == 32773) UTIF22.decode._decodePackBits(data, off, len, tgt, toff);
        else if (cmpr == 32809) UTIF22.decode._decodeThunder(data, off, len, tgt, toff);
        else if (cmpr == 34316) UTIF22.decode._decodePanasonic(img, data, off, len, tgt, toff);
        else if (cmpr == 34713)
          UTIF22.decode._decodeNikon(img, ifds, data, off, len, tgt, toff);
        else if (cmpr == 34676) UTIF22.decode._decodeLogLuv32(img, data, off, len, tgt, toff);
        else log("Unknown compression", cmpr);
        var bps = img["t258"] ? Math.min(32, img["t258"][0]) : 1;
        var noc = img["t277"] ? img["t277"][0] : 1, bpp = bps * noc >>> 3, bpl = Math.ceil(bps * noc * w / 8);
        if (bps == 16 && !img.isLE && img["t33422"] == null)
          for (var y2 = 0; y2 < h; y2++) {
            var roff = toff + y2 * bpl;
            for (var x2 = 1; x2 < bpl; x2 += 2) {
              var t = tgt[roff + x2];
              tgt[roff + x2] = tgt[roff + x2 - 1];
              tgt[roff + x2 - 1] = t;
            }
          }
        if (img["t317"] && img["t317"][0] == 2) {
          for (var y2 = 0; y2 < h; y2++) {
            var ntoff = toff + y2 * bpl;
            if (bps == 16) for (var j = bpp; j < bpl; j += 2) {
              var nv = (tgt[ntoff + j + 1] << 8 | tgt[ntoff + j]) + (tgt[ntoff + j - bpp + 1] << 8 | tgt[ntoff + j - bpp]);
              tgt[ntoff + j] = nv & 255;
              tgt[ntoff + j + 1] = nv >>> 8 & 255;
            }
            else if (noc == 3) for (var j = 3; j < bpl; j += 3) {
              tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - 3] & 255;
              tgt[ntoff + j + 1] = tgt[ntoff + j + 1] + tgt[ntoff + j - 2] & 255;
              tgt[ntoff + j + 2] = tgt[ntoff + j + 2] + tgt[ntoff + j - 1] & 255;
            }
            else for (var j = bpp; j < bpl; j++) tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - bpp] & 255;
          }
        }
      };
      UTIF22.decode._decodePanasonic = function(img, data, off, len, tgt, toff) {
        var img_buffer = data.buffer;
        var rawWidth = img["t2"][0];
        var rawHeight = img["t3"][0];
        var bitsPerSample = img["t10"][0];
        var RW2_Format = img["t45"][0];
        var bidx = 0;
        var imageIndex = 0;
        var vpos = 0;
        var byte = 0;
        var bytes = RW2_Format == 6 ? new Uint32Array(18) : new Uint8Array(16);
        var i, j, sh, pred = [0, 0], nonz = [0, 0], isOdd, idx = 0, pixel_base;
        var row, col, crow;
        var buffer = new Uint8Array(16384);
        var result = new Uint16Array(tgt.buffer);
        function getDataRaw(bits) {
          if (vpos == 0) {
            var arr_a2 = new Uint8Array(img_buffer, off + imageIndex + 8184, 16384 - 8184);
            var arr_b2 = new Uint8Array(img_buffer, off + imageIndex, 8184);
            buffer.set(arr_a2);
            buffer.set(arr_b2, arr_a2.length);
            imageIndex += 16384;
          }
          if (RW2_Format == 5) {
            for (i = 0; i < 16; i++) {
              bytes[i] = buffer[vpos++];
              vpos &= 16383;
            }
          } else {
            vpos = vpos - bits & 131071;
            byte = vpos >> 3 ^ 16368;
            return (buffer[byte] | buffer[byte + 1] << 8) >> (vpos & 7) & ~(-1 << bits);
          }
        }
        function getBufferDataRW6(i2) {
          return buffer[vpos + 15 - i2];
        }
        function readPageRW6() {
          bytes[0] = getBufferDataRW6(0) << 6 | getBufferDataRW6(1) >> 2;
          bytes[1] = ((getBufferDataRW6(1) & 3) << 12 | getBufferDataRW6(2) << 4 | getBufferDataRW6(3) >> 4) & 16383;
          bytes[2] = getBufferDataRW6(3) >> 2 & 3;
          bytes[3] = (getBufferDataRW6(3) & 3) << 8 | getBufferDataRW6(4);
          bytes[4] = getBufferDataRW6(5) << 2 | getBufferDataRW6(6) >> 6;
          bytes[5] = (getBufferDataRW6(6) & 63) << 4 | getBufferDataRW6(7) >> 4;
          bytes[6] = getBufferDataRW6(7) >> 2 & 3;
          bytes[7] = (getBufferDataRW6(7) & 3) << 8 | getBufferDataRW6(8);
          bytes[8] = getBufferDataRW6(9) << 2 & 1020 | getBufferDataRW6(10) >> 6;
          bytes[9] = (getBufferDataRW6(10) << 4 | getBufferDataRW6(11) >> 4) & 1023;
          bytes[10] = getBufferDataRW6(11) >> 2 & 3;
          bytes[11] = (getBufferDataRW6(11) & 3) << 8 | getBufferDataRW6(12);
          bytes[12] = (getBufferDataRW6(13) << 2 & 1020 | getBufferDataRW6(14) >> 6) & 1023;
          bytes[13] = (getBufferDataRW6(14) << 4 | getBufferDataRW6(15) >> 4) & 1023;
          vpos += 16;
          byte = 0;
        }
        function readPageRw6_bps12() {
          bytes[0] = getBufferDataRW6(0) << 4 | getBufferDataRW6(1) >> 4;
          bytes[1] = ((getBufferDataRW6(1) & 15) << 8 | getBufferDataRW6(2)) & 4095;
          bytes[2] = getBufferDataRW6(3) >> 6 & 3;
          bytes[3] = (getBufferDataRW6(3) & 63) << 2 | getBufferDataRW6(4) >> 6;
          bytes[4] = (getBufferDataRW6(4) & 63) << 2 | getBufferDataRW6(5) >> 6;
          bytes[5] = (getBufferDataRW6(5) & 63) << 2 | getBufferDataRW6(6) >> 6;
          bytes[6] = getBufferDataRW6(6) >> 4 & 3;
          bytes[7] = (getBufferDataRW6(6) & 15) << 4 | getBufferDataRW6(7) >> 4;
          bytes[8] = (getBufferDataRW6(7) & 15) << 4 | getBufferDataRW6(8) >> 4;
          bytes[9] = (getBufferDataRW6(8) & 15) << 4 | getBufferDataRW6(9) >> 4;
          bytes[10] = getBufferDataRW6(9) >> 2 & 3;
          bytes[11] = (getBufferDataRW6(9) & 3) << 6 | getBufferDataRW6(10) >> 2;
          bytes[12] = (getBufferDataRW6(10) & 3) << 6 | getBufferDataRW6(11) >> 2;
          bytes[13] = (getBufferDataRW6(11) & 3) << 6 | getBufferDataRW6(12) >> 2;
          bytes[14] = getBufferDataRW6(12) & 3;
          bytes[15] = getBufferDataRW6(13);
          bytes[16] = getBufferDataRW6(14);
          bytes[17] = getBufferDataRW6(15);
          vpos += 16;
          byte = 0;
        }
        function resetPredNonzeros() {
          pred[0] = 0;
          pred[1] = 0;
          nonz[0] = 0;
          nonz[1] = 0;
        }
        if (RW2_Format == 7) {
          throw RW2_Format;
        } else if (RW2_Format == 6) {
          var is12bit = bitsPerSample == 12, readPageRw6Fn = is12bit ? readPageRw6_bps12 : readPageRW6, pixelsPerBlock = is12bit ? 14 : 11, pixelbase0 = is12bit ? 128 : 512, pixelbase_compare = is12bit ? 2048 : 8192, spix_compare = is12bit ? 16383 : 65535, pixel_mask = is12bit ? 4095 : 16383, blocksperrow = rawWidth / pixelsPerBlock, rowbytes = blocksperrow * 16, bufferSize = is12bit ? 18 : 14;
          for (row = 0; row < rawHeight - 15; row += 16) {
            var rowstoread = Math.min(16, rawHeight - row);
            var readlen = rowbytes * rowstoread;
            buffer = new Uint8Array(img_buffer, off + bidx, readlen);
            vpos = 0;
            bidx += readlen;
            for (crow = 0, col = 0; crow < rowstoread; crow++, col = 0) {
              idx = (row + crow) * rawWidth;
              for (var rblock = 0; rblock < blocksperrow; rblock++) {
                readPageRw6Fn();
                resetPredNonzeros();
                sh = 0;
                pixel_base = 0;
                for (i = 0; i < pixelsPerBlock; i++) {
                  isOdd = i & 1;
                  if (i % 3 == 2) {
                    var base = byte < bufferSize ? bytes[byte++] : 0;
                    if (base == 3) base = 4;
                    pixel_base = pixelbase0 << base;
                    sh = 1 << base;
                  }
                  var epixel = byte < bufferSize ? bytes[byte++] : 0;
                  if (pred[isOdd]) {
                    epixel *= sh;
                    if (pixel_base < pixelbase_compare && nonz[isOdd] > pixel_base)
                      epixel += nonz[isOdd] - pixel_base;
                    nonz[isOdd] = epixel;
                  } else {
                    pred[isOdd] = epixel;
                    if (epixel)
                      nonz[isOdd] = epixel;
                    else
                      epixel = nonz[isOdd];
                  }
                  result[idx + col++] = epixel - 15 <= spix_compare ? epixel - 15 & spix_compare : epixel + 2147483633 >> 31 & pixel_mask;
                }
              }
            }
          }
        } else if (RW2_Format == 5) {
          var blockSize = bitsPerSample == 12 ? 10 : 9;
          for (row = 0; row < rawHeight; row++) {
            for (col = 0; col < rawWidth; col += blockSize) {
              getDataRaw(0);
              if (bitsPerSample == 12) {
                result[idx++] = ((bytes[1] & 15) << 8) + bytes[0];
                result[idx++] = 16 * bytes[2] + (bytes[1] >> 4);
                result[idx++] = ((bytes[4] & 15) << 8) + bytes[3];
                result[idx++] = 16 * bytes[5] + (bytes[4] >> 4);
                result[idx++] = ((bytes[7] & 15) << 8) + bytes[6];
                result[idx++] = 16 * bytes[8] + (bytes[7] >> 4);
                result[idx++] = ((bytes[10] & 15) << 8) + bytes[9];
                result[idx++] = 16 * bytes[11] + (bytes[10] >> 4);
                result[idx++] = ((bytes[13] & 15) << 8) + bytes[12];
                result[idx++] = 16 * bytes[14] + (bytes[13] >> 4);
              } else if (bitsPerSample == 14) {
                result[idx++] = bytes[0] + ((bytes[1] & 63) << 8);
                result[idx++] = (bytes[1] >> 6) + 4 * bytes[2] + ((bytes[3] & 15) << 10);
                result[idx++] = (bytes[3] >> 4) + 16 * bytes[4] + ((bytes[5] & 3) << 12);
                result[idx++] = ((bytes[5] & 252) >> 2) + (bytes[6] << 6);
                result[idx++] = bytes[7] + ((bytes[8] & 63) << 8);
                result[idx++] = (bytes[8] >> 6) + 4 * bytes[9] + ((bytes[10] & 15) << 10);
                result[idx++] = (bytes[10] >> 4) + 16 * bytes[11] + ((bytes[12] & 3) << 12);
                result[idx++] = ((bytes[12] & 252) >> 2) + (bytes[13] << 6);
                result[idx++] = bytes[14] + ((bytes[15] & 63) << 8);
              }
            }
          }
        } else if (RW2_Format == 4) {
          for (row = 0; row < rawHeight; row++) {
            for (col = 0; col < rawWidth; col++) {
              i = col % 14;
              isOdd = i & 1;
              if (i == 0) resetPredNonzeros();
              if (i % 3 == 2)
                sh = 4 >> 3 - getDataRaw(2);
              if (nonz[isOdd]) {
                j = getDataRaw(8);
                if (j != 0) {
                  pred[isOdd] -= 128 << sh;
                  if (pred[isOdd] < 0 || sh == 4)
                    pred[isOdd] &= ~(-1 << sh);
                  pred[isOdd] += j << sh;
                }
              } else {
                nonz[isOdd] = getDataRaw(8);
                if (nonz[isOdd] || i > 11)
                  pred[isOdd] = nonz[isOdd] << 4 | getDataRaw(4);
              }
              result[idx++] = pred[col & 1];
            }
          }
        } else throw RW2_Format;
      };
      UTIF22.decode._decodeVC5 = function() {
        var x2 = [1, 0, 1, 0, 2, 2, 1, 1, 3, 7, 1, 2, 5, 25, 1, 3, 6, 48, 1, 4, 6, 54, 1, 5, 7, 111, 1, 8, 7, 99, 1, 6, 7, 105, 12, 0, 7, 107, 1, 7, 8, 209, 20, 0, 8, 212, 1, 9, 8, 220, 1, 10, 9, 393, 1, 11, 9, 394, 32, 0, 9, 416, 1, 12, 9, 427, 1, 13, 10, 887, 1, 18, 10, 784, 1, 14, 10, 790, 1, 15, 10, 835, 60, 0, 10, 852, 1, 16, 10, 885, 1, 17, 11, 1571, 1, 19, 11, 1668, 1, 20, 11, 1669, 100, 0, 11, 1707, 1, 21, 11, 1772, 1, 22, 12, 3547, 1, 29, 12, 3164, 1, 24, 12, 3166, 1, 25, 12, 3140, 1, 23, 12, 3413, 1, 26, 12, 3537, 1, 27, 12, 3539, 1, 28, 13, 7093, 1, 35, 13, 6283, 1, 30, 13, 6331, 1, 31, 13, 6335, 180, 0, 13, 6824, 1, 32, 13, 7072, 1, 33, 13, 7077, 320, 0, 13, 7076, 1, 34, 14, 12565, 1, 36, 14, 12661, 1, 37, 14, 12669, 1, 38, 14, 13651, 1, 39, 14, 14184, 1, 40, 15, 28295, 1, 46, 15, 28371, 1, 47, 15, 25320, 1, 42, 15, 25336, 1, 43, 15, 25128, 1, 41, 15, 27300, 1, 44, 15, 28293, 1, 45, 16, 50259, 1, 48, 16, 50643, 1, 49, 16, 50675, 1, 50, 16, 56740, 1, 53, 16, 56584, 1, 51, 16, 56588, 1, 52, 17, 113483, 1, 61, 17, 113482, 1, 60, 17, 101285, 1, 55, 17, 101349, 1, 56, 17, 109205, 1, 57, 17, 109207, 1, 58, 17, 100516, 1, 54, 17, 113171, 1, 59, 18, 202568, 1, 62, 18, 202696, 1, 63, 18, 218408, 1, 64, 18, 218412, 1, 65, 18, 226340, 1, 66, 18, 226356, 1, 67, 18, 226358, 1, 68, 19, 402068, 1, 69, 19, 405138, 1, 70, 19, 405394, 1, 71, 19, 436818, 1, 72, 19, 436826, 1, 73, 19, 452714, 1, 75, 19, 452718, 1, 76, 19, 452682, 1, 74, 20, 804138, 1, 77, 20, 810279, 1, 78, 20, 810790, 1, 79, 20, 873638, 1, 80, 20, 873654, 1, 81, 20, 905366, 1, 82, 20, 905430, 1, 83, 20, 905438, 1, 84, 21, 1608278, 1, 85, 21, 1620557, 1, 86, 21, 1621582, 1, 87, 21, 1621583, 1, 88, 21, 1747310, 1, 89, 21, 1810734, 1, 90, 21, 1810735, 1, 91, 21, 1810863, 1, 92, 21, 1810879, 1, 93, 22, 3621725, 1, 99, 22, 3621757, 1, 100, 22, 3241112, 1, 94, 22, 3494556, 1, 95, 22, 3494557, 1, 96, 22, 3494622, 1, 97, 22, 3494623, 1, 98, 23, 6482227, 1, 102, 23, 6433117, 1, 101, 23, 6989117, 1, 103, 23, 6989119, 1, 105, 23, 6989118, 1, 104, 23, 7243449, 1, 106, 23, 7243512, 1, 107, 24, 13978233, 1, 111, 24, 12964453, 1, 109, 24, 12866232, 1, 108, 24, 14486897, 1, 113, 24, 13978232, 1, 110, 24, 14486896, 1, 112, 24, 14487026, 1, 114, 24, 14487027, 1, 115, 25, 25732598, 1, 225, 25, 25732597, 1, 189, 25, 25732596, 1, 188, 25, 25732595, 1, 203, 25, 25732594, 1, 202, 25, 25732593, 1, 197, 25, 25732592, 1, 207, 25, 25732591, 1, 169, 25, 25732590, 1, 223, 25, 25732589, 1, 159, 25, 25732522, 1, 235, 25, 25732579, 1, 152, 25, 25732575, 1, 192, 25, 25732489, 1, 179, 25, 25732573, 1, 201, 25, 25732472, 1, 172, 25, 25732576, 1, 149, 25, 25732488, 1, 178, 25, 25732566, 1, 120, 25, 25732571, 1, 219, 25, 25732577, 1, 150, 25, 25732487, 1, 127, 25, 25732506, 1, 211, 25, 25732548, 1, 125, 25, 25732588, 1, 158, 25, 25732486, 1, 247, 25, 25732467, 1, 238, 25, 25732508, 1, 163, 25, 25732552, 1, 228, 25, 25732603, 1, 183, 25, 25732513, 1, 217, 25, 25732587, 1, 168, 25, 25732520, 1, 122, 25, 25732484, 1, 128, 25, 25732562, 1, 249, 25, 25732505, 1, 187, 25, 25732504, 1, 186, 25, 25732483, 1, 136, 25, 25928905, 1, 181, 25, 25732560, 1, 255, 25, 25732500, 1, 230, 25, 25732482, 1, 135, 25, 25732555, 1, 233, 25, 25732568, 1, 222, 25, 25732583, 1, 145, 25, 25732481, 1, 134, 25, 25732586, 1, 167, 25, 25732521, 1, 248, 25, 25732518, 1, 209, 25, 25732480, 1, 243, 25, 25732512, 1, 216, 25, 25732509, 1, 164, 25, 25732547, 1, 140, 25, 25732479, 1, 157, 25, 25732544, 1, 239, 25, 25732574, 1, 191, 25, 25732564, 1, 251, 25, 25732478, 1, 156, 25, 25732546, 1, 139, 25, 25732498, 1, 242, 25, 25732557, 1, 133, 25, 25732477, 1, 162, 25, 25732515, 1, 213, 25, 25732584, 1, 165, 25, 25732514, 1, 212, 25, 25732476, 1, 227, 25, 25732494, 1, 198, 25, 25732531, 1, 236, 25, 25732530, 1, 234, 25, 25732529, 1, 117, 25, 25732528, 1, 215, 25, 25732527, 1, 124, 25, 25732526, 1, 123, 25, 25732525, 1, 254, 25, 25732524, 1, 253, 25, 25732523, 1, 148, 25, 25732570, 1, 218, 25, 25732580, 1, 146, 25, 25732581, 1, 147, 25, 25732569, 1, 224, 25, 25732533, 1, 143, 25, 25732540, 1, 184, 25, 25732541, 1, 185, 25, 25732585, 1, 166, 25, 25732556, 1, 132, 25, 25732485, 1, 129, 25, 25732563, 1, 250, 25, 25732578, 1, 151, 25, 25732501, 1, 119, 25, 25732502, 1, 193, 25, 25732536, 1, 176, 25, 25732496, 1, 245, 25, 25732553, 1, 229, 25, 25732516, 1, 206, 25, 25732582, 1, 144, 25, 25732517, 1, 208, 25, 25732558, 1, 137, 25, 25732543, 1, 241, 25, 25732466, 1, 237, 25, 25732507, 1, 190, 25, 25732542, 1, 240, 25, 25732551, 1, 131, 25, 25732554, 1, 232, 25, 25732565, 1, 252, 25, 25732475, 1, 171, 25, 25732493, 1, 205, 25, 25732492, 1, 204, 25, 25732491, 1, 118, 25, 25732490, 1, 214, 25, 25928904, 1, 180, 25, 25732549, 1, 126, 25, 25732602, 1, 182, 25, 25732539, 1, 175, 25, 25732545, 1, 141, 25, 25732559, 1, 138, 25, 25732537, 1, 177, 25, 25732534, 1, 153, 25, 25732503, 1, 194, 25, 25732606, 1, 160, 25, 25732567, 1, 121, 25, 25732538, 1, 174, 25, 25732497, 1, 246, 25, 25732550, 1, 130, 25, 25732572, 1, 200, 25, 25732474, 1, 170, 25, 25732511, 1, 221, 25, 25732601, 1, 196, 25, 25732532, 1, 142, 25, 25732519, 1, 210, 25, 25732495, 1, 199, 25, 25732605, 1, 155, 25, 25732535, 1, 154, 25, 25732499, 1, 244, 25, 25732510, 1, 220, 25, 25732600, 1, 195, 25, 25732607, 1, 161, 25, 25732604, 1, 231, 25, 25732473, 1, 173, 25, 25732599, 1, 226, 26, 51465122, 1, 116, 26, 51465123, 0, 1], o, C, k, P = [3, 3, 3, 3, 2, 2, 2, 1, 1, 1], V = 24576, ar = 16384, H = 8192, az = ar | H;
        function d(t) {
          var E = t[1], h = t[0][E >>> 3] >>> 7 - (E & 7) & 1;
          t[1]++;
          return h;
        }
        function ag(t, E) {
          if (o == null) {
            o = {};
            for (var h = 0; h < x2.length; h += 4) o[x2[h + 1]] = x2.slice(h, h + 4);
          }
          var L = d(t), g = o[L];
          while (g == null) {
            L = L << 1 | d(t);
            g = o[L];
          }
          var n = g[3];
          if (n != 0) n = d(t) == 0 ? n : -n;
          E[0] = g[2];
          E[1] = n;
        }
        function m(t, E) {
          for (var h = 0; h < E; h++) {
            if ((t & 1) == 1) t++;
            t = t >>> 1;
          }
          return t;
        }
        function A(t, E) {
          return t >> E;
        }
        function O(t, E, h, L, g, n) {
          E[h] = A(A(11 * t[g] - 4 * t[g + n] + t[g + n + n] + 4, 3) + t[L], 1);
          E[h + n] = A(A(5 * t[g] + 4 * t[g + n] - t[g + n + n] + 4, 3) - t[L], 1);
        }
        function J(t, E, h, L, g, n) {
          var W = t[g - n] - t[g + n], j = t[g], $ = t[L];
          E[h] = A(A(W + 4, 3) + j + $, 1);
          E[h + n] = A(A(-W + 4, 3) + j - $, 1);
        }
        function y2(t, E, h, L, g, n) {
          E[h] = A(A(5 * t[g] + 4 * t[g - n] - t[g - n - n] + 4, 3) + t[L], 1);
          E[h + n] = A(A(11 * t[g] - 4 * t[g - n] + t[g - n - n] + 4, 3) - t[L], 1);
        }
        function q(t) {
          t = t < 0 ? 0 : t > 4095 ? 4095 : t;
          t = k[t] >>> 2;
          return t;
        }
        function av(t, E, h, L, g, n) {
          L = new Uint16Array(L.buffer);
          var W = Date.now(), j = UTIF22._binBE, $ = E + h, r, u, X, I, ax, R, aa, i, T, B;
          E += 4;
          var a5 = n[0] == 1;
          while (E < $) {
            var S = j.readShort(t, E), s = j.readUshort(t, E + 2);
            E += 4;
            if (S == 12) r = s;
            else if (S == 20) u = s;
            else if (S == 21) X = s;
            else if (S == 48) I = s;
            else if (S == 53) ax = s;
            else if (S == 35) ;
            else if (S == 62) R = s;
            else if (S == 101) ;
            else if (S == 109) aa = s;
            else if (S == 84) ;
            else if (S == 106) ;
            else if (S == 107) ;
            else if (S == 108) ;
            else if (S == 102) ;
            else if (S == 104) i = s;
            else if (S == 105) ;
            else {
              var F = S < 0 ? -S : S, D = F & 65280, _ = 0;
              if (F & az) {
                if (F & H) {
                  _ = s & 65535;
                  _ += (F & 255) << 16;
                } else {
                  _ = s & 65535;
                }
              }
              if ((F & V) == V) {
                if (T == null) {
                  T = [];
                  for (var M = 0; M < 4; M++) T[M] = new Int16Array((u >>> 1) * (X >>> 1));
                  B = new Int16Array((u >>> 1) * (X >>> 1));
                  C = new Int16Array(1024);
                  for (var M = 0; M < 1024; M++) {
                    var aG = M - 512, p = Math.abs(aG), r = Math.floor(768 * p * p * p / (255 * 255 * 255)) + p;
                    C[M] = Math.sign(aG) * r;
                  }
                  k = new Uint16Array(4096);
                  var aA = (1 << 16) - 1;
                  for (var M = 0; M < 4096; M++) {
                    var at = M, a1 = aA * (Math.pow(113, at / 4095) - 1) / 112;
                    k[M] = Math.min(a1, aA);
                  }
                }
                var w = T[R], v = m(u, 1 + P[I]), N = m(X, 1 + P[I]);
                if (I == 0) {
                  for (var b = 0; b < N; b++) for (var G = 0; G < v; G++) {
                    var c2 = E + (b * v + G) * 2;
                    w[b * (u >>> 1) + G] = t[c2] << 8 | t[c2 + 1];
                  }
                } else {
                  var a7 = [t, E * 8], a4 = [], ay = 0, aw = v * N, f = [0, 0], Q = 0, s = 0;
                  while (ay < aw) {
                    ag(a7, f);
                    Q = f[0];
                    s = f[1];
                    while (Q > 0) {
                      a4[ay++] = s;
                      Q--;
                    }
                  }
                  var l = (I - 1) % 3, aF = l != 1 ? v : 0, a2 = l != 0 ? N : 0;
                  for (var b = 0; b < N; b++) {
                    var af = (b + a2) * (u >>> 1) + aF, au = b * v;
                    for (var G = 0; G < v; G++) w[af + G] = C[a4[au + G] + 512] * ax;
                  }
                  if (l == 2) {
                    var i = u >>> 1, an = v * 2, a9 = N * 2;
                    for (var b = 0; b < N; b++) {
                      for (var G = 0; G < an; G++) {
                        var M = b * 2 * i + G, a = b * i + G, e = N * i + a;
                        if (b == 0) O(w, B, M, e, a, i);
                        else if (b == N - 1) y2(w, B, M, e, a, i);
                        else J(w, B, M, e, a, i);
                      }
                    }
                    var Z = w;
                    w = B;
                    B = Z;
                    for (var b = 0; b < a9; b++) {
                      for (var G = 0; G < v; G++) {
                        var M = b * i + 2 * G, a = b * i + G, e = v + a;
                        if (G == 0) O(w, B, M, e, a, 1);
                        else if (G == v - 1) y2(w, B, M, e, a, 1);
                        else J(w, B, M, e, a, 1);
                      }
                    }
                    var Z = w;
                    w = B;
                    B = Z;
                    var aC = [], aB = 2 - ~~((I - 1) / 3);
                    for (var K = 0; K < 3; K++) aC[K] = aa >> 14 - K * 2 & 3;
                    var a6 = aC[aB];
                    if (a6 != 0) for (var b = 0; b < a9; b++) for (var G = 0; G < an; G++) {
                      var M = b * i + G;
                      w[M] = w[M] << a6;
                    }
                  }
                }
                if (I == 9 && R == 3) {
                  var a8 = T[0], ab = T[1], aq = T[2], as = T[3];
                  for (var b = 0; b < X; b += 2) for (var G = 0; G < u; G += 2) {
                    var U = b * u + G, c2 = (b >>> 1) * (u >>> 1) + (G >>> 1), z2 = a8[c2], ao = ab[c2] - 2048, ak = aq[c2] - 2048, ad = as[c2] - 2048, aj = (ao << 1) + z2, a0 = (ak << 1) + z2, aH = z2 + ad, am = z2 - ad;
                    if (a5) {
                      L[U] = q(aH);
                      L[U + 1] = q(a0);
                      L[U + u] = q(aj);
                      L[U + u + 1] = q(am);
                    } else {
                      L[U] = q(aj);
                      L[U + 1] = q(aH);
                      L[U + u] = q(am);
                      L[U + u + 1] = q(a0);
                    }
                  }
                }
                E += _ * 4;
              } else if (F == 16388) {
                E += _ * 4;
              } else if (D == 8192 || D == 8448 || D == 9216) ;
              else throw F.toString(16);
            }
          }
          console.log(Date.now() - W);
        }
        return av;
      }();
      UTIF22.decode._decodeLogLuv32 = function(img, data, off, len, tgt, toff) {
        var w = img.width, qw = w * 4;
        var io = 0, out = new Uint8Array(qw);
        while (io < len) {
          var oo = 0;
          while (oo < qw) {
            var c2 = data[off + io];
            io++;
            if (c2 < 128) {
              for (var j = 0; j < c2; j++) out[oo + j] = data[off + io + j];
              oo += c2;
              io += c2;
            } else {
              c2 = c2 - 126;
              for (var j = 0; j < c2; j++) out[oo + j] = data[off + io];
              oo += c2;
              io++;
            }
          }
          for (var x2 = 0; x2 < w; x2++) {
            tgt[toff + 0] = out[x2];
            tgt[toff + 1] = out[x2 + w];
            tgt[toff + 2] = out[x2 + w * 2];
            tgt[toff + 4] = out[x2 + w * 3];
            toff += 6;
          }
        }
      };
      UTIF22.decode._ljpeg_diff = function(data, prm, huff) {
        var getbithuff = UTIF22.decode._getbithuff;
        var len, diff;
        len = getbithuff(data, prm, huff[0], huff);
        diff = getbithuff(data, prm, len, 0);
        if ((diff & 1 << len - 1) == 0) diff -= (1 << len) - 1;
        return diff;
      };
      UTIF22.decode._decodeARW = function(img, inp, off, src_length, tgt, toff) {
        var raw_width = img["t256"][0], height = img["t257"][0], tiff_bps = img["t258"][0];
        var bin = img.isLE ? UTIF22._binLE : UTIF22._binBE;
        var arw2 = raw_width * height == src_length || raw_width * height * 1.5 == src_length;
        if (!arw2) {
          height += 8;
          var prm = [off, 0, 0, 0];
          var huff = new Uint16Array(32770);
          var tab = [
            3857,
            3856,
            3599,
            3342,
            3085,
            2828,
            2571,
            2314,
            2057,
            1800,
            1543,
            1286,
            1029,
            772,
            771,
            768,
            514,
            513
          ];
          var i, c2, n, col, row, sum = 0;
          var ljpeg_diff = UTIF22.decode._ljpeg_diff;
          huff[0] = 15;
          for (n = i = 0; i < 18; i++) {
            var lim = 32768 >>> (tab[i] >>> 8);
            for (var c2 = 0; c2 < lim; c2++) huff[++n] = tab[i];
          }
          for (col = raw_width; col--; )
            for (row = 0; row < height + 1; row += 2) {
              if (row == height) row = 1;
              sum += ljpeg_diff(inp, prm, huff);
              if (row < height) {
                var clr = sum & 4095;
                UTIF22.decode._putsF(tgt, (row * raw_width + col) * tiff_bps, clr << 16 - tiff_bps);
              }
            }
          return;
        }
        if (raw_width * height * 1.5 == src_length) {
          for (var i = 0; i < src_length; i += 3) {
            var b0 = inp[off + i + 0], b1 = inp[off + i + 1], b2 = inp[off + i + 2];
            tgt[toff + i] = b1 << 4 | b0 >>> 4;
            tgt[toff + i + 1] = b0 << 4 | b2 >>> 4;
            tgt[toff + i + 2] = b2 << 4 | b1 >>> 4;
          }
          return;
        }
        var pix = new Uint16Array(16);
        var row, col, val, max, min, imax, imin, sh, bit, i, dp;
        var data = new Uint8Array(raw_width + 1);
        for (row = 0; row < height; row++) {
          for (var j = 0; j < raw_width; j++) data[j] = inp[off++];
          for (dp = 0, col = 0; col < raw_width - 30; dp += 16) {
            max = 2047 & (val = bin.readUint(data, dp));
            min = 2047 & val >>> 11;
            imax = 15 & val >>> 22;
            imin = 15 & val >>> 26;
            for (sh = 0; sh < 4 && 128 << sh <= max - min; sh++) ;
            for (bit = 30, i = 0; i < 16; i++)
              if (i == imax) pix[i] = max;
              else if (i == imin) pix[i] = min;
              else {
                pix[i] = ((bin.readUshort(data, dp + (bit >> 3)) >>> (bit & 7) & 127) << sh) + min;
                if (pix[i] > 2047) pix[i] = 2047;
                bit += 7;
              }
            for (i = 0; i < 16; i++, col += 2) {
              var clr = pix[i] << 1;
              UTIF22.decode._putsF(tgt, (row * raw_width + col) * tiff_bps, clr << 16 - tiff_bps);
            }
            col -= col & 1 ? 1 : 31;
          }
        }
      };
      UTIF22.decode._decodeNikon = function(img, imgs, data, off, src_length, tgt, toff) {
        var nikon_tree = [
          [
            0,
            0,
            1,
            5,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            /* 12-bit lossy */
            5,
            4,
            3,
            6,
            2,
            7,
            1,
            0,
            8,
            9,
            11,
            10,
            12
          ],
          [
            0,
            0,
            1,
            5,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            /* 12-bit lossy after split */
            57,
            90,
            56,
            39,
            22,
            5,
            4,
            3,
            2,
            1,
            0,
            11,
            12,
            12
          ],
          [
            0,
            0,
            1,
            4,
            2,
            3,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            /* 12-bit lossless */
            5,
            4,
            6,
            3,
            7,
            2,
            8,
            1,
            9,
            0,
            10,
            11,
            12
          ],
          [
            0,
            0,
            1,
            4,
            3,
            1,
            1,
            1,
            1,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            /* 14-bit lossy */
            5,
            6,
            4,
            7,
            8,
            3,
            9,
            2,
            1,
            0,
            10,
            11,
            12,
            13,
            14
          ],
          [
            0,
            0,
            1,
            5,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            /* 14-bit lossy after split */
            8,
            92,
            75,
            58,
            41,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            0,
            13,
            14
          ],
          [
            0,
            0,
            1,
            4,
            2,
            2,
            3,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            /* 14-bit lossless */
            7,
            6,
            8,
            5,
            9,
            4,
            10,
            3,
            11,
            12,
            2,
            0,
            1,
            13,
            14
          ]
        ];
        var raw_width = img["t256"][0], height = img["t257"][0], tiff_bps = img["t258"][0];
        var tree = 0, split = 0;
        var make_decoder = UTIF22.decode._make_decoder;
        var getbithuff = UTIF22.decode._getbithuff;
        var mn = imgs[0].exifIFD.makerNote, md = mn["t150"] ? mn["t150"] : mn["t140"], mdo = 0;
        var ver0 = md[mdo++], ver1 = md[mdo++];
        if (ver0 == 73 || ver1 == 88) mdo += 2110;
        if (ver0 == 70) tree = 2;
        if (tiff_bps == 14) tree += 3;
        var vpred = [[0, 0], [0, 0]], bin = img.isLE ? UTIF22._binLE : UTIF22._binBE;
        for (var i = 0; i < 2; i++) for (var j = 0; j < 2; j++) {
          vpred[i][j] = bin.readShort(md, mdo);
          mdo += 2;
        }
        var max = 1 << tiff_bps & 32767, step = 0;
        var csize = bin.readShort(md, mdo);
        mdo += 2;
        if (csize > 1) step = Math.floor(max / (csize - 1));
        if (ver0 == 68 && ver1 == 32 && step > 0) split = bin.readShort(md, 562);
        var i;
        var row, col;
        var len, shl, diff;
        var hpred = [0, 0];
        var huff = make_decoder(nikon_tree[tree]);
        var prm = [off, 0, 0, 0];
        for (row = 0; row < height; row++) {
          if (split && row == split) {
            huff = make_decoder(nikon_tree[tree + 1]);
          }
          for (col = 0; col < raw_width; col++) {
            i = getbithuff(data, prm, huff[0], huff);
            len = i & 15;
            shl = i >>> 4;
            diff = (getbithuff(data, prm, len - shl, 0) << 1) + 1 << shl >>> 1;
            if ((diff & 1 << len - 1) == 0)
              diff -= (1 << len) - (shl == 0 ? 1 : 0);
            if (col < 2) hpred[col] = vpred[row & 1][col] += diff;
            else hpred[col & 1] += diff;
            var clr = Math.min(Math.max(hpred[col & 1], 0), (1 << tiff_bps) - 1);
            var bti = (row * raw_width + col) * tiff_bps;
            UTIF22.decode._putsF(tgt, bti, clr << 16 - tiff_bps);
          }
        }
      };
      UTIF22.decode._putsF = function(dt, pos, val) {
        val = val << 8 - (pos & 7);
        var o = pos >>> 3;
        dt[o] |= val >>> 16;
        dt[o + 1] |= val >>> 8;
        dt[o + 2] |= val;
      };
      UTIF22.decode._getbithuff = function(data, prm, nbits, huff) {
        var zero_after_ff = 0;
        UTIF22.decode._get_byte;
        var c2;
        var off = prm[0], bitbuf = prm[1], vbits = prm[2], reset = prm[3];
        if (nbits == 0 || vbits < 0) return 0;
        while (!reset && vbits < nbits && (c2 = data[off++]) != -1 && !(reset = zero_after_ff)) {
          bitbuf = (bitbuf << 8) + c2;
          vbits += 8;
        }
        c2 = bitbuf << 32 - vbits >>> 32 - nbits;
        if (huff) {
          vbits -= huff[c2 + 1] >>> 8;
          c2 = huff[c2 + 1] & 255;
        } else
          vbits -= nbits;
        if (vbits < 0) throw "e";
        prm[0] = off;
        prm[1] = bitbuf;
        prm[2] = vbits;
        prm[3] = reset;
        return c2;
      };
      UTIF22.decode._make_decoder = function(source) {
        var max, len, h, i, j;
        var huff = [];
        for (max = 16; max != 0 && !source[max]; max--) ;
        var si = 17;
        huff[0] = max;
        for (h = len = 1; len <= max; len++)
          for (i = 0; i < source[len]; i++, ++si)
            for (j = 0; j < 1 << max - len; j++)
              if (h <= 1 << max)
                huff[h++] = len << 8 | source[si];
        return huff;
      };
      UTIF22.decode._decodeNewJPEG = function(img, data, off, len, tgt, toff) {
        len = Math.min(len, data.length - off);
        var tables = img["t347"], tlen = tables ? tables.length : 0, buff = new Uint8Array(tlen + len);
        if (tables) {
          var SOI = 216, EOI2 = 217, boff = 0;
          for (var i = 0; i < tlen - 1; i++) {
            if (tables[i] == 255 && tables[i + 1] == EOI2) break;
            buff[boff++] = tables[i];
          }
          var byte1 = data[off], byte2 = data[off + 1];
          if (byte1 != 255 || byte2 != SOI) {
            buff[boff++] = byte1;
            buff[boff++] = byte2;
          }
          for (var i = 2; i < len; i++) buff[boff++] = data[off + i];
        } else for (var i = 0; i < len; i++) buff[i] = data[off + i];
        if (img["t262"][0] == 32803 || img["t259"][0] == 7 && img["t262"][0] == 34892) {
          var bps = img["t258"][0];
          var out = UTIF22.LosslessJpegDecode(buff), olen = out.length;
          if (bps == 16) {
            if (img.isLE) for (var i = 0; i < olen; i++) {
              tgt[toff + (i << 1)] = out[i] & 255;
              tgt[toff + (i << 1) + 1] = out[i] >>> 8;
            }
            else for (var i = 0; i < olen; i++) {
              tgt[toff + (i << 1)] = out[i] >>> 8;
              tgt[toff + (i << 1) + 1] = out[i] & 255;
            }
          } else if (bps == 14 || bps == 12 || bps == 10) {
            var rst = 16 - bps;
            for (var i = 0; i < olen; i++) UTIF22.decode._putsF(tgt, i * bps, out[i] << rst);
          } else if (bps == 8) {
            for (var i = 0; i < olen; i++) tgt[toff + i] = out[i];
          } else throw new Error("unsupported bit depth " + bps);
        } else {
          var parser2 = new UTIF22.JpegDecoder();
          parser2.parse(buff);
          var decoded = parser2.getData({ "width": parser2.width, "height": parser2.height, "forceRGB": true, "isSourcePDF": false });
          for (var i = 0; i < decoded.length; i++) tgt[toff + i] = decoded[i];
        }
        if (img["t262"][0] == 6) img["t262"][0] = 2;
      };
      UTIF22.decode._decodeOldJPEGInit = function(img, data, off, len) {
        var SOI = 216, DQT = 219, DHT = 196, DRI = 221, SOF0 = 192, SOS2 = 218;
        var joff = 0, soff = 0, tables, sosMarker2, isTiled = false, i, j, k;
        var jpgIchgFmt = img["t513"], jifoff = jpgIchgFmt ? jpgIchgFmt[0] : 0;
        var jpgIchgFmtLen = img["t514"], jiflen = jpgIchgFmtLen ? jpgIchgFmtLen[0] : 0;
        var soffTag = img["t324"] || img["t273"] || jpgIchgFmt;
        var ycbcrss = img["t530"], ssx = 0, ssy = 0;
        var spp = img["t277"] ? img["t277"][0] : 1;
        var jpgresint = img["t515"];
        if (soffTag) {
          soff = soffTag[0];
          isTiled = soffTag.length > 1;
        }
        if (!isTiled) {
          if (data[off] == 255 && data[off + 1] == SOI) return { jpegOffset: off };
          if (jpgIchgFmt != null) {
            if (data[off + jifoff] == 255 && data[off + jifoff + 1] == SOI) joff = off + jifoff;
            else log("JPEGInterchangeFormat does not point to SOI");
            if (jpgIchgFmtLen == null) log("JPEGInterchangeFormatLength field is missing");
            else if (jifoff >= soff || jifoff + jiflen <= soff) log("JPEGInterchangeFormatLength field value is invalid");
            if (joff != null) return { jpegOffset: joff };
          }
        }
        if (ycbcrss != null) {
          ssx = ycbcrss[0];
          ssy = ycbcrss[1];
        }
        if (jpgIchgFmt != null) {
          if (jpgIchgFmtLen != null)
            if (jiflen >= 2 && jifoff + jiflen <= soff) {
              if (data[off + jifoff + jiflen - 2] == 255 && data[off + jifoff + jiflen - 1] == SOI) tables = new Uint8Array(jiflen - 2);
              else tables = new Uint8Array(jiflen);
              for (i = 0; i < tables.length; i++) tables[i] = data[off + jifoff + i];
              log("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
            } else log("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
        }
        if (tables == null) {
          var ooff = 0, out = [];
          out[ooff++] = 255;
          out[ooff++] = SOI;
          var qtables = img["t519"];
          if (qtables == null) throw new Error("JPEGQTables tag is missing");
          for (i = 0; i < qtables.length; i++) {
            out[ooff++] = 255;
            out[ooff++] = DQT;
            out[ooff++] = 0;
            out[ooff++] = 67;
            out[ooff++] = i;
            for (j = 0; j < 64; j++) out[ooff++] = data[off + qtables[i] + j];
          }
          for (k = 0; k < 2; k++) {
            var htables = img[k == 0 ? "t520" : "t521"];
            if (htables == null) throw new Error((k == 0 ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
            for (i = 0; i < htables.length; i++) {
              out[ooff++] = 255;
              out[ooff++] = DHT;
              var nc = 19;
              for (j = 0; j < 16; j++) nc += data[off + htables[i] + j];
              out[ooff++] = nc >>> 8;
              out[ooff++] = nc & 255;
              out[ooff++] = i | k << 4;
              for (j = 0; j < 16; j++) out[ooff++] = data[off + htables[i] + j];
              for (j = 0; j < nc; j++) out[ooff++] = data[off + htables[i] + 16 + j];
            }
          }
          out[ooff++] = 255;
          out[ooff++] = SOF0;
          out[ooff++] = 0;
          out[ooff++] = 8 + 3 * spp;
          out[ooff++] = 8;
          out[ooff++] = img.height >>> 8 & 255;
          out[ooff++] = img.height & 255;
          out[ooff++] = img.width >>> 8 & 255;
          out[ooff++] = img.width & 255;
          out[ooff++] = spp;
          if (spp == 1) {
            out[ooff++] = 1;
            out[ooff++] = 17;
            out[ooff++] = 0;
          } else for (i = 0; i < 3; i++) {
            out[ooff++] = i + 1;
            out[ooff++] = i != 0 ? 17 : (ssx & 15) << 4 | ssy & 15;
            out[ooff++] = i;
          }
          if (jpgresint != null && jpgresint[0] != 0) {
            out[ooff++] = 255;
            out[ooff++] = DRI;
            out[ooff++] = 0;
            out[ooff++] = 4;
            out[ooff++] = jpgresint[0] >>> 8 & 255;
            out[ooff++] = jpgresint[0] & 255;
          }
          tables = new Uint8Array(out);
        }
        var sofpos = -1;
        i = 0;
        while (i < tables.length - 1) {
          if (tables[i] == 255 && tables[i + 1] == SOF0) {
            sofpos = i;
            break;
          }
          i++;
        }
        if (sofpos == -1) {
          var tmptab = new Uint8Array(tables.length + 10 + 3 * spp);
          tmptab.set(tables);
          var tmpoff = tables.length;
          sofpos = tables.length;
          tables = tmptab;
          tables[tmpoff++] = 255;
          tables[tmpoff++] = SOF0;
          tables[tmpoff++] = 0;
          tables[tmpoff++] = 8 + 3 * spp;
          tables[tmpoff++] = 8;
          tables[tmpoff++] = img.height >>> 8 & 255;
          tables[tmpoff++] = img.height & 255;
          tables[tmpoff++] = img.width >>> 8 & 255;
          tables[tmpoff++] = img.width & 255;
          tables[tmpoff++] = spp;
          if (spp == 1) {
            tables[tmpoff++] = 1;
            tables[tmpoff++] = 17;
            tables[tmpoff++] = 0;
          } else for (i = 0; i < 3; i++) {
            tables[tmpoff++] = i + 1;
            tables[tmpoff++] = i != 0 ? 17 : (ssx & 15) << 4 | ssy & 15;
            tables[tmpoff++] = i;
          }
        }
        if (data[soff] == 255 && data[soff + 1] == SOS2) {
          var soslen = data[soff + 2] << 8 | data[soff + 3];
          sosMarker2 = new Uint8Array(soslen + 2);
          sosMarker2[0] = data[soff];
          sosMarker2[1] = data[soff + 1];
          sosMarker2[2] = data[soff + 2];
          sosMarker2[3] = data[soff + 3];
          for (i = 0; i < soslen - 2; i++) sosMarker2[i + 4] = data[soff + i + 4];
        } else {
          sosMarker2 = new Uint8Array(2 + 6 + 2 * spp);
          var sosoff = 0;
          sosMarker2[sosoff++] = 255;
          sosMarker2[sosoff++] = SOS2;
          sosMarker2[sosoff++] = 0;
          sosMarker2[sosoff++] = 6 + 2 * spp;
          sosMarker2[sosoff++] = spp;
          if (spp == 1) {
            sosMarker2[sosoff++] = 1;
            sosMarker2[sosoff++] = 0;
          } else for (i = 0; i < 3; i++) {
            sosMarker2[sosoff++] = i + 1;
            sosMarker2[sosoff++] = i << 4 | i;
          }
          sosMarker2[sosoff++] = 0;
          sosMarker2[sosoff++] = 63;
          sosMarker2[sosoff++] = 0;
        }
        return { jpegOffset: off, tables, sosMarker: sosMarker2, sofPosition: sofpos };
      };
      UTIF22.decode._decodeOldJPEG = function(img, data, off, len, tgt, toff) {
        var i, dlen, tlen, buff, buffoff;
        var jpegData = UTIF22.decode._decodeOldJPEGInit(img, data, off, len);
        if (jpegData.jpegOffset != null) {
          dlen = off + len - jpegData.jpegOffset;
          buff = new Uint8Array(dlen);
          for (i = 0; i < dlen; i++) buff[i] = data[jpegData.jpegOffset + i];
        } else {
          tlen = jpegData.tables.length;
          buff = new Uint8Array(tlen + jpegData.sosMarker.length + len + 2);
          buff.set(jpegData.tables);
          buffoff = tlen;
          buff[jpegData.sofPosition + 5] = img.height >>> 8 & 255;
          buff[jpegData.sofPosition + 6] = img.height & 255;
          buff[jpegData.sofPosition + 7] = img.width >>> 8 & 255;
          buff[jpegData.sofPosition + 8] = img.width & 255;
          if (data[off] != 255 || data[off + 1] != SOS) {
            buff.set(jpegData.sosMarker, buffoff);
            buffoff += sosMarker.length;
          }
          for (i = 0; i < len; i++) buff[buffoff++] = data[off + i];
          buff[buffoff++] = 255;
          buff[buffoff++] = EOI;
        }
        var parser2 = new UTIF22.JpegDecoder();
        parser2.parse(buff);
        var decoded = parser2.getData({ "width": parser2.width, "height": parser2.height, "forceRGB": true, "isSourcePDF": false });
        for (var i = 0; i < decoded.length; i++) tgt[toff + i] = decoded[i];
        if (img["t262"] && img["t262"][0] == 6) img["t262"][0] = 2;
      };
      UTIF22.decode._decodePackBits = function(data, off, len, tgt, toff) {
        var sa = new Int8Array(data.buffer), ta = new Int8Array(tgt.buffer), lim = off + len;
        while (off < lim) {
          var n = sa[off];
          off++;
          if (n >= 0 && n < 128) for (var i = 0; i < n + 1; i++) {
            ta[toff] = sa[off];
            toff++;
            off++;
          }
          if (n >= -127 && n < 0) {
            for (var i = 0; i < -n + 1; i++) {
              ta[toff] = sa[off];
              toff++;
            }
            off++;
          }
        }
        return toff;
      };
      UTIF22.decode._decodeThunder = function(data, off, len, tgt, toff) {
        var d2 = [0, 1, 0, -1], d3 = [0, 1, 2, 3, 0, -3, -2, -1];
        var lim = off + len, qoff = toff * 2, px = 0;
        while (off < lim) {
          var b = data[off], msk = b >>> 6, n = b & 63;
          off++;
          if (msk == 3) {
            px = n & 15;
            tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
            qoff++;
          }
          if (msk == 0) for (var i = 0; i < n; i++) {
            tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
            qoff++;
          }
          if (msk == 2) for (var i = 0; i < 2; i++) {
            var d = n >>> 3 * (1 - i) & 7;
            if (d != 4) {
              px += d3[d];
              tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
              qoff++;
            }
          }
          if (msk == 1) for (var i = 0; i < 3; i++) {
            var d = n >>> 2 * (2 - i) & 3;
            if (d != 2) {
              px += d2[d];
              tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
              qoff++;
            }
          }
        }
      };
      UTIF22.decode._dmap = { "1": 0, "011": 1, "000011": 2, "0000011": 3, "010": -1, "000010": -2, "0000010": -3 };
      UTIF22.decode._lens = function() {
        var addKeys = function(lens, arr, i0, inc) {
          for (var i = 0; i < arr.length; i++) lens[arr[i]] = i0 + i * inc;
        };
        var termW = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100";
        var termB = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111";
        var makeW = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011";
        var makeB = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101";
        var makeA = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
        termW = termW.split(",");
        termB = termB.split(",");
        makeW = makeW.split(",");
        makeB = makeB.split(",");
        makeA = makeA.split(",");
        var lensW = {}, lensB = {};
        addKeys(lensW, termW, 0, 1);
        addKeys(lensW, makeW, 64, 64);
        addKeys(lensW, makeA, 1792, 64);
        addKeys(lensB, termB, 0, 1);
        addKeys(lensB, makeB, 64, 64);
        addKeys(lensB, makeA, 1792, 64);
        return [lensW, lensB];
      }();
      UTIF22.decode._decodeG4 = function(data, off, slen, tgt, toff, w, fo) {
        var U = UTIF22.decode, boff = off << 3, len = 0, wrd = "";
        var line = [], pline = [];
        for (var i = 0; i < w; i++) pline.push(0);
        pline = U._makeDiff(pline);
        var a0 = 0, a1 = 0, b1 = 0, b2 = 0, clr = 0;
        var y2 = 0, mode = "", toRead = 0;
        var bipl = Math.ceil(w / 8) * 8;
        while (boff >>> 3 < off + slen) {
          b1 = U._findDiff(pline, a0 + (a0 == 0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr);
          var bit = 0;
          if (fo == 1) bit = data[boff >>> 3] >>> 7 - (boff & 7) & 1;
          if (fo == 2) bit = data[boff >>> 3] >>> (boff & 7) & 1;
          boff++;
          wrd += bit;
          if (mode == "H") {
            if (U._lens[clr][wrd] != null) {
              var dl = U._lens[clr][wrd];
              wrd = "";
              len += dl;
              if (dl < 64) {
                U._addNtimes(line, len, clr);
                a0 += len;
                clr = 1 - clr;
                len = 0;
                toRead--;
                if (toRead == 0) mode = "";
              }
            }
          } else {
            if (wrd == "0001") {
              wrd = "";
              U._addNtimes(line, b2 - a0, clr);
              a0 = b2;
            }
            if (wrd == "001") {
              wrd = "";
              mode = "H";
              toRead = 2;
            }
            if (U._dmap[wrd] != null) {
              a1 = b1 + U._dmap[wrd];
              U._addNtimes(line, a1 - a0, clr);
              a0 = a1;
              wrd = "";
              clr = 1 - clr;
            }
          }
          if (line.length == w && mode == "") {
            U._writeBits(line, tgt, toff * 8 + y2 * bipl);
            clr = 0;
            y2++;
            a0 = 0;
            pline = U._makeDiff(line);
            line = [];
          }
        }
      };
      UTIF22.decode._findDiff = function(line, x2, clr) {
        for (var i = 0; i < line.length; i += 2) if (line[i] >= x2 && line[i + 1] == clr) return line[i];
      };
      UTIF22.decode._makeDiff = function(line) {
        var out = [];
        if (line[0] == 1) out.push(0, 1);
        for (var i = 1; i < line.length; i++) if (line[i - 1] != line[i]) out.push(i, line[i]);
        out.push(line.length, 0, line.length, 1);
        return out;
      };
      UTIF22.decode._decodeG2 = function(data, off, slen, tgt, toff, w, fo) {
        var U = UTIF22.decode, boff = off << 3, len = 0, wrd = "";
        var line = [];
        var clr = 0;
        var y2 = 0;
        var bipl = Math.ceil(w / 8) * 8;
        while (boff >>> 3 < off + slen) {
          var bit = 0;
          if (fo == 1) bit = data[boff >>> 3] >>> 7 - (boff & 7) & 1;
          if (fo == 2) bit = data[boff >>> 3] >>> (boff & 7) & 1;
          boff++;
          wrd += bit;
          len = U._lens[clr][wrd];
          if (len != null) {
            U._addNtimes(line, len, clr);
            wrd = "";
            if (len < 64) clr = 1 - clr;
            if (line.length == w) {
              U._writeBits(line, tgt, toff * 8 + y2 * bipl);
              line = [];
              y2++;
              clr = 0;
              if ((boff & 7) != 0) boff += 8 - (boff & 7);
              if (len >= 64) boff += 8;
            }
          }
        }
      };
      UTIF22.decode._decodeG3 = function(data, off, slen, tgt, toff, w, fo, twoDim) {
        var U = UTIF22.decode, boff = off << 3, len = 0, wrd = "";
        var line = [], pline = [];
        for (var i = 0; i < w; i++) line.push(0);
        var a0 = 0, a1 = 0, b1 = 0, b2 = 0, clr = 0;
        var y2 = -1, mode = "", toRead = 0, is1D = true;
        var bipl = Math.ceil(w / 8) * 8;
        while (boff >>> 3 < off + slen) {
          b1 = U._findDiff(pline, a0 + (a0 == 0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr);
          var bit = 0;
          if (fo == 1) bit = data[boff >>> 3] >>> 7 - (boff & 7) & 1;
          if (fo == 2) bit = data[boff >>> 3] >>> (boff & 7) & 1;
          boff++;
          wrd += bit;
          if (is1D) {
            if (U._lens[clr][wrd] != null) {
              var dl = U._lens[clr][wrd];
              wrd = "";
              len += dl;
              if (dl < 64) {
                U._addNtimes(line, len, clr);
                clr = 1 - clr;
                len = 0;
              }
            }
          } else {
            if (mode == "H") {
              if (U._lens[clr][wrd] != null) {
                var dl = U._lens[clr][wrd];
                wrd = "";
                len += dl;
                if (dl < 64) {
                  U._addNtimes(line, len, clr);
                  a0 += len;
                  clr = 1 - clr;
                  len = 0;
                  toRead--;
                  if (toRead == 0) mode = "";
                }
              }
            } else {
              if (wrd == "0001") {
                wrd = "";
                U._addNtimes(line, b2 - a0, clr);
                a0 = b2;
              }
              if (wrd == "001") {
                wrd = "";
                mode = "H";
                toRead = 2;
              }
              if (U._dmap[wrd] != null) {
                a1 = b1 + U._dmap[wrd];
                U._addNtimes(line, a1 - a0, clr);
                a0 = a1;
                wrd = "";
                clr = 1 - clr;
              }
            }
          }
          if (wrd.endsWith("000000000001")) {
            if (y2 >= 0) U._writeBits(line, tgt, toff * 8 + y2 * bipl);
            if (twoDim) {
              if (fo == 1) is1D = (data[boff >>> 3] >>> 7 - (boff & 7) & 1) == 1;
              if (fo == 2) is1D = (data[boff >>> 3] >>> (boff & 7) & 1) == 1;
              boff++;
            }
            wrd = "";
            clr = 0;
            y2++;
            a0 = 0;
            pline = U._makeDiff(line);
            line = [];
          }
        }
        if (line.length == w) U._writeBits(line, tgt, toff * 8 + y2 * bipl);
      };
      UTIF22.decode._addNtimes = function(arr, n, val) {
        for (var i = 0; i < n; i++) arr.push(val);
      };
      UTIF22.decode._writeBits = function(bits, tgt, boff) {
        for (var i = 0; i < bits.length; i++) tgt[boff + i >>> 3] |= bits[i] << 7 - (boff + i & 7);
      };
      UTIF22.decode._decodeLZW = UTIF22.decode._decodeLZW = function() {
        var e, U, Z, u, K = 0, V = 0, g = 0, N = 0, O = function() {
          var S = e >>> 3, A = U[S] << 16 | U[S + 1] << 8 | U[S + 2], j = A >>> 24 - (e & 7) - V & (1 << V) - 1;
          e += V;
          return j;
        }, h = new Uint32Array(4096 * 4), w = 0, m = function(S) {
          if (S == w) return;
          w = S;
          g = 1 << S;
          N = g + 1;
          for (var A = 0; A < N + 1; A++) {
            h[4 * A] = h[4 * A + 3] = A;
            h[4 * A + 1] = 65535;
            h[4 * A + 2] = 1;
          }
        }, i = function(S) {
          V = S + 1;
          K = N + 1;
        }, D = function(S) {
          var A = S << 2, j = h[A + 2], a = u + j - 1;
          while (A != 65535) {
            Z[a--] = h[A];
            A = h[A + 1];
          }
          u += j;
        }, L = function(S, A) {
          var j = K << 2, a = S << 2;
          h[j] = h[(A << 2) + 3];
          h[j + 1] = a;
          h[j + 2] = h[a + 2] + 1;
          h[j + 3] = h[a + 3];
          K++;
          if (K + 1 == 1 << V && V != 12) V++;
        }, T = function(S, A, j, a, n, q) {
          e = A << 3;
          U = S;
          Z = a;
          u = n;
          var B = A + j << 3, _ = 0, t = 0;
          m(q);
          i(q);
          while (e < B && (_ = O()) != N) {
            if (_ == g) {
              i(q);
              _ = O();
              if (_ == N) break;
              D(_);
            } else {
              if (_ < K) {
                D(_);
                L(t, _);
              } else {
                L(t, t);
                D(K - 1);
              }
            }
            t = _;
          }
          return u;
        };
        return T;
      }();
      UTIF22.tags = {};
      UTIF22._types = function() {
        var main = new Array(250);
        main.fill(0);
        main = main.concat([0, 0, 0, 0, 4, 3, 3, 3, 3, 3, 0, 0, 3, 0, 0, 0, 3, 0, 0, 2, 2, 2, 2, 4, 3, 0, 0, 3, 4, 4, 3, 3, 5, 5, 3, 2, 5, 5, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 5, 5, 3, 0, 3, 3, 4, 4, 4, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        var rest = { 33432: 2, 33434: 5, 33437: 5, 34665: 4, 34850: 3, 34853: 4, 34855: 3, 34864: 3, 34866: 4, 36864: 7, 36867: 2, 36868: 2, 37121: 7, 37377: 10, 37378: 5, 37380: 10, 37381: 5, 37383: 3, 37384: 3, 37385: 3, 37386: 5, 37510: 7, 37520: 2, 37521: 2, 37522: 2, 40960: 7, 40961: 3, 40962: 4, 40963: 4, 40965: 4, 41486: 5, 41487: 5, 41488: 3, 41985: 3, 41986: 3, 41987: 3, 41988: 5, 41989: 3, 41990: 3, 41993: 3, 41994: 3, 41995: 7, 41996: 3, 42032: 2, 42033: 2, 42034: 5, 42036: 2, 42037: 2, 59932: 7 };
        return {
          basic: {
            main,
            rest
          },
          gps: {
            main: [1, 2, 5, 2, 5, 1, 5, 5, 0, 9],
            rest: { 18: 2, 29: 2 }
          }
        };
      }();
      UTIF22._readIFD = function(bin, data, offset, ifds, depth, prm) {
        var cnt = bin.readUshort(data, offset);
        offset += 2;
        var ifd = {};
        if (prm.debug) log("   ".repeat(depth), ifds.length - 1, ">>>----------------");
        for (var i = 0; i < cnt; i++) {
          var tag = bin.readUshort(data, offset);
          offset += 2;
          var type = bin.readUshort(data, offset);
          offset += 2;
          var num = bin.readUint(data, offset);
          offset += 4;
          var voff = bin.readUint(data, offset);
          offset += 4;
          var arr = [];
          if (type == 1 || type == 7) {
            var no = num < 5 ? offset - 4 : voff;
            if (no + num > data.buffer.byteLength) num = data.buffer.byteLength - no;
            arr = new Uint8Array(data.buffer, no, num);
          }
          if (type == 2) {
            var o0 = num < 5 ? offset - 4 : voff, c2 = data[o0], len = Math.max(0, Math.min(num - 1, data.length - o0));
            if (c2 < 128 || len == 0) arr.push(bin.readASCII(data, o0, len));
            else arr = new Uint8Array(data.buffer, o0, len);
          }
          if (type == 3) {
            for (var j = 0; j < num; j++) arr.push(bin.readUshort(data, (num < 3 ? offset - 4 : voff) + 2 * j));
          }
          if (type == 4 || type == 13) {
            for (var j = 0; j < num; j++) arr.push(bin.readUint(data, (num < 2 ? offset - 4 : voff) + 4 * j));
          }
          if (type == 5 || type == 10) {
            var ri = type == 5 ? bin.readUint : bin.readInt;
            for (var j = 0; j < num; j++) arr.push([ri(data, voff + j * 8), ri(data, voff + j * 8 + 4)]);
          }
          if (type == 8) {
            for (var j = 0; j < num; j++) arr.push(bin.readShort(data, (num < 3 ? offset - 4 : voff) + 2 * j));
          }
          if (type == 9) {
            for (var j = 0; j < num; j++) arr.push(bin.readInt(data, (num < 2 ? offset - 4 : voff) + 4 * j));
          }
          if (type == 11) {
            for (var j = 0; j < num; j++) arr.push(bin.readFloat(data, voff + j * 4));
          }
          if (type == 12) {
            for (var j = 0; j < num; j++) arr.push(bin.readDouble(data, voff + j * 8));
          }
          if (num != 0 && arr.length == 0) {
            log(tag, "unknown TIFF tag type: ", type, "num:", num);
            if (i == 0) return;
            continue;
          }
          if (prm.debug) log("   ".repeat(depth), tag, type, UTIF22.tags[tag], arr);
          ifd["t" + tag] = arr;
          if (tag == 330 && ifd["t272"] && ifd["t272"][0] == "DSLR-A100") ;
          else if (tag == 330 || tag == 34665 || tag == 34853 || tag == 50740 && bin.readUshort(data, bin.readUint(arr, 0)) < 300 || tag == 61440) {
            var oarr = tag == 50740 ? [bin.readUint(arr, 0)] : arr;
            var subfd = [];
            for (var j = 0; j < oarr.length; j++) UTIF22._readIFD(bin, data, oarr[j], subfd, depth + 1, prm);
            if (tag == 330) ifd.subIFD = subfd;
            if (tag == 34665) ifd.exifIFD = subfd[0];
            if (tag == 34853) ifd.gpsiIFD = subfd[0];
            if (tag == 50740) ifd.dngPrvt = subfd[0];
            if (tag == 61440) ifd.fujiIFD = subfd[0];
          }
          if (tag == 37500 && prm.parseMN) {
            var mn = arr;
            if (bin.readASCII(mn, 0, 5) == "Nikon") ifd.makerNote = UTIF22["decode"](mn.slice(10).buffer)[0];
            else if (bin.readASCII(mn, 0, 5) == "OLYMP" || bin.readASCII(mn, 0, 9) == "OM SYSTEM") {
              var inds = [8208, 8224, 8240, 8256, 8272];
              var subsub = [];
              UTIF22._readIFD(bin, mn, mn[1] == 77 ? 16 : mn[5] == 85 ? 12 : 8, subsub, depth + 1, prm);
              var obj = ifd.makerNote = subsub.pop();
              for (var j = 0; j < inds.length; j++) {
                var k = "t" + inds[j];
                if (obj[k] == null) continue;
                UTIF22._readIFD(bin, mn, obj[k][0], subsub, depth + 1, prm);
                obj[k] = subsub.pop();
              }
              if (obj["t12288"]) {
                UTIF22._readIFD(bin, obj["t12288"], 0, subsub, depth + 1, prm);
                obj["t12288"] = subsub.pop();
              }
            } else if (bin.readUshort(data, voff) < 300 && bin.readUshort(data, voff + 4) <= 12) {
              var subsub = [];
              UTIF22._readIFD(bin, data, voff, subsub, depth + 1, prm);
              ifd.makerNote = subsub[0];
            }
          }
        }
        ifds.push(ifd);
        if (prm.debug) log("   ".repeat(depth), "<<<---------------");
        return offset;
      };
      UTIF22._writeIFD = function(bin, types, data, offset, ifd) {
        var keys = Object.keys(ifd), knum = keys.length;
        if (ifd["exifIFD"]) knum--;
        if (ifd["gpsiIFD"]) knum--;
        bin.writeUshort(data, offset, knum);
        offset += 2;
        var eoff = offset + knum * 12 + 4;
        for (var ki = 0; ki < keys.length; ki++) {
          var key = keys[ki];
          if (key == "t34665" || key == "t34853") continue;
          if (key == "exifIFD") key = "t34665";
          if (key == "gpsiIFD") key = "t34853";
          var tag = parseInt(key.slice(1)), type = types.main[tag];
          if (type == null) type = types.rest[tag];
          if (type == null || type == 0) throw new Error("unknown type of tag: " + tag);
          var val = ifd[key];
          if (tag == 34665) {
            var outp = UTIF22._writeIFD(bin, types, data, eoff, ifd["exifIFD"]);
            val = [eoff];
            eoff = outp[1];
          }
          if (tag == 34853) {
            var outp = UTIF22._writeIFD(bin, UTIF22._types.gps, data, eoff, ifd["gpsiIFD"]);
            val = [eoff];
            eoff = outp[1];
          }
          if (type == 2) val = val[0] + "\0";
          var num = val.length;
          bin.writeUshort(data, offset, tag);
          offset += 2;
          bin.writeUshort(data, offset, type);
          offset += 2;
          bin.writeUint(data, offset, num);
          offset += 4;
          var dlen = [-1, 1, 1, 2, 4, 8, 0, 1, 0, 4, 8, 0, 8][type] * num;
          var toff = offset;
          if (dlen > 4) {
            bin.writeUint(data, offset, eoff);
            toff = eoff;
          }
          if (type == 1 || type == 7) {
            for (var i = 0; i < num; i++) data[toff + i] = val[i];
          } else if (type == 2) {
            bin.writeASCII(data, toff, val);
          } else if (type == 3) {
            for (var i = 0; i < num; i++) bin.writeUshort(data, toff + 2 * i, val[i]);
          } else if (type == 4) {
            for (var i = 0; i < num; i++) bin.writeUint(data, toff + 4 * i, val[i]);
          } else if (type == 5 || type == 10) {
            var wr = type == 5 ? bin.writeUint : bin.writeInt;
            for (var i = 0; i < num; i++) {
              var v = val[i], nu = v[0], de = v[1];
              if (nu == null) throw "e";
              wr(data, toff + 8 * i, nu);
              wr(data, toff + 8 * i + 4, de);
            }
          } else if (type == 9) {
            for (var i = 0; i < num; i++) bin.writeInt(data, toff + 4 * i, val[i]);
          } else if (type == 12) {
            for (var i = 0; i < num; i++) bin.writeDouble(data, toff + 8 * i, val[i]);
          } else throw type;
          if (dlen > 4) {
            dlen += dlen & 1;
            eoff += dlen;
          }
          offset += 4;
        }
        return [offset, eoff];
      };
      UTIF22.toRGBA8 = function(out, scl) {
        function gamma(x22) {
          return x22 < 31308e-7 ? 12.92 * x22 : 1.055 * Math.pow(x22, 1 / 2.4) - 0.055;
        }
        var w = out.width, h = out.height, area = w * h, data = out.data;
        var img = new Uint8Array(area * 4);
        var intp = out["t262"] ? out["t262"][0] : 2, bps = out["t258"] ? Math.min(32, out["t258"][0]) : 1;
        if (out["t262"] == null && bps == 1) intp = 0;
        var smpls = out["t277"] ? out["t277"][0] : out["t258"] ? out["t258"].length : [1, 1, 3, 1, 1, 4, 3][intp];
        var sfmt = out["t339"] ? out["t339"][0] : null;
        if (intp == 1 && bps == 32 && sfmt != 3) throw "e";
        var bpl = Math.ceil(smpls * bps * w / 8);
        if (intp == 0) {
          scl = 1 / 256;
          for (var y2 = 0; y2 < h; y2++) {
            var off = y2 * bpl, io = y2 * w;
            if (bps == 1) for (var i = 0; i < w; i++) {
              var qi = io + i << 2, px = data[off + (i >> 3)] >> 7 - (i & 7) & 1;
              img[qi] = img[qi + 1] = img[qi + 2] = (1 - px) * 255;
              img[qi + 3] = 255;
            }
            if (bps == 4) for (var i = 0; i < w; i++) {
              var qi = io + i << 2, px = data[off + (i >> 1)] >> 4 - 4 * (i & 1) & 15;
              img[qi] = img[qi + 1] = img[qi + 2] = (15 - px) * 17;
              img[qi + 3] = 255;
            }
            if (bps == 8) for (var i = 0; i < w; i++) {
              var qi = io + i << 2, px = data[off + i];
              img[qi] = img[qi + 1] = img[qi + 2] = 255 - px;
              img[qi + 3] = 255;
            }
            if (bps == 16) for (var i = 0; i < w; i++) {
              var qi = io + i << 2, o = off + 2 * i, px = data[o + 1] << 8 | data[o];
              img[qi] = img[qi + 1] = img[qi + 2] = Math.min(255, 255 - ~~(px * scl));
              img[qi + 3] = 255;
            }
          }
        } else if (intp == 1) {
          if (scl == null) scl = 1 / 256;
          var f32 = (data.length & 3) == 0 ? new Float32Array(data.buffer) : null;
          for (var y2 = 0; y2 < h; y2++) {
            var off = y2 * bpl, io = y2 * w;
            if (bps == 1) for (var i = 0; i < w; i++) {
              var qi = io + i << 2, px = data[off + (i >> 3)] >> 7 - (i & 7) & 1;
              img[qi] = img[qi + 1] = img[qi + 2] = px * 255;
              img[qi + 3] = 255;
            }
            if (bps == 2) for (var i = 0; i < w; i++) {
              var qi = io + i << 2, px = data[off + (i >> 2)] >> 6 - 2 * (i & 3) & 3;
              img[qi] = img[qi + 1] = img[qi + 2] = px * 85;
              img[qi + 3] = 255;
            }
            if (bps == 8) for (var i = 0; i < w; i++) {
              var qi = io + i << 2, px = data[off + i * smpls];
              img[qi] = img[qi + 1] = img[qi + 2] = px;
              img[qi + 3] = 255;
            }
            if (bps == 16) for (var i = 0; i < w; i++) {
              var qi = io + i << 2, o = off + 2 * i, px = data[o + 1] << 8 | data[o];
              img[qi] = img[qi + 1] = img[qi + 2] = Math.min(255, ~~(px * scl));
              img[qi + 3] = 255;
            }
            if (bps == 32) for (var i = 0; i < w; i++) {
              var qi = io + i << 2, o = (off >>> 2) + i, px = f32[o];
              img[qi] = img[qi + 1] = img[qi + 2] = ~~(0.5 + 255 * px);
              img[qi + 3] = 255;
            }
          }
        } else if (intp == 2) {
          if (bps == 8) {
            if (smpls == 1) for (var i = 0; i < area; i++) {
              img[4 * i] = img[4 * i + 1] = img[4 * i + 2] = data[i];
              img[4 * i + 3] = 255;
            }
            if (smpls == 3) for (var i = 0; i < area; i++) {
              var qi = i << 2, ti = i * 3;
              img[qi] = data[ti];
              img[qi + 1] = data[ti + 1];
              img[qi + 2] = data[ti + 2];
              img[qi + 3] = 255;
            }
            if (smpls >= 4) for (var i = 0; i < area; i++) {
              var qi = i << 2, ti = i * smpls;
              img[qi] = data[ti];
              img[qi + 1] = data[ti + 1];
              img[qi + 2] = data[ti + 2];
              img[qi + 3] = data[ti + 3];
            }
          } else if (bps == 16) {
            if (smpls == 4) for (var i = 0; i < area; i++) {
              var qi = i << 2, ti = i * 8 + 1;
              img[qi] = data[ti];
              img[qi + 1] = data[ti + 2];
              img[qi + 2] = data[ti + 4];
              img[qi + 3] = data[ti + 6];
            }
            if (smpls == 3) for (var i = 0; i < area; i++) {
              var qi = i << 2, ti = i * 6 + 1;
              img[qi] = data[ti];
              img[qi + 1] = data[ti + 2];
              img[qi + 2] = data[ti + 4];
              img[qi + 3] = 255;
            }
          } else if (bps == 32) {
            var ndt = new Float32Array(data.buffer);
            var min = 0;
            for (var i = 0; i < ndt.length; i++) min = Math.min(min, ndt[i]);
            if (min < 0) for (var i = 0; i < data.length; i += 4) {
              var t = data[i];
              data[i] = data[i + 3];
              data[i + 3] = t;
              t = data[i + 1];
              data[i + 1] = data[i + 2];
              data[i + 2] = t;
            }
            var pmap = [];
            for (var i = 0; i < 65536; i++) pmap.push(gamma(i / 65535));
            for (var i = 0; i < ndt.length; i++) {
              var cv = Math.max(0, Math.min(1, ndt[i]));
              ndt[i] = pmap[~~(0.5 + cv * 65535)];
            }
            if (smpls == 3) for (var i = 0; i < area; i++) {
              var qi = i << 2, ti = i * 3;
              img[qi] = ~~(0.5 + ndt[ti] * 255);
              img[qi + 1] = ~~(0.5 + ndt[ti + 1] * 255);
              img[qi + 2] = ~~(0.5 + ndt[ti + 2] * 255);
              img[qi + 3] = 255;
            }
            else if (smpls == 4) for (var i = 0; i < area; i++) {
              var qi = i << 2, ti = i * 4;
              img[qi] = ~~(0.5 + ndt[ti] * 255);
              img[qi + 1] = ~~(0.5 + ndt[ti + 1] * 255);
              img[qi + 2] = ~~(0.5 + ndt[ti + 2] * 255);
              img[qi + 3] = ~~(0.5 + ndt[ti + 3] * 255);
            }
            else throw smpls;
          } else throw bps;
        } else if (intp == 3) {
          var map = out["t320"];
          var cn = 1 << bps;
          var nexta = bps == 8 && smpls > 1 && out["t338"] && out["t338"][0] != 0;
          for (var y2 = 0; y2 < h; y2++)
            for (var x2 = 0; x2 < w; x2++) {
              var i = y2 * w + x2;
              var qi = i << 2, mi = 0;
              var dof = y2 * bpl;
              if (bps == 1) mi = data[dof + (x2 >>> 3)] >>> 7 - (x2 & 7) & 1;
              else if (bps == 2) mi = data[dof + (x2 >>> 2)] >>> 6 - 2 * (x2 & 3) & 3;
              else if (bps == 4) mi = data[dof + (x2 >>> 1)] >>> 4 - 4 * (x2 & 1) & 15;
              else if (bps == 8) mi = data[dof + x2 * smpls];
              else throw bps;
              img[qi] = map[mi] >> 8;
              img[qi + 1] = map[cn + mi] >> 8;
              img[qi + 2] = map[cn + cn + mi] >> 8;
              img[qi + 3] = nexta ? data[dof + x2 * smpls + 1] : 255;
            }
        } else if (intp == 5) {
          var gotAlpha = smpls > 4 ? 1 : 0;
          for (var i = 0; i < area; i++) {
            var qi = i << 2, si = i * smpls;
            if (window.UDOC) {
              var C = data[si], M = data[si + 1], Y2 = data[si + 2], K = data[si + 3];
              var c2 = UDOC.C.cmykToRgb([C * (1 / 255), M * (1 / 255), Y2 * (1 / 255), K * (1 / 255)]);
              img[qi] = ~~(0.5 + 255 * c2[0]);
              img[qi + 1] = ~~(0.5 + 255 * c2[1]);
              img[qi + 2] = ~~(0.5 + 255 * c2[2]);
            } else {
              var C = 255 - data[si], M = 255 - data[si + 1], Y2 = 255 - data[si + 2], K = (255 - data[si + 3]) * (1 / 255);
              img[qi] = ~~(C * K + 0.5);
              img[qi + 1] = ~~(M * K + 0.5);
              img[qi + 2] = ~~(Y2 * K + 0.5);
            }
            img[qi + 3] = 255 * (1 - gotAlpha) + data[si + 4] * gotAlpha;
          }
        } else if (intp == 6 && out["t278"]) {
          var rps = out["t278"][0];
          for (var y2 = 0; y2 < h; y2 += rps) {
            var i = y2 * w, len = rps * w;
            for (var j = 0; j < len; j++) {
              var qi = 4 * (i + j), si = 3 * i + 4 * (j >>> 1);
              var Y2 = data[si + (j & 1)], Cb = data[si + 2] - 128, Cr = data[si + 3] - 128;
              var r = Y2 + ((Cr >> 2) + (Cr >> 3) + (Cr >> 5));
              var g = Y2 - ((Cb >> 2) + (Cb >> 4) + (Cb >> 5)) - ((Cr >> 1) + (Cr >> 3) + (Cr >> 4) + (Cr >> 5));
              var b = Y2 + (Cb + (Cb >> 1) + (Cb >> 2) + (Cb >> 6));
              img[qi] = Math.max(0, Math.min(255, r));
              img[qi + 1] = Math.max(0, Math.min(255, g));
              img[qi + 2] = Math.max(0, Math.min(255, b));
              img[qi + 3] = 255;
            }
          }
        } else if (intp == 32845) {
          for (var y2 = 0; y2 < h; y2++)
            for (var x2 = 0; x2 < w; x2++) {
              var si = (y2 * w + x2) * 6, qi = (y2 * w + x2) * 4;
              var L = data[si + 1] << 8 | data[si];
              var L = Math.pow(2, (L + 0.5) / 256 - 64);
              var u = (data[si + 3] + 0.5) / 410;
              var v = (data[si + 5] + 0.5) / 410;
              var sX = 9 * u / (6 * u - 16 * v + 12);
              var sY = 4 * v / (6 * u - 16 * v + 12);
              var bY = L;
              var X = sX * bY / sY, Y2 = bY, Z = (1 - sX - sY) * bY / sY;
              var r = 2.69 * X - 1.276 * Y2 - 0.414 * Z;
              var g = -1.022 * X + 1.978 * Y2 + 0.044 * Z;
              var b = 0.061 * X - 0.224 * Y2 + 1.163 * Z;
              img[qi] = gamma(Math.min(r, 1)) * 255;
              img[qi + 1] = gamma(Math.min(g, 1)) * 255;
              img[qi + 2] = gamma(Math.min(b, 1)) * 255;
              img[qi + 3] = 255;
            }
        } else log("Unknown Photometric interpretation: " + intp);
        return img;
      };
      UTIF22.replaceIMG = function(imgs) {
        if (imgs == null) imgs = document.getElementsByTagName("img");
        var sufs = ["tif", "tiff", "dng", "cr2", "nef"];
        for (var i = 0; i < imgs.length; i++) {
          var img = imgs[i], src2 = img.getAttribute("src");
          if (src2 == null) continue;
          var suff = src2.split(".").pop().toLowerCase();
          if (sufs.indexOf(suff) == -1) continue;
          var xhr = new XMLHttpRequest();
          UTIF22._xhrs.push(xhr);
          UTIF22._imgs.push(img);
          xhr.open("GET", src2);
          xhr.responseType = "arraybuffer";
          xhr.onload = UTIF22._imgLoaded;
          xhr.send();
        }
      };
      UTIF22._xhrs = [];
      UTIF22._imgs = [];
      UTIF22._imgLoaded = function(e) {
        var ind = UTIF22._xhrs.indexOf(e.target), img = UTIF22._imgs[ind];
        UTIF22._xhrs.splice(ind, 1);
        UTIF22._imgs.splice(ind, 1);
        img.setAttribute("src", UTIF22.bufferToURI(e.target.response));
      };
      UTIF22.bufferToURI = function(buff) {
        var ifds = UTIF22.decode(buff);
        var vsns = ifds, ma = 0, page = vsns[0];
        if (ifds[0].subIFD) vsns = vsns.concat(ifds[0].subIFD);
        for (var i = 0; i < vsns.length; i++) {
          var img = vsns[i];
          if (img["t258"] == null || img["t258"].length < 3) continue;
          var ar = img["t256"] * img["t257"];
          if (ar > ma) {
            ma = ar;
            page = img;
          }
        }
        UTIF22.decodeImage(buff, page, ifds);
        var rgba = UTIF22.toRGBA8(page), w = page.width, h = page.height;
        var cnv = document.createElement("canvas");
        cnv.width = w;
        cnv.height = h;
        var ctx = cnv.getContext("2d");
        var imgd = new ImageData(new Uint8ClampedArray(rgba.buffer), w, h);
        ctx.putImageData(imgd, 0, 0);
        return cnv.toDataURL();
      };
      UTIF22._binBE = {
        nextZero: function(data, o) {
          while (data[o] != 0) o++;
          return o;
        },
        readUshort: function(buff, p) {
          return buff[p] << 8 | buff[p + 1];
        },
        readShort: function(buff, p) {
          var a = UTIF22._binBE.ui8;
          a[0] = buff[p + 1];
          a[1] = buff[p + 0];
          return UTIF22._binBE.i16[0];
        },
        readInt: function(buff, p) {
          var a = UTIF22._binBE.ui8;
          a[0] = buff[p + 3];
          a[1] = buff[p + 2];
          a[2] = buff[p + 1];
          a[3] = buff[p + 0];
          return UTIF22._binBE.i32[0];
        },
        readUint: function(buff, p) {
          var a = UTIF22._binBE.ui8;
          a[0] = buff[p + 3];
          a[1] = buff[p + 2];
          a[2] = buff[p + 1];
          a[3] = buff[p + 0];
          return UTIF22._binBE.ui32[0];
        },
        readASCII: function(buff, p, l) {
          var s = "";
          for (var i = 0; i < l; i++) s += String.fromCharCode(buff[p + i]);
          return s;
        },
        readFloat: function(buff, p) {
          var a = UTIF22._binBE.ui8;
          for (var i = 0; i < 4; i++) a[i] = buff[p + 3 - i];
          return UTIF22._binBE.fl32[0];
        },
        readDouble: function(buff, p) {
          var a = UTIF22._binBE.ui8;
          for (var i = 0; i < 8; i++) a[i] = buff[p + 7 - i];
          return UTIF22._binBE.fl64[0];
        },
        writeUshort: function(buff, p, n) {
          buff[p] = n >> 8 & 255;
          buff[p + 1] = n & 255;
        },
        writeInt: function(buff, p, n) {
          var a = UTIF22._binBE.ui8;
          UTIF22._binBE.i32[0] = n;
          buff[p + 3] = a[0];
          buff[p + 2] = a[1];
          buff[p + 1] = a[2];
          buff[p + 0] = a[3];
        },
        writeUint: function(buff, p, n) {
          buff[p] = n >> 24 & 255;
          buff[p + 1] = n >> 16 & 255;
          buff[p + 2] = n >> 8 & 255;
          buff[p + 3] = n >> 0 & 255;
        },
        writeASCII: function(buff, p, s) {
          for (var i = 0; i < s.length; i++) buff[p + i] = s.charCodeAt(i);
        },
        writeDouble: function(buff, p, n) {
          UTIF22._binBE.fl64[0] = n;
          for (var i = 0; i < 8; i++) buff[p + i] = UTIF22._binBE.ui8[7 - i];
        }
      };
      UTIF22._binBE.ui8 = new Uint8Array(8);
      UTIF22._binBE.i16 = new Int16Array(UTIF22._binBE.ui8.buffer);
      UTIF22._binBE.i32 = new Int32Array(UTIF22._binBE.ui8.buffer);
      UTIF22._binBE.ui32 = new Uint32Array(UTIF22._binBE.ui8.buffer);
      UTIF22._binBE.fl32 = new Float32Array(UTIF22._binBE.ui8.buffer);
      UTIF22._binBE.fl64 = new Float64Array(UTIF22._binBE.ui8.buffer);
      UTIF22._binLE = {
        nextZero: UTIF22._binBE.nextZero,
        readUshort: function(buff, p) {
          return buff[p + 1] << 8 | buff[p];
        },
        readShort: function(buff, p) {
          var a = UTIF22._binBE.ui8;
          a[0] = buff[p + 0];
          a[1] = buff[p + 1];
          return UTIF22._binBE.i16[0];
        },
        readInt: function(buff, p) {
          var a = UTIF22._binBE.ui8;
          a[0] = buff[p + 0];
          a[1] = buff[p + 1];
          a[2] = buff[p + 2];
          a[3] = buff[p + 3];
          return UTIF22._binBE.i32[0];
        },
        readUint: function(buff, p) {
          var a = UTIF22._binBE.ui8;
          a[0] = buff[p + 0];
          a[1] = buff[p + 1];
          a[2] = buff[p + 2];
          a[3] = buff[p + 3];
          return UTIF22._binBE.ui32[0];
        },
        readASCII: UTIF22._binBE.readASCII,
        readFloat: function(buff, p) {
          var a = UTIF22._binBE.ui8;
          for (var i = 0; i < 4; i++) a[i] = buff[p + i];
          return UTIF22._binBE.fl32[0];
        },
        readDouble: function(buff, p) {
          var a = UTIF22._binBE.ui8;
          for (var i = 0; i < 8; i++) a[i] = buff[p + i];
          return UTIF22._binBE.fl64[0];
        },
        writeUshort: function(buff, p, n) {
          buff[p] = n & 255;
          buff[p + 1] = n >> 8 & 255;
        },
        writeInt: function(buff, p, n) {
          var a = UTIF22._binBE.ui8;
          UTIF22._binBE.i32[0] = n;
          buff[p + 0] = a[0];
          buff[p + 1] = a[1];
          buff[p + 2] = a[2];
          buff[p + 3] = a[3];
        },
        writeUint: function(buff, p, n) {
          buff[p] = n >>> 0 & 255;
          buff[p + 1] = n >>> 8 & 255;
          buff[p + 2] = n >>> 16 & 255;
          buff[p + 3] = n >>> 24 & 255;
        },
        writeASCII: UTIF22._binBE.writeASCII
      };
      UTIF22._copyTile = function(tb, tw, th, b, w, h, xoff, yoff) {
        var xlim = Math.min(tw, w - xoff);
        var ylim = Math.min(th, h - yoff);
        for (var y2 = 0; y2 < ylim; y2++) {
          var tof = (yoff + y2) * w + xoff;
          var sof = y2 * tw;
          for (var x2 = 0; x2 < xlim; x2++) b[tof + x2] = tb[sof + x2];
        }
      };
      UTIF22.LosslessJpegDecode = /* @__PURE__ */ function() {
        var b, O;
        function l() {
          return b[O++];
        }
        function m() {
          return b[O++] << 8 | b[O++];
        }
        function a0(h) {
          var V = l(), I = [0, 0, 0, 255], f = [], G = 8;
          for (var w = 0; w < 16; w++) f[w] = l();
          for (var w = 0; w < 16; w++) {
            for (var x2 = 0; x2 < f[w]; x2++) {
              var T = z2(I, 0, w + 1, 1);
              I[T + 3] = l();
            }
          }
          var E = new Uint8Array(1 << G);
          h[V] = [new Uint8Array(I), E];
          for (var w = 0; w < 1 << G; w++) {
            var s = G, _ = w, Y2 = 0, F = 0;
            while (I[Y2 + 3] == 255 && s != 0) {
              F = _ >> --s & 1;
              Y2 = I[Y2 + F];
            }
            E[w] = Y2;
          }
        }
        function z2(h, V, I, f) {
          if (h[V + 3] != 255) return 0;
          if (I == 0) return V;
          for (var w = 0; w < 2; w++) {
            if (h[V + w] == 0) {
              h[V + w] = h.length;
              h.push(0, 0, f, 255);
            }
            var x2 = z2(h, h[V + w], I - 1, f + 1);
            if (x2 != 0) return x2;
          }
          return 0;
        }
        function i(h) {
          var V = h.b, I = h.f;
          while (V < 25 && h.a < h.d) {
            var f = h.data[h.a++];
            if (f == 255 && !h.c) h.a++;
            I = I << 8 | f;
            V += 8;
          }
          if (V < 0) throw "e";
          h.b = V;
          h.f = I;
        }
        function H(h, V) {
          if (V.b < h) i(V);
          return V.f >> (V.b -= h) & 65535 >> 16 - h;
        }
        function g(h, V) {
          var I = h[0], f = 0, w = 255, x2 = 0;
          if (V.b < 16) i(V);
          var T = V.f >> V.b - 8 & 255;
          f = h[1][T];
          w = I[f + 3];
          V.b -= I[f + 2];
          while (w == 255) {
            x2 = V.f >> --V.b & 1;
            f = I[f + x2];
            w = I[f + 3];
          }
          return w;
        }
        function P(h, V) {
          if (h < 32768 >> 16 - V) h += -(1 << V) + 1;
          return h;
        }
        function a2(h, V) {
          var I = g(h, V);
          if (I == 0) return 0;
          if (I == 16) return -32768;
          var f = H(I, V);
          return P(f, I);
        }
        function X(h, V, I, f, w, x2) {
          var T = 0;
          for (var G = 0; G < x2; G++) {
            var s = G * V;
            for (var _ = 0; _ < V; _ += w) {
              T++;
              for (var Y2 = 0; Y2 < w; Y2++) h[s + _ + Y2] = a2(f[Y2], I);
            }
            if (I.e != 0 && T % I.e == 0 && G != 0) {
              var F = I.a, t = I.data;
              while (t[F] != 255 || !(208 <= t[F + 1] && t[F + 1] <= 215)) F--;
              I.a = F + 2;
              I.f = 0;
              I.b = 0;
            }
          }
        }
        function o(h, V) {
          return P(H(h, V), h);
        }
        function a1(h, V, I, f, w) {
          var x2 = b.length - O;
          for (var T = 0; T < x2; T += 4) {
            var G = b[O + T];
            b[O + T] = b[O + T + 3];
            b[O + T + 3] = G;
            var G = b[O + T + 1];
            b[O + T + 1] = b[O + T + 2];
            b[O + T + 2] = G;
          }
          for (var E = 0; E < w; E++) {
            var s = 32768, _ = 32768;
            for (var Y2 = 0; Y2 < V; Y2 += 2) {
              var F = g(f, I), t = g(f, I);
              if (F != 0) s += o(F, I);
              if (t != 0) _ += o(t, I);
              h[E * V + Y2] = s & 65535;
              h[E * V + Y2 + 1] = _ & 65535;
            }
          }
        }
        function C(h) {
          b = h;
          O = 0;
          if (m() != 65496) throw "e";
          var V = [], I = 0, f = 0, w = 0, x2 = [], T = [], G = [], E = 0, s = 0, _ = 0;
          while (true) {
            var Y2 = m();
            if (Y2 == 65535) {
              O--;
              continue;
            }
            var F = m();
            if (Y2 == 65475) {
              f = l();
              s = m();
              _ = m();
              E = l();
              for (var t = 0; t < E; t++) {
                var a = l(), J = l(), r = l();
                if (r != 0) throw "e";
                V[a] = [t, J >> 4, J & 15];
              }
            } else if (Y2 == 65476) {
              var a3 = O + F - 2;
              while (O < a3) a0(T);
            } else if (Y2 == 65498) {
              O++;
              for (var t = 0; t < E; t++) {
                var a5 = l(), v = V[a5];
                G[v[0]] = T[l() >>> 4];
                x2[v[0]] = v.slice(1);
              }
              I = l();
              O += 2;
              break;
            } else if (Y2 == 65501) {
              w = m();
            } else {
              O += F - 2;
            }
          }
          var a4 = f > 8 ? Uint16Array : Uint8Array, $ = new a4(s * _ * E), M = { b: 0, f: 0, c: I == 8, a: O, data: b, d: b.length, e: w };
          if (M.c) a1($, _ * E, M, G[0], s);
          else {
            var c2 = [], p = 0, D = 0;
            for (var t = 0; t < E; t++) {
              var N = x2[t], S = N[0], K = N[1];
              if (S > p) p = S;
              if (K > D) D = K;
              c2.push(S * K);
            }
            if (p != 1 || D != 1) {
              if (E != 3 || c2[1] != 1 || c2[2] != 1) throw "e";
              if (p != 2 || D != 1 && D != 2) throw "e";
              var u = [], Z = 0;
              for (var t = 0; t < E; t++) {
                for (var R = 0; R < c2[t]; R++) u.push(G[t]);
                Z += c2[t];
              }
              var B = _ / p, e = s / D, d = B * e;
              X($, B * Z, M, u, Z, e);
              j($, I, B, e, Z - 2, Z, Z, f);
              var A = new Uint16Array(d * c2[0]);
              if (p == 2 && D == 2) {
                for (var t = 0; t < d; t++) {
                  A[4 * t] = $[6 * t];
                  A[4 * t + 1] = $[6 * t + 1];
                  A[4 * t + 2] = $[6 * t + 2];
                  A[4 * t + 3] = $[6 * t + 3];
                }
                j(A, I, B * 4, e, 0, 1, 1, f);
                for (var t = 0; t < d; t++) {
                  $[6 * t] = A[4 * t];
                  $[6 * t + 1] = A[4 * t + 1];
                  $[6 * t + 2] = A[4 * t + 2];
                  $[6 * t + 3] = A[4 * t + 3];
                }
              }
              if (p == 2 && D == 1) {
                for (var t = 0; t < d; t++) {
                  A[2 * t] = $[4 * t];
                  A[2 * t + 1] = $[4 * t + 1];
                }
                j(A, I, B * 2, e, 0, 1, 1, f);
                for (var t = 0; t < d; t++) {
                  $[4 * t] = A[2 * t];
                  $[4 * t + 1] = A[2 * t + 1];
                }
              }
              var n = $.slice(0);
              for (var K = 0; K < s; K++) {
                if (D == 2) for (var S = 0; S < _; S++) {
                  var q = (K * _ + S) * E, k = ((K >>> 1) * B + (S >>> 1)) * Z, y2 = (K & 1) * 2 + (S & 1);
                  $[q] = n[k + y2];
                  $[q + 1] = n[k + 4];
                  $[q + 2] = n[k + 5];
                }
                else for (var S = 0; S < _; S++) {
                  var q = (K * _ + S) * E, k = (K * B + (S >>> 1)) * Z, y2 = S & 1;
                  $[q] = n[k + y2];
                  $[q + 1] = n[k + 2];
                  $[q + 2] = n[k + 3];
                }
              }
            } else {
              X($, _ * E, M, G, E, s);
              if (w == 0) j($, I, _, s, 0, E, E, f);
              else {
                var U = Math.floor(w / _);
                for (var K = 0; K < s; K += U) {
                  var L = $.slice(K * _ * E, (K + U) * _ * E);
                  j(L, I, _, U, 0, E, E, f);
                  $.set(L, K * _ * E);
                }
              }
            }
          }
          return $;
        }
        function j(h, V, I, f, w, x2, G, E) {
          var s = I * G;
          for (var _ = w; _ < x2; _++) h[_] += 1 << E - 1;
          for (var Y2 = G; Y2 < s; Y2 += G) for (var _ = w; _ < x2; _++) h[Y2 + _] += h[Y2 + _ - G];
          for (var F = 1; F < f; F++) {
            var t = F * s;
            for (var _ = w; _ < x2; _++) h[t + _] += h[t + _ - s];
            for (var Y2 = G; Y2 < s; Y2 += G) {
              for (var _ = w; _ < x2; _++) {
                var a = t + Y2 + _, J = a - s, r = h[a - G], Q = 0;
                if (V == 0) Q = 0;
                else if (V == 1) Q = r;
                else if (V == 2) Q = h[J];
                else if (V == 3) Q = h[J - G];
                else if (V == 4) Q = r + (h[J] - h[J - G]);
                else if (V == 5) Q = r + (h[J] - h[J - G] >>> 1);
                else if (V == 6) Q = h[J] + (r - h[J - G] >>> 1);
                else if (V == 7) Q = r + h[J] >>> 1;
                else throw V;
                h[a] += Q;
              }
            }
          }
        }
        return C;
      }();
      (function() {
        var G = 0, F = 1, i = 2, b = 3, J = 4, N = 5, E = 6, s = 7, c2 = 8, T = 9, a3 = 10, f = 11, q = 12, M = 13, m = 14, x2 = 15, L = 16, $ = 17, p = 18;
        function a5(t) {
          var Z = UTIF22._binBE.readUshort, u = { b: Z(t, 0), i: t[2], C: t[3], u: t[4], q: Z(t, 5), k: Z(t, 7), e: Z(t, 9), l: Z(t, 11), s: t[13], d: Z(t, 14) };
          if (u.b != 18771 || u.i > 1 || u.q < 6 || u.q % 6 || u.e < 768 || u.e % 24 || u.l != 768 || u.k < u.l || u.k % u.l || u.k - u.e >= u.l || u.s > 16 || u.s != u.k / u.l || u.s != Math.ceil(u.e / u.l) || u.d != u.q / 6 || u.u != 12 && u.u != 14 && u.u != 16 || u.C != 16 && u.C != 0) {
            throw "Invalid data";
          }
          if (u.i == 0) {
            throw "Not implemented. We need this file!";
          }
          u.h = u.C == 16;
          u.m = (u.h ? u.l * 2 / 3 : u.l >>> 1) | 0;
          u.A = u.m + 2;
          u.f = 64;
          u.g = (1 << u.u) - 1;
          u.n = 4 * u.u;
          return u;
        }
        function a7(t, Z) {
          var u = new Array(Z.s), e = 4 * Z.s, Q = 16 + e;
          if (e & 12) Q += 16 - (e & 12);
          for (var V = 0, O = 16; V < Z.s; O += 4) {
            var o = UTIF22._binBE.readUint(t, O);
            u[V] = t.slice(Q, Q + o);
            u[V].j = 0;
            u[V].a = 0;
            Q += o;
            V++;
          }
          if (Q != t.length) throw "Invalid data";
          return u;
        }
        function a6(t, Z) {
          for (var u = -Z[4], e = 0; u <= Z[4]; e++, u++) {
            t[e] = u <= -276 ? -4 : u <= -67 ? -3 : u <= -18 ? -2 : u < -0 ? -1 : u <= Z[0] ? 0 : u < Z[1] ? 1 : u < Z[2] ? 2 : u < Z[3] ? 3 : 4;
          }
        }
        function a1(t, Z, u) {
          var e = [Z, 3 * Z + 18, 5 * Z + 67, 7 * Z + 276, u];
          t.o = Z;
          t.w = (e[4] + 2 * Z) / (2 * Z + 1) + 1 | 0;
          t.v = Math.ceil(Math.log2(t.w));
          t.t = 9;
          a6(t.c, e);
        }
        function a2(t) {
          var Z = { c: new Int8Array(2 << t.u) };
          a1(Z, 0, t.g);
          return Z;
        }
        function D(t) {
          var Z = [[], [], []], u = Math.max(2, t.w + 32 >>> 6);
          for (var e = 0; e < 3; e++) {
            for (var Q = 0; Q < 41; Q++) {
              Z[e][Q] = [u, 1];
            }
          }
          return Z;
        }
        function a4(t) {
          for (var Z = -1, u = 0; !u; Z++) {
            u = t[t.j] >>> 7 - t.a & 1;
            t.a++;
            t.a &= 7;
            if (!t.a) t.j++;
          }
          return Z;
        }
        function K(t, Z) {
          var u = 0, e = 8 - t.a;
          t.j;
          t.a;
          if (Z) {
            if (Z >= e) {
              do {
                u <<= e;
                Z -= e;
                u |= t[t.j] & (1 << e) - 1;
                t.j++;
                e = 8;
              } while (Z >= 8);
            }
            if (Z) {
              u <<= Z;
              e -= Z;
              u |= t[t.j] >>> e & (1 << Z) - 1;
            }
            t.a = 8 - e;
          }
          return u;
        }
        function a0(t, Z) {
          var u = 0;
          if (Z < t) {
            while (u <= 14 && Z << ++u < t) ;
          }
          return u;
        }
        function r(t, Z, u, e, Q, V, O, o) {
          if (o == null) o = 0;
          var X = V + 1, k = X % 2, a = 0, l, R, w = e[Q], S = e[Q - 1], H = e[Q - 2][X], g = S[X - 1], Y2 = S[X], P = S[X + 1], A = w[X - 1], v = w[X + 1], y2 = Math.abs, d, C, n, h;
          if (k) {
            d = y2(P - Y2);
            C = y2(H - Y2);
            n = y2(g - Y2);
          }
          if (k) {
            h = d > n && C < d ? H + g : d < n && C < n ? H + P : P + g;
            h = h + 2 * Y2 >>> 2;
            if (o) {
              w[X] = h;
              return;
            }
            l = Z.t * Z.c[t.g + Y2 - H] + Z.c[t.g + g - Y2];
          } else {
            h = Y2 > g && Y2 > P || Y2 < g && Y2 < P ? v + A + 2 * Y2 >>> 2 : A + v >>> 1;
            l = Z.t * Z.c[t.g + Y2 - g] + Z.c[t.g + g - A];
          }
          R = y2(l);
          var W = a4(u);
          if (W < t.n - Z.v - 1) {
            var z2 = a0(O[R][0], O[R][1]);
            a = K(u, z2) + (W << z2);
          } else {
            a = K(u, Z.v) + 1;
          }
          a = a & 1 ? -1 - (a >>> 1) : a >>> 1;
          O[R][0] += y2(a);
          if (O[R][1] == t.f) {
            O[R][0] >>>= 1;
            O[R][1] >>>= 1;
          }
          O[R][1]++;
          h = l < 0 ? h - a : h + a;
          if (t.i) {
            if (h < 0) h += Z.w;
            else if (h > t.g) h -= Z.w;
          }
          w[X] = h >= 0 ? Math.min(h, t.g) : 0;
        }
        function U(t, Z, u) {
          var e = t[0].length;
          for (var Q = Z; Q <= u; Q++) {
            t[Q][0] = t[Q - 1][1];
            t[Q][e - 1] = t[Q - 1][e - 2];
          }
        }
        function B(t) {
          U(t, s, q);
          U(t, i, J);
          U(t, x2, $);
        }
        function _(t, Z, u, e, Q, V, O, o, X, k, j, I, a) {
          var l = 0, R = 1, w = Q < M && Q > J;
          while (R < t.m) {
            if (l < t.m) {
              r(t, Z, u, e, Q, l, O[X], t.h && (w && k || !w && (j || (l & I) == a)));
              r(t, Z, u, e, V, l, O[X], t.h && (!w && k || w && (j || (l & I) == a)));
              l += 2;
            }
            if (l > 8) {
              r(t, Z, u, e, Q, R, o[X]);
              r(t, Z, u, e, V, R, o[X]);
              R += 2;
            }
          }
          B(e);
        }
        function a8(t, Z, u, e, Q, V) {
          _(t, Z, u, e, i, s, Q, V, 0, 0, 1, 0, 8);
          _(t, Z, u, e, c2, x2, Q, V, 1, 0, 1, 0, 8);
          _(t, Z, u, e, b, T, Q, V, 2, 1, 0, 3, 0);
          _(t, Z, u, e, a3, L, Q, V, 0, 0, 0, 3, 2);
          _(t, Z, u, e, J, f, Q, V, 1, 0, 0, 3, 2);
          _(t, Z, u, e, q, $, Q, V, 2, 1, 0, 3, 0);
        }
        function a9(t, Z, u, e, Q, V) {
          var O = V.length, o = t.l;
          if (Q + 1 == t.s) o = t.e - Q * t.l;
          var X = 6 * t.e * e + Q * t.l;
          for (var k = 0; k < 6; k++) {
            for (var j = 0; j < o; j++) {
              var I = V[k % O][j % O], a;
              if (I == 0) {
                a = i + (k >>> 1);
              } else if (I == 2) {
                a = x2 + (k >>> 1);
              } else {
                a = s + k;
              }
              var l = t.h ? (j * 2 / 3 & 2147483646 | j % 3 & 1) + (j % 3 >>> 1) : j >>> 1;
              Z[X + j] = u[a][l + 1];
            }
            X += t.e;
          }
        }
        UTIF22._decompressRAF = function(t, Z) {
          var u = a5(t), e = a7(t, u), Q = a2(u), V = new Int16Array(u.e * u.q);
          if (Z == null) {
            Z = u.h ? [[1, 1, 0, 1, 1, 2], [1, 1, 2, 1, 1, 0], [2, 0, 1, 0, 2, 1], [1, 1, 2, 1, 1, 0], [1, 1, 0, 1, 1, 2], [0, 2, 1, 2, 0, 1]] : [[0, 1], [3, 2]];
          }
          var O = [[G, b], [F, J], [N, f], [E, q], [M, L], [m, $]], o = [];
          for (var X = 0; X < p; X++) {
            o[X] = new Uint16Array(u.A);
          }
          for (var k = 0; k < u.s; k++) {
            var j = D(Q), I = D(Q);
            for (var X = 0; X < p; X++) {
              for (var a = 0; a < u.A; a++) {
                o[X][a] = 0;
              }
            }
            for (var l = 0; l < u.d; l++) {
              a8(u, Q, e[k], o, j, I);
              for (var X = 0; X < 6; X++) {
                for (var a = 0; a < u.A; a++) {
                  o[O[X][0]][a] = o[O[X][1]][a];
                }
              }
              a9(u, V, o, l, k, Z);
              for (var X = i; X < p; X++) {
                if ([N, E, M, m].indexOf(X) == -1) {
                  for (var a = 0; a < u.A; a++) {
                    o[X][a] = 0;
                  }
                }
              }
              B(o);
            }
          }
          return V;
        };
      })();
    })(UTIF2, pako);
  })();
})(UTIF);
var UTIFExports = UTIF.exports;
const utif = /* @__PURE__ */ getDefaultExportFromCjs(UTIFExports);
function getDimensionValue(dimension) {
  if (typeof dimension === "number") {
    return dimension;
  }
  if (dimension instanceof Uint8Array) {
    return dimension[0];
  }
  if (typeof dimension[0] === "string") {
    return parseInt(dimension[0]);
  }
  return dimension[0];
}
function tiff() {
  return {
    mime: "image/tiff",
    encode: (bitmap) => {
      const tiff2 = utif.encodeImage(bitmap.data, bitmap.width, bitmap.height);
      return Buffer.from(tiff2);
    },
    decode: (data) => {
      const ifds = utif.decode(data);
      const page = ifds[0];
      if (!page) {
        throw new Error("No page found in TIFF");
      }
      if (!page.t256) {
        throw new Error("No image width found in TIFF");
      }
      if (!page.t257) {
        throw new Error("No image height found in TIFF");
      }
      ifds.forEach((ifd) => {
        utif.decodeImage(data, ifd);
      });
      const rgba = utif.toRGBA8(page);
      return {
        data: Buffer.from(rgba),
        width: getDimensionValue(page.t256),
        height: getDimensionValue(page.t257)
      };
    }
  };
}
var util$g;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$g || (util$g = {}));
var objectUtil$f;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$f || (objectUtil$f = {}));
const ZodParsedType$f = util$g.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$f = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$f.undefined;
    case "string":
      return ZodParsedType$f.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType$f.nan : ZodParsedType$f.number;
    case "boolean":
      return ZodParsedType$f.boolean;
    case "function":
      return ZodParsedType$f.function;
    case "bigint":
      return ZodParsedType$f.bigint;
    case "symbol":
      return ZodParsedType$f.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$f.array;
      }
      if (data === null) {
        return ZodParsedType$f.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$f.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$f.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$f.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$f.date;
      }
      return ZodParsedType$f.object;
    default:
      return ZodParsedType$f.unknown;
  }
};
const ZodIssueCode$f = util$g.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
let ZodError$f = class ZodError2 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue2 of error.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError2)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$g.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$f.create = (issues) => {
  const error = new ZodError$f(issues);
  return error;
};
const errorMap$f = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode$f.invalid_type:
      if (issue2.received === ZodParsedType$f.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode$f.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util$g.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$f.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$g.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode$f.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$f.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$g.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode$f.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$g.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode$f.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$f.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$f.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$f.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util$g.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$f.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$f.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$f.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$f.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$f.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode$f.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$g.assertNever(issue2);
  }
  return { message };
};
let overrideErrorMap$f = errorMap$f;
function getErrorMap$f() {
  return overrideErrorMap$f;
}
const makeIssue$f = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext$f(ctx, issueData) {
  const overrideMap = getErrorMap$f();
  const issue2 = makeIssue$f({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$f ? void 0 : errorMap$f
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue2);
}
let ParseStatus$f = class ParseStatus2 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$f;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus2.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$f;
      if (value.status === "aborted")
        return INVALID$f;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$f = Object.freeze({
  status: "aborted"
});
const DIRTY$f = (value) => ({ status: "dirty", value });
const OK$f = (value) => ({ status: "valid", value });
const isAborted$f = (x2) => x2.status === "aborted";
const isDirty$f = (x2) => x2.status === "dirty";
const isValid$f = (x2) => x2.status === "valid";
const isAsync$f = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil$f;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil$f || (errorUtil$f = {}));
let ParseInputLazyPath$f = class ParseInputLazyPath2 {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$f = (ctx, result) => {
  if (isValid$f(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$f(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$f(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$f = class ZodType2 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$f(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$f(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$f(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$f(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$f(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: (params == null ? void 0 : params.async) ?? false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$f(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$f(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$f(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$f(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$f(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$f(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$f(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$f(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$f.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$f({
      schema: this,
      typeName: ZodFirstPartyTypeKind$f.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$f.create(this, this._def);
  }
  nullable() {
    return ZodNullable$f.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$f.create(this);
  }
  promise() {
    return ZodPromise$f.create(this, this._def);
  }
  or(option) {
    return ZodUnion$f.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$f.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects$f({
      ...processCreateParams$f(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$f.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault$f({
      ...processCreateParams$f(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$f.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$f({
      typeName: ZodFirstPartyTypeKind$f.ZodBranded,
      type: this,
      ...processCreateParams$f(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch$f({
      ...processCreateParams$f(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$f.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$f.create(this, target);
  }
  readonly() {
    return ZodReadonly$f.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$f = /^c[^\s-]{8,}$/i;
const cuid2Regex$f = /^[0-9a-z]+$/;
const ulidRegex$f = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$f = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$f = /^[a-z0-9_-]{21}$/i;
const jwtRegex$f = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$f = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$f = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$f = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$f;
const ipv4Regex$f = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$f = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$f = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$f = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$f = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$f = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$f = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$f = new RegExp(`^${dateRegexSource$f}$`);
function timeRegexSource$f(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex$f(args) {
  return new RegExp(`^${timeRegexSource$f(args)}$`);
}
function datetimeRegex$f(args) {
  let regex = `${dateRegexSource$f}T${timeRegexSource$f(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$f(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex$f.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex$f.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$f(jwt, alg) {
  if (!jwtRegex$f.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr$f(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex$f.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex$f.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$f = class ZodString2 extends ZodType$f {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$f.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$f(ctx2, {
        code: ZodIssueCode$f.invalid_type,
        expected: ZodParsedType$f.string,
        received: ctx2.parsedType
      });
      return INVALID$f;
    }
    const status = new ParseStatus$f();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            code: ZodIssueCode$f.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            code: ZodIssueCode$f.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$f(ctx, {
              code: ZodIssueCode$f.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$f(ctx, {
              code: ZodIssueCode$f.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$f.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            validation: "email",
            code: ZodIssueCode$f.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$f) {
          emojiRegex$f = new RegExp(_emojiRegex$f, "u");
        }
        if (!emojiRegex$f.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            validation: "emoji",
            code: ZodIssueCode$f.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$f.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            validation: "uuid",
            code: ZodIssueCode$f.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$f.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$f.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$f.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            validation: "cuid",
            code: ZodIssueCode$f.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$f.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$f.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$f.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            validation: "ulid",
            code: ZodIssueCode$f.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            validation: "url",
            code: ZodIssueCode$f.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            validation: "regex",
            code: ZodIssueCode$f.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            code: ZodIssueCode$f.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            code: ZodIssueCode$f.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            code: ZodIssueCode$f.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$f(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            code: ZodIssueCode$f.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$f;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            code: ZodIssueCode$f.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$f(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            code: ZodIssueCode$f.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$f.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            validation: "duration",
            code: ZodIssueCode$f.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$f(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            validation: "ip",
            code: ZodIssueCode$f.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$f(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            validation: "jwt",
            code: ZodIssueCode$f.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$f(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            validation: "cidr",
            code: ZodIssueCode$f.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$f.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            validation: "base64",
            code: ZodIssueCode$f.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$f.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            validation: "base64url",
            code: ZodIssueCode$f.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$g.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$f.invalid_string,
      ...errorUtil$f.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$f.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$f.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$f.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$f.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$f.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$f.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$f.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$f.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$f.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$f.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$f.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$f.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$f.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (options == null ? void 0 : options.offset) ?? false,
      local: (options == null ? void 0 : options.local) ?? false,
      ...errorUtil$f.errToObj(options == null ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      ...errorUtil$f.errToObj(options == null ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$f.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$f.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position,
      ...errorUtil$f.errToObj(options == null ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$f.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$f.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$f.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$f.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$f.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$f.errToObj(message));
  }
  trim() {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$f.create = (params) => {
  return new ZodString$f({
    checks: [],
    typeName: ZodFirstPartyTypeKind$f.ZodString,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$f(params)
  });
};
function floatSafeRemainder$f(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
let ZodNumber$f = class ZodNumber2 extends ZodType$f {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$f.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$f(ctx2, {
        code: ZodIssueCode$f.invalid_type,
        expected: ZodParsedType$f.number,
        received: ctx2.parsedType
      });
      return INVALID$f;
    }
    let ctx = void 0;
    const status = new ParseStatus$f();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$g.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            code: ZodIssueCode$f.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            code: ZodIssueCode$f.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            code: ZodIssueCode$f.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$f(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            code: ZodIssueCode$f.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            code: ZodIssueCode$f.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$g.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$f.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$f.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$f.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$f.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber2({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$f.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber2({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$f.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$f.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$f.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$f.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$f.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$f.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$f.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$f.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$f.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$g.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$f.create = (params) => {
  return new ZodNumber$f({
    checks: [],
    typeName: ZodFirstPartyTypeKind$f.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$f(params)
  });
};
let ZodBigInt$f = class ZodBigInt2 extends ZodType$f {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$f.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$f();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            code: ZodIssueCode$f.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            code: ZodIssueCode$f.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            code: ZodIssueCode$f.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$g.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$f(ctx, {
      code: ZodIssueCode$f.invalid_type,
      expected: ZodParsedType$f.bigint,
      received: ctx.parsedType
    });
    return INVALID$f;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$f.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$f.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$f.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$f.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt2({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$f.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt2({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$f.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$f.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$f.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$f.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$f.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$f.create = (params) => {
  return new ZodBigInt$f({
    checks: [],
    typeName: ZodFirstPartyTypeKind$f.ZodBigInt,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$f(params)
  });
};
let ZodBoolean$f = class ZodBoolean2 extends ZodType$f {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$f.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$f(ctx, {
        code: ZodIssueCode$f.invalid_type,
        expected: ZodParsedType$f.boolean,
        received: ctx.parsedType
      });
      return INVALID$f;
    }
    return OK$f(input.data);
  }
};
ZodBoolean$f.create = (params) => {
  return new ZodBoolean$f({
    typeName: ZodFirstPartyTypeKind$f.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$f(params)
  });
};
let ZodDate$f = class ZodDate2 extends ZodType$f {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$f.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$f(ctx2, {
        code: ZodIssueCode$f.invalid_type,
        expected: ZodParsedType$f.date,
        received: ctx2.parsedType
      });
      return INVALID$f;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$f(ctx2, {
        code: ZodIssueCode$f.invalid_date
      });
      return INVALID$f;
    }
    const status = new ParseStatus$f();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            code: ZodIssueCode$f.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$f(ctx, {
            code: ZodIssueCode$f.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$g.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate2({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$f.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$f.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$f.create = (params) => {
  return new ZodDate$f({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$f.ZodDate,
    ...processCreateParams$f(params)
  });
};
let ZodSymbol$f = class ZodSymbol2 extends ZodType$f {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$f.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$f(ctx, {
        code: ZodIssueCode$f.invalid_type,
        expected: ZodParsedType$f.symbol,
        received: ctx.parsedType
      });
      return INVALID$f;
    }
    return OK$f(input.data);
  }
};
ZodSymbol$f.create = (params) => {
  return new ZodSymbol$f({
    typeName: ZodFirstPartyTypeKind$f.ZodSymbol,
    ...processCreateParams$f(params)
  });
};
let ZodUndefined$f = class ZodUndefined2 extends ZodType$f {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$f.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$f(ctx, {
        code: ZodIssueCode$f.invalid_type,
        expected: ZodParsedType$f.undefined,
        received: ctx.parsedType
      });
      return INVALID$f;
    }
    return OK$f(input.data);
  }
};
ZodUndefined$f.create = (params) => {
  return new ZodUndefined$f({
    typeName: ZodFirstPartyTypeKind$f.ZodUndefined,
    ...processCreateParams$f(params)
  });
};
let ZodNull$f = class ZodNull2 extends ZodType$f {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$f.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$f(ctx, {
        code: ZodIssueCode$f.invalid_type,
        expected: ZodParsedType$f.null,
        received: ctx.parsedType
      });
      return INVALID$f;
    }
    return OK$f(input.data);
  }
};
ZodNull$f.create = (params) => {
  return new ZodNull$f({
    typeName: ZodFirstPartyTypeKind$f.ZodNull,
    ...processCreateParams$f(params)
  });
};
let ZodAny$f = class ZodAny2 extends ZodType$f {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$f(input.data);
  }
};
ZodAny$f.create = (params) => {
  return new ZodAny$f({
    typeName: ZodFirstPartyTypeKind$f.ZodAny,
    ...processCreateParams$f(params)
  });
};
let ZodUnknown$f = class ZodUnknown2 extends ZodType$f {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$f(input.data);
  }
};
ZodUnknown$f.create = (params) => {
  return new ZodUnknown$f({
    typeName: ZodFirstPartyTypeKind$f.ZodUnknown,
    ...processCreateParams$f(params)
  });
};
let ZodNever$f = class ZodNever2 extends ZodType$f {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$f(ctx, {
      code: ZodIssueCode$f.invalid_type,
      expected: ZodParsedType$f.never,
      received: ctx.parsedType
    });
    return INVALID$f;
  }
};
ZodNever$f.create = (params) => {
  return new ZodNever$f({
    typeName: ZodFirstPartyTypeKind$f.ZodNever,
    ...processCreateParams$f(params)
  });
};
let ZodVoid$f = class ZodVoid2 extends ZodType$f {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$f.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$f(ctx, {
        code: ZodIssueCode$f.invalid_type,
        expected: ZodParsedType$f.void,
        received: ctx.parsedType
      });
      return INVALID$f;
    }
    return OK$f(input.data);
  }
};
ZodVoid$f.create = (params) => {
  return new ZodVoid$f({
    typeName: ZodFirstPartyTypeKind$f.ZodVoid,
    ...processCreateParams$f(params)
  });
};
let ZodArray$f = class ZodArray2 extends ZodType$f {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType$f.array) {
      addIssueToContext$f(ctx, {
        code: ZodIssueCode$f.invalid_type,
        expected: ZodParsedType$f.array,
        received: ctx.parsedType
      });
      return INVALID$f;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$f(ctx, {
          code: tooBig ? ZodIssueCode$f.too_big : ZodIssueCode$f.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext$f(ctx, {
          code: ZodIssueCode$f.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext$f(ctx, {
          code: ZodIssueCode$f.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath$f(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$f.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath$f(ctx, item, ctx.path, i));
    });
    return ParseStatus$f.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray2({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$f.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray2({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$f.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray2({
      ...this._def,
      exactLength: { value: len, message: errorUtil$f.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$f.create = (schema, params) => {
  return new ZodArray$f({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$f.ZodArray,
    ...processCreateParams$f(params)
  });
};
function deepPartialify$f(schema) {
  if (schema instanceof ZodObject$f) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$f.create(deepPartialify$f(fieldSchema));
    }
    return new ZodObject$f({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$f) {
    return new ZodArray$f({
      ...schema._def,
      type: deepPartialify$f(schema.element)
    });
  } else if (schema instanceof ZodOptional$f) {
    return ZodOptional$f.create(deepPartialify$f(schema.unwrap()));
  } else if (schema instanceof ZodNullable$f) {
    return ZodNullable$f.create(deepPartialify$f(schema.unwrap()));
  } else if (schema instanceof ZodTuple$f) {
    return ZodTuple$f.create(schema.items.map((item) => deepPartialify$f(item)));
  } else {
    return schema;
  }
}
let ZodObject$f = class ZodObject2 extends ZodType$f {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$g.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$f.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$f(ctx2, {
        code: ZodIssueCode$f.invalid_type,
        expected: ZodParsedType$f.object,
        received: ctx2.parsedType
      });
      return INVALID$f;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$f && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$f(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$f) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$f(ctx, {
            code: ZodIssueCode$f.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$f(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$f.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$f.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$f.errToObj;
    return new ZodObject2({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          var _a, _b;
          const defaultError = ((_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue2, ctx).message) ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil$f.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject2({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject2({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject2({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject2({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$f.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject2({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util$g.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject2({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util$g.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject2({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$f(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util$g.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject2({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util$g.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$f) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject2({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$f(util$g.objectKeys(this.shape));
  }
};
ZodObject$f.create = (shape, params) => {
  return new ZodObject$f({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$f.create(),
    typeName: ZodFirstPartyTypeKind$f.ZodObject,
    ...processCreateParams$f(params)
  });
};
ZodObject$f.strictCreate = (shape, params) => {
  return new ZodObject$f({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$f.create(),
    typeName: ZodFirstPartyTypeKind$f.ZodObject,
    ...processCreateParams$f(params)
  });
};
ZodObject$f.lazycreate = (shape, params) => {
  return new ZodObject$f({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$f.create(),
    typeName: ZodFirstPartyTypeKind$f.ZodObject,
    ...processCreateParams$f(params)
  });
};
let ZodUnion$f = class ZodUnion2 extends ZodType$f {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$f(result.ctx.common.issues));
      addIssueToContext$f(ctx, {
        code: ZodIssueCode$f.invalid_union,
        unionErrors
      });
      return INVALID$f;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$f(issues2));
      addIssueToContext$f(ctx, {
        code: ZodIssueCode$f.invalid_union,
        unionErrors
      });
      return INVALID$f;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$f.create = (types, params) => {
  return new ZodUnion$f({
    options: types,
    typeName: ZodFirstPartyTypeKind$f.ZodUnion,
    ...processCreateParams$f(params)
  });
};
function mergeValues$f(a, b) {
  const aType = getParsedType$f(a);
  const bType = getParsedType$f(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$f.object && bType === ZodParsedType$f.object) {
    const bKeys = util$g.objectKeys(b);
    const sharedKeys = util$g.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$f(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$f.array && bType === ZodParsedType$f.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$f(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$f.date && bType === ZodParsedType$f.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$f = class ZodIntersection2 extends ZodType$f {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$f(parsedLeft) || isAborted$f(parsedRight)) {
        return INVALID$f;
      }
      const merged = mergeValues$f(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$f(ctx, {
          code: ZodIssueCode$f.invalid_intersection_types
        });
        return INVALID$f;
      }
      if (isDirty$f(parsedLeft) || isDirty$f(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$f.create = (left, right, params) => {
  return new ZodIntersection$f({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$f.ZodIntersection,
    ...processCreateParams$f(params)
  });
};
let ZodTuple$f = class ZodTuple2 extends ZodType$f {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$f.array) {
      addIssueToContext$f(ctx, {
        code: ZodIssueCode$f.invalid_type,
        expected: ZodParsedType$f.array,
        received: ctx.parsedType
      });
      return INVALID$f;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$f(ctx, {
        code: ZodIssueCode$f.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$f;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$f(ctx, {
        code: ZodIssueCode$f.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$f(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$f.mergeArray(status, results);
      });
    } else {
      return ParseStatus$f.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple2({
      ...this._def,
      rest
    });
  }
};
ZodTuple$f.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$f({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$f.ZodTuple,
    rest: null,
    ...processCreateParams$f(params)
  });
};
let ZodMap$f = class ZodMap2 extends ZodType$f {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$f.map) {
      addIssueToContext$f(ctx, {
        code: ZodIssueCode$f.invalid_type,
        expected: ZodParsedType$f.map,
        received: ctx.parsedType
      });
      return INVALID$f;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$f(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$f(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$f;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$f;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$f.create = (keyType, valueType, params) => {
  return new ZodMap$f({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$f.ZodMap,
    ...processCreateParams$f(params)
  });
};
let ZodSet$f = class ZodSet2 extends ZodType$f {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$f.set) {
      addIssueToContext$f(ctx, {
        code: ZodIssueCode$f.invalid_type,
        expected: ZodParsedType$f.set,
        received: ctx.parsedType
      });
      return INVALID$f;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext$f(ctx, {
          code: ZodIssueCode$f.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext$f(ctx, {
          code: ZodIssueCode$f.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID$f;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$f(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet2({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$f.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet2({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$f.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$f.create = (valueType, params) => {
  return new ZodSet$f({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$f.ZodSet,
    ...processCreateParams$f(params)
  });
};
let ZodLazy$f = class ZodLazy2 extends ZodType$f {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$f.create = (getter, params) => {
  return new ZodLazy$f({
    getter,
    typeName: ZodFirstPartyTypeKind$f.ZodLazy,
    ...processCreateParams$f(params)
  });
};
let ZodLiteral$f = class ZodLiteral2 extends ZodType$f {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$f(ctx, {
        received: ctx.data,
        code: ZodIssueCode$f.invalid_literal,
        expected: this._def.value
      });
      return INVALID$f;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$f.create = (value, params) => {
  return new ZodLiteral$f({
    value,
    typeName: ZodFirstPartyTypeKind$f.ZodLiteral,
    ...processCreateParams$f(params)
  });
};
function createZodEnum$f(values, params) {
  return new ZodEnum$f({
    values,
    typeName: ZodFirstPartyTypeKind$f.ZodEnum,
    ...processCreateParams$f(params)
  });
}
let ZodEnum$f = class ZodEnum2 extends ZodType$f {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$f(ctx, {
        expected: util$g.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$f.invalid_type
      });
      return INVALID$f;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$f(ctx, {
        received: ctx.data,
        code: ZodIssueCode$f.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$f;
    }
    return OK$f(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum2.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum2.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum$f.create = createZodEnum$f;
let ZodNativeEnum$f = class ZodNativeEnum2 extends ZodType$f {
  _parse(input) {
    const nativeEnumValues = util$g.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$f.string && ctx.parsedType !== ZodParsedType$f.number) {
      const expectedValues = util$g.objectValues(nativeEnumValues);
      addIssueToContext$f(ctx, {
        expected: util$g.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$f.invalid_type
      });
      return INVALID$f;
    }
    if (!this._cache) {
      this._cache = new Set(util$g.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util$g.objectValues(nativeEnumValues);
      addIssueToContext$f(ctx, {
        received: ctx.data,
        code: ZodIssueCode$f.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$f;
    }
    return OK$f(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum$f.create = (values, params) => {
  return new ZodNativeEnum$f({
    values,
    typeName: ZodFirstPartyTypeKind$f.ZodNativeEnum,
    ...processCreateParams$f(params)
  });
};
let ZodPromise$f = class ZodPromise2 extends ZodType$f {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$f.promise && ctx.common.async === false) {
      addIssueToContext$f(ctx, {
        code: ZodIssueCode$f.invalid_type,
        expected: ZodParsedType$f.promise,
        received: ctx.parsedType
      });
      return INVALID$f;
    }
    const promisified = ctx.parsedType === ZodParsedType$f.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$f(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$f.create = (schema, params) => {
  return new ZodPromise$f({
    type: schema,
    typeName: ZodFirstPartyTypeKind$f.ZodPromise,
    ...processCreateParams$f(params)
  });
};
let ZodEffects$f = class ZodEffects2 extends ZodType$f {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$f.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$f(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$f;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$f;
          if (result.status === "dirty")
            return DIRTY$f(result.value);
          if (status.value === "dirty")
            return DIRTY$f(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$f;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$f;
        if (result.status === "dirty")
          return DIRTY$f(result.value);
        if (status.value === "dirty")
          return DIRTY$f(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$f;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$f;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$f(base))
          return INVALID$f;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$f(base))
            return INVALID$f;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util$g.assertNever(effect);
  }
};
ZodEffects$f.create = (schema, effect, params) => {
  return new ZodEffects$f({
    schema,
    typeName: ZodFirstPartyTypeKind$f.ZodEffects,
    effect,
    ...processCreateParams$f(params)
  });
};
ZodEffects$f.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$f({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$f.ZodEffects,
    ...processCreateParams$f(params)
  });
};
let ZodOptional$f = class ZodOptional2 extends ZodType$f {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$f.undefined) {
      return OK$f(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$f.create = (type, params) => {
  return new ZodOptional$f({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$f.ZodOptional,
    ...processCreateParams$f(params)
  });
};
let ZodNullable$f = class ZodNullable2 extends ZodType$f {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$f.null) {
      return OK$f(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$f.create = (type, params) => {
  return new ZodNullable$f({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$f.ZodNullable,
    ...processCreateParams$f(params)
  });
};
let ZodDefault$f = class ZodDefault2 extends ZodType$f {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$f.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$f.create = (type, params) => {
  return new ZodDefault$f({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$f.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$f(params)
  });
};
let ZodCatch$f = class ZodCatch2 extends ZodType$f {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$f(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$f(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$f(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$f.create = (type, params) => {
  return new ZodCatch$f({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$f.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$f(params)
  });
};
let ZodNaN$f = class ZodNaN2 extends ZodType$f {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$f.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$f(ctx, {
        code: ZodIssueCode$f.invalid_type,
        expected: ZodParsedType$f.nan,
        received: ctx.parsedType
      });
      return INVALID$f;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$f.create = (params) => {
  return new ZodNaN$f({
    typeName: ZodFirstPartyTypeKind$f.ZodNaN,
    ...processCreateParams$f(params)
  });
};
let ZodBranded$f = class ZodBranded2 extends ZodType$f {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$f = class ZodPipeline2 extends ZodType$f {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$f;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$f(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$f;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline2({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$f.ZodPipeline
    });
  }
};
let ZodReadonly$f = class ZodReadonly2 extends ZodType$f {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$f(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$f(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$f.create = (type, params) => {
  return new ZodReadonly$f({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$f.ZodReadonly,
    ...processCreateParams$f(params)
  });
};
function cleanParams$1(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom$1(check, _params = {}, fatal) {
  if (check)
    return ZodAny$f.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams$1(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams$1(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny$f.create();
}
var ZodFirstPartyTypeKind$f;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$f || (ZodFirstPartyTypeKind$f = {}));
const instanceOfType$1 = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom$1((data) => data instanceof cls, params);
const numberType$e = ZodNumber$f.create;
ZodAny$f.create;
ZodNever$f.create;
ZodArray$f.create;
const objectType$f = ZodObject$f.create;
const unionType$7 = ZodUnion$f.create;
ZodIntersection$f.create;
ZodTuple$f.create;
ZodEnum$f.create;
ZodPromise$f.create;
ZodOptional$f.create;
ZodNullable$f.create;
var Edge;
(function(Edge2) {
  Edge2[Edge2["EXTEND"] = 1] = "EXTEND";
  Edge2[Edge2["WRAP"] = 2] = "WRAP";
  Edge2[Edge2["CROP"] = 3] = "CROP";
})(Edge || (Edge = {}));
const JimpClassSchema = objectType$f({
  bitmap: objectType$f({
    data: unionType$7([instanceOfType$1(Buffer), instanceOfType$1(Uint8Array)]),
    width: numberType$e(),
    height: numberType$e()
  })
});
var util$f;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$f || (util$f = {}));
var objectUtil$e;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$e || (objectUtil$e = {}));
const ZodParsedType$e = util$f.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$e = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$e.undefined;
    case "string":
      return ZodParsedType$e.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType$e.nan : ZodParsedType$e.number;
    case "boolean":
      return ZodParsedType$e.boolean;
    case "function":
      return ZodParsedType$e.function;
    case "bigint":
      return ZodParsedType$e.bigint;
    case "symbol":
      return ZodParsedType$e.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$e.array;
      }
      if (data === null) {
        return ZodParsedType$e.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$e.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$e.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$e.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$e.date;
      }
      return ZodParsedType$e.object;
    default:
      return ZodParsedType$e.unknown;
  }
};
const ZodIssueCode$e = util$f.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
let ZodError$e = class ZodError3 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue2 of error.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError3)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$f.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$e.create = (issues) => {
  const error = new ZodError$e(issues);
  return error;
};
const errorMap$e = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode$e.invalid_type:
      if (issue2.received === ZodParsedType$e.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode$e.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util$f.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$e.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$f.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode$e.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$e.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$f.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode$e.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$f.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode$e.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$e.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$e.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$e.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util$f.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$e.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$e.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$e.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$e.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$e.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode$e.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$f.assertNever(issue2);
  }
  return { message };
};
let overrideErrorMap$e = errorMap$e;
function getErrorMap$e() {
  return overrideErrorMap$e;
}
const makeIssue$e = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext$e(ctx, issueData) {
  const overrideMap = getErrorMap$e();
  const issue2 = makeIssue$e({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$e ? void 0 : errorMap$e
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue2);
}
let ParseStatus$e = class ParseStatus3 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$e;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus3.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$e;
      if (value.status === "aborted")
        return INVALID$e;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$e = Object.freeze({
  status: "aborted"
});
const DIRTY$e = (value) => ({ status: "dirty", value });
const OK$e = (value) => ({ status: "valid", value });
const isAborted$e = (x2) => x2.status === "aborted";
const isDirty$e = (x2) => x2.status === "dirty";
const isValid$e = (x2) => x2.status === "valid";
const isAsync$e = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil$e;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil$e || (errorUtil$e = {}));
let ParseInputLazyPath$e = class ParseInputLazyPath3 {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$e = (ctx, result) => {
  if (isValid$e(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$e(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$e(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$e = class ZodType3 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$e(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$e(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$e(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$e(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$e(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: (params == null ? void 0 : params.async) ?? false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$e(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$e(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$e(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$e(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$e(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$e(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$e(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$e(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$e.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$e({
      schema: this,
      typeName: ZodFirstPartyTypeKind$e.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$e.create(this, this._def);
  }
  nullable() {
    return ZodNullable$e.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$e.create(this);
  }
  promise() {
    return ZodPromise$e.create(this, this._def);
  }
  or(option) {
    return ZodUnion$e.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$e.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects$e({
      ...processCreateParams$e(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$e.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault$e({
      ...processCreateParams$e(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$e.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$e({
      typeName: ZodFirstPartyTypeKind$e.ZodBranded,
      type: this,
      ...processCreateParams$e(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch$e({
      ...processCreateParams$e(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$e.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$e.create(this, target);
  }
  readonly() {
    return ZodReadonly$e.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$e = /^c[^\s-]{8,}$/i;
const cuid2Regex$e = /^[0-9a-z]+$/;
const ulidRegex$e = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$e = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$e = /^[a-z0-9_-]{21}$/i;
const jwtRegex$e = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$e = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$e = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$e = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$e;
const ipv4Regex$e = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$e = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$e = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$e = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$e = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$e = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$e = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$e = new RegExp(`^${dateRegexSource$e}$`);
function timeRegexSource$e(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex$e(args) {
  return new RegExp(`^${timeRegexSource$e(args)}$`);
}
function datetimeRegex$e(args) {
  let regex = `${dateRegexSource$e}T${timeRegexSource$e(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$e(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex$e.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex$e.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$e(jwt, alg) {
  if (!jwtRegex$e.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr$e(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex$e.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex$e.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$e = class ZodString3 extends ZodType$e {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$e.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$e(ctx2, {
        code: ZodIssueCode$e.invalid_type,
        expected: ZodParsedType$e.string,
        received: ctx2.parsedType
      });
      return INVALID$e;
    }
    const status = new ParseStatus$e();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            code: ZodIssueCode$e.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            code: ZodIssueCode$e.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$e(ctx, {
              code: ZodIssueCode$e.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$e(ctx, {
              code: ZodIssueCode$e.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$e.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            validation: "email",
            code: ZodIssueCode$e.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$e) {
          emojiRegex$e = new RegExp(_emojiRegex$e, "u");
        }
        if (!emojiRegex$e.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            validation: "emoji",
            code: ZodIssueCode$e.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$e.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            validation: "uuid",
            code: ZodIssueCode$e.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$e.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$e.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$e.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            validation: "cuid",
            code: ZodIssueCode$e.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$e.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$e.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$e.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            validation: "ulid",
            code: ZodIssueCode$e.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            validation: "url",
            code: ZodIssueCode$e.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            validation: "regex",
            code: ZodIssueCode$e.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            code: ZodIssueCode$e.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            code: ZodIssueCode$e.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            code: ZodIssueCode$e.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$e(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            code: ZodIssueCode$e.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$e;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            code: ZodIssueCode$e.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$e(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            code: ZodIssueCode$e.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$e.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            validation: "duration",
            code: ZodIssueCode$e.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$e(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            validation: "ip",
            code: ZodIssueCode$e.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$e(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            validation: "jwt",
            code: ZodIssueCode$e.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$e(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            validation: "cidr",
            code: ZodIssueCode$e.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$e.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            validation: "base64",
            code: ZodIssueCode$e.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$e.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            validation: "base64url",
            code: ZodIssueCode$e.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$f.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$e.invalid_string,
      ...errorUtil$e.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString3({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$e.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$e.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$e.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$e.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$e.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$e.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$e.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$e.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$e.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$e.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$e.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$e.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$e.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (options == null ? void 0 : options.offset) ?? false,
      local: (options == null ? void 0 : options.local) ?? false,
      ...errorUtil$e.errToObj(options == null ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      ...errorUtil$e.errToObj(options == null ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$e.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$e.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position,
      ...errorUtil$e.errToObj(options == null ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$e.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$e.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$e.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$e.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$e.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$e.errToObj(message));
  }
  trim() {
    return new ZodString3({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString3({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString3({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$e.create = (params) => {
  return new ZodString$e({
    checks: [],
    typeName: ZodFirstPartyTypeKind$e.ZodString,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$e(params)
  });
};
function floatSafeRemainder$e(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
let ZodNumber$e = class ZodNumber3 extends ZodType$e {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$e.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$e(ctx2, {
        code: ZodIssueCode$e.invalid_type,
        expected: ZodParsedType$e.number,
        received: ctx2.parsedType
      });
      return INVALID$e;
    }
    let ctx = void 0;
    const status = new ParseStatus$e();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$f.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            code: ZodIssueCode$e.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            code: ZodIssueCode$e.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            code: ZodIssueCode$e.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$e(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            code: ZodIssueCode$e.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            code: ZodIssueCode$e.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$f.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$e.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$e.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$e.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$e.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber3({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$e.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber3({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$e.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$e.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$e.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$e.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$e.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$e.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$e.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$e.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$e.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$f.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$e.create = (params) => {
  return new ZodNumber$e({
    checks: [],
    typeName: ZodFirstPartyTypeKind$e.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$e(params)
  });
};
let ZodBigInt$e = class ZodBigInt3 extends ZodType$e {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$e.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$e();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            code: ZodIssueCode$e.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            code: ZodIssueCode$e.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            code: ZodIssueCode$e.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$f.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$e(ctx, {
      code: ZodIssueCode$e.invalid_type,
      expected: ZodParsedType$e.bigint,
      received: ctx.parsedType
    });
    return INVALID$e;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$e.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$e.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$e.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$e.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt3({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$e.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt3({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$e.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$e.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$e.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$e.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$e.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$e.create = (params) => {
  return new ZodBigInt$e({
    checks: [],
    typeName: ZodFirstPartyTypeKind$e.ZodBigInt,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$e(params)
  });
};
let ZodBoolean$e = class ZodBoolean3 extends ZodType$e {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$e.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$e(ctx, {
        code: ZodIssueCode$e.invalid_type,
        expected: ZodParsedType$e.boolean,
        received: ctx.parsedType
      });
      return INVALID$e;
    }
    return OK$e(input.data);
  }
};
ZodBoolean$e.create = (params) => {
  return new ZodBoolean$e({
    typeName: ZodFirstPartyTypeKind$e.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$e(params)
  });
};
let ZodDate$e = class ZodDate3 extends ZodType$e {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$e.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$e(ctx2, {
        code: ZodIssueCode$e.invalid_type,
        expected: ZodParsedType$e.date,
        received: ctx2.parsedType
      });
      return INVALID$e;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$e(ctx2, {
        code: ZodIssueCode$e.invalid_date
      });
      return INVALID$e;
    }
    const status = new ParseStatus$e();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            code: ZodIssueCode$e.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$e(ctx, {
            code: ZodIssueCode$e.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$f.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate3({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$e.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$e.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$e.create = (params) => {
  return new ZodDate$e({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$e.ZodDate,
    ...processCreateParams$e(params)
  });
};
let ZodSymbol$e = class ZodSymbol3 extends ZodType$e {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$e.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$e(ctx, {
        code: ZodIssueCode$e.invalid_type,
        expected: ZodParsedType$e.symbol,
        received: ctx.parsedType
      });
      return INVALID$e;
    }
    return OK$e(input.data);
  }
};
ZodSymbol$e.create = (params) => {
  return new ZodSymbol$e({
    typeName: ZodFirstPartyTypeKind$e.ZodSymbol,
    ...processCreateParams$e(params)
  });
};
let ZodUndefined$e = class ZodUndefined3 extends ZodType$e {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$e.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$e(ctx, {
        code: ZodIssueCode$e.invalid_type,
        expected: ZodParsedType$e.undefined,
        received: ctx.parsedType
      });
      return INVALID$e;
    }
    return OK$e(input.data);
  }
};
ZodUndefined$e.create = (params) => {
  return new ZodUndefined$e({
    typeName: ZodFirstPartyTypeKind$e.ZodUndefined,
    ...processCreateParams$e(params)
  });
};
let ZodNull$e = class ZodNull3 extends ZodType$e {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$e.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$e(ctx, {
        code: ZodIssueCode$e.invalid_type,
        expected: ZodParsedType$e.null,
        received: ctx.parsedType
      });
      return INVALID$e;
    }
    return OK$e(input.data);
  }
};
ZodNull$e.create = (params) => {
  return new ZodNull$e({
    typeName: ZodFirstPartyTypeKind$e.ZodNull,
    ...processCreateParams$e(params)
  });
};
let ZodAny$e = class ZodAny3 extends ZodType$e {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$e(input.data);
  }
};
ZodAny$e.create = (params) => {
  return new ZodAny$e({
    typeName: ZodFirstPartyTypeKind$e.ZodAny,
    ...processCreateParams$e(params)
  });
};
let ZodUnknown$e = class ZodUnknown3 extends ZodType$e {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$e(input.data);
  }
};
ZodUnknown$e.create = (params) => {
  return new ZodUnknown$e({
    typeName: ZodFirstPartyTypeKind$e.ZodUnknown,
    ...processCreateParams$e(params)
  });
};
let ZodNever$e = class ZodNever3 extends ZodType$e {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$e(ctx, {
      code: ZodIssueCode$e.invalid_type,
      expected: ZodParsedType$e.never,
      received: ctx.parsedType
    });
    return INVALID$e;
  }
};
ZodNever$e.create = (params) => {
  return new ZodNever$e({
    typeName: ZodFirstPartyTypeKind$e.ZodNever,
    ...processCreateParams$e(params)
  });
};
let ZodVoid$e = class ZodVoid3 extends ZodType$e {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$e.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$e(ctx, {
        code: ZodIssueCode$e.invalid_type,
        expected: ZodParsedType$e.void,
        received: ctx.parsedType
      });
      return INVALID$e;
    }
    return OK$e(input.data);
  }
};
ZodVoid$e.create = (params) => {
  return new ZodVoid$e({
    typeName: ZodFirstPartyTypeKind$e.ZodVoid,
    ...processCreateParams$e(params)
  });
};
let ZodArray$e = class ZodArray3 extends ZodType$e {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType$e.array) {
      addIssueToContext$e(ctx, {
        code: ZodIssueCode$e.invalid_type,
        expected: ZodParsedType$e.array,
        received: ctx.parsedType
      });
      return INVALID$e;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$e(ctx, {
          code: tooBig ? ZodIssueCode$e.too_big : ZodIssueCode$e.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext$e(ctx, {
          code: ZodIssueCode$e.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext$e(ctx, {
          code: ZodIssueCode$e.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath$e(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$e.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath$e(ctx, item, ctx.path, i));
    });
    return ParseStatus$e.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray3({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$e.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray3({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$e.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray3({
      ...this._def,
      exactLength: { value: len, message: errorUtil$e.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$e.create = (schema, params) => {
  return new ZodArray$e({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$e.ZodArray,
    ...processCreateParams$e(params)
  });
};
function deepPartialify$e(schema) {
  if (schema instanceof ZodObject$e) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$e.create(deepPartialify$e(fieldSchema));
    }
    return new ZodObject$e({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$e) {
    return new ZodArray$e({
      ...schema._def,
      type: deepPartialify$e(schema.element)
    });
  } else if (schema instanceof ZodOptional$e) {
    return ZodOptional$e.create(deepPartialify$e(schema.unwrap()));
  } else if (schema instanceof ZodNullable$e) {
    return ZodNullable$e.create(deepPartialify$e(schema.unwrap()));
  } else if (schema instanceof ZodTuple$e) {
    return ZodTuple$e.create(schema.items.map((item) => deepPartialify$e(item)));
  } else {
    return schema;
  }
}
let ZodObject$e = class ZodObject3 extends ZodType$e {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$f.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$e.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$e(ctx2, {
        code: ZodIssueCode$e.invalid_type,
        expected: ZodParsedType$e.object,
        received: ctx2.parsedType
      });
      return INVALID$e;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$e && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$e(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$e) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$e(ctx, {
            code: ZodIssueCode$e.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$e(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$e.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$e.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$e.errToObj;
    return new ZodObject3({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          var _a, _b;
          const defaultError = ((_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue2, ctx).message) ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil$e.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject3({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject3({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject3({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject3({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$e.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject3({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util$f.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject3({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util$f.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject3({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$e(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util$f.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject3({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util$f.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$e) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject3({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$e(util$f.objectKeys(this.shape));
  }
};
ZodObject$e.create = (shape, params) => {
  return new ZodObject$e({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$e.create(),
    typeName: ZodFirstPartyTypeKind$e.ZodObject,
    ...processCreateParams$e(params)
  });
};
ZodObject$e.strictCreate = (shape, params) => {
  return new ZodObject$e({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$e.create(),
    typeName: ZodFirstPartyTypeKind$e.ZodObject,
    ...processCreateParams$e(params)
  });
};
ZodObject$e.lazycreate = (shape, params) => {
  return new ZodObject$e({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$e.create(),
    typeName: ZodFirstPartyTypeKind$e.ZodObject,
    ...processCreateParams$e(params)
  });
};
let ZodUnion$e = class ZodUnion3 extends ZodType$e {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$e(result.ctx.common.issues));
      addIssueToContext$e(ctx, {
        code: ZodIssueCode$e.invalid_union,
        unionErrors
      });
      return INVALID$e;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$e(issues2));
      addIssueToContext$e(ctx, {
        code: ZodIssueCode$e.invalid_union,
        unionErrors
      });
      return INVALID$e;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$e.create = (types, params) => {
  return new ZodUnion$e({
    options: types,
    typeName: ZodFirstPartyTypeKind$e.ZodUnion,
    ...processCreateParams$e(params)
  });
};
function mergeValues$e(a, b) {
  const aType = getParsedType$e(a);
  const bType = getParsedType$e(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$e.object && bType === ZodParsedType$e.object) {
    const bKeys = util$f.objectKeys(b);
    const sharedKeys = util$f.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$e(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$e.array && bType === ZodParsedType$e.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$e(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$e.date && bType === ZodParsedType$e.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$e = class ZodIntersection3 extends ZodType$e {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$e(parsedLeft) || isAborted$e(parsedRight)) {
        return INVALID$e;
      }
      const merged = mergeValues$e(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$e(ctx, {
          code: ZodIssueCode$e.invalid_intersection_types
        });
        return INVALID$e;
      }
      if (isDirty$e(parsedLeft) || isDirty$e(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$e.create = (left, right, params) => {
  return new ZodIntersection$e({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$e.ZodIntersection,
    ...processCreateParams$e(params)
  });
};
let ZodTuple$e = class ZodTuple3 extends ZodType$e {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$e.array) {
      addIssueToContext$e(ctx, {
        code: ZodIssueCode$e.invalid_type,
        expected: ZodParsedType$e.array,
        received: ctx.parsedType
      });
      return INVALID$e;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$e(ctx, {
        code: ZodIssueCode$e.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$e;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$e(ctx, {
        code: ZodIssueCode$e.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$e(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$e.mergeArray(status, results);
      });
    } else {
      return ParseStatus$e.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple3({
      ...this._def,
      rest
    });
  }
};
ZodTuple$e.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$e({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$e.ZodTuple,
    rest: null,
    ...processCreateParams$e(params)
  });
};
let ZodMap$e = class ZodMap3 extends ZodType$e {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$e.map) {
      addIssueToContext$e(ctx, {
        code: ZodIssueCode$e.invalid_type,
        expected: ZodParsedType$e.map,
        received: ctx.parsedType
      });
      return INVALID$e;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$e(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$e(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$e;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$e;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$e.create = (keyType, valueType, params) => {
  return new ZodMap$e({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$e.ZodMap,
    ...processCreateParams$e(params)
  });
};
let ZodSet$e = class ZodSet3 extends ZodType$e {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$e.set) {
      addIssueToContext$e(ctx, {
        code: ZodIssueCode$e.invalid_type,
        expected: ZodParsedType$e.set,
        received: ctx.parsedType
      });
      return INVALID$e;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext$e(ctx, {
          code: ZodIssueCode$e.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext$e(ctx, {
          code: ZodIssueCode$e.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID$e;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$e(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet3({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$e.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet3({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$e.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$e.create = (valueType, params) => {
  return new ZodSet$e({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$e.ZodSet,
    ...processCreateParams$e(params)
  });
};
let ZodLazy$e = class ZodLazy3 extends ZodType$e {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$e.create = (getter, params) => {
  return new ZodLazy$e({
    getter,
    typeName: ZodFirstPartyTypeKind$e.ZodLazy,
    ...processCreateParams$e(params)
  });
};
let ZodLiteral$e = class ZodLiteral3 extends ZodType$e {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$e(ctx, {
        received: ctx.data,
        code: ZodIssueCode$e.invalid_literal,
        expected: this._def.value
      });
      return INVALID$e;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$e.create = (value, params) => {
  return new ZodLiteral$e({
    value,
    typeName: ZodFirstPartyTypeKind$e.ZodLiteral,
    ...processCreateParams$e(params)
  });
};
function createZodEnum$e(values, params) {
  return new ZodEnum$e({
    values,
    typeName: ZodFirstPartyTypeKind$e.ZodEnum,
    ...processCreateParams$e(params)
  });
}
let ZodEnum$e = class ZodEnum3 extends ZodType$e {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$e(ctx, {
        expected: util$f.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$e.invalid_type
      });
      return INVALID$e;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$e(ctx, {
        received: ctx.data,
        code: ZodIssueCode$e.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$e;
    }
    return OK$e(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum3.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum3.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum$e.create = createZodEnum$e;
let ZodNativeEnum$e = class ZodNativeEnum3 extends ZodType$e {
  _parse(input) {
    const nativeEnumValues = util$f.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$e.string && ctx.parsedType !== ZodParsedType$e.number) {
      const expectedValues = util$f.objectValues(nativeEnumValues);
      addIssueToContext$e(ctx, {
        expected: util$f.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$e.invalid_type
      });
      return INVALID$e;
    }
    if (!this._cache) {
      this._cache = new Set(util$f.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util$f.objectValues(nativeEnumValues);
      addIssueToContext$e(ctx, {
        received: ctx.data,
        code: ZodIssueCode$e.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$e;
    }
    return OK$e(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum$e.create = (values, params) => {
  return new ZodNativeEnum$e({
    values,
    typeName: ZodFirstPartyTypeKind$e.ZodNativeEnum,
    ...processCreateParams$e(params)
  });
};
let ZodPromise$e = class ZodPromise3 extends ZodType$e {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$e.promise && ctx.common.async === false) {
      addIssueToContext$e(ctx, {
        code: ZodIssueCode$e.invalid_type,
        expected: ZodParsedType$e.promise,
        received: ctx.parsedType
      });
      return INVALID$e;
    }
    const promisified = ctx.parsedType === ZodParsedType$e.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$e(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$e.create = (schema, params) => {
  return new ZodPromise$e({
    type: schema,
    typeName: ZodFirstPartyTypeKind$e.ZodPromise,
    ...processCreateParams$e(params)
  });
};
let ZodEffects$e = class ZodEffects3 extends ZodType$e {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$e.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$e(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$e;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$e;
          if (result.status === "dirty")
            return DIRTY$e(result.value);
          if (status.value === "dirty")
            return DIRTY$e(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$e;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$e;
        if (result.status === "dirty")
          return DIRTY$e(result.value);
        if (status.value === "dirty")
          return DIRTY$e(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$e;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$e;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$e(base))
          return INVALID$e;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$e(base))
            return INVALID$e;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util$f.assertNever(effect);
  }
};
ZodEffects$e.create = (schema, effect, params) => {
  return new ZodEffects$e({
    schema,
    typeName: ZodFirstPartyTypeKind$e.ZodEffects,
    effect,
    ...processCreateParams$e(params)
  });
};
ZodEffects$e.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$e({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$e.ZodEffects,
    ...processCreateParams$e(params)
  });
};
let ZodOptional$e = class ZodOptional3 extends ZodType$e {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$e.undefined) {
      return OK$e(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$e.create = (type, params) => {
  return new ZodOptional$e({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$e.ZodOptional,
    ...processCreateParams$e(params)
  });
};
let ZodNullable$e = class ZodNullable3 extends ZodType$e {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$e.null) {
      return OK$e(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$e.create = (type, params) => {
  return new ZodNullable$e({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$e.ZodNullable,
    ...processCreateParams$e(params)
  });
};
let ZodDefault$e = class ZodDefault3 extends ZodType$e {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$e.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$e.create = (type, params) => {
  return new ZodDefault$e({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$e.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$e(params)
  });
};
let ZodCatch$e = class ZodCatch3 extends ZodType$e {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$e(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$e(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$e(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$e.create = (type, params) => {
  return new ZodCatch$e({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$e.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$e(params)
  });
};
let ZodNaN$e = class ZodNaN3 extends ZodType$e {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$e.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$e(ctx, {
        code: ZodIssueCode$e.invalid_type,
        expected: ZodParsedType$e.nan,
        received: ctx.parsedType
      });
      return INVALID$e;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$e.create = (params) => {
  return new ZodNaN$e({
    typeName: ZodFirstPartyTypeKind$e.ZodNaN,
    ...processCreateParams$e(params)
  });
};
let ZodBranded$e = class ZodBranded3 extends ZodType$e {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$e = class ZodPipeline3 extends ZodType$e {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$e;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$e(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$e;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline3({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$e.ZodPipeline
    });
  }
};
let ZodReadonly$e = class ZodReadonly3 extends ZodType$e {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$e(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$e(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$e.create = (type, params) => {
  return new ZodReadonly$e({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$e.ZodReadonly,
    ...processCreateParams$e(params)
  });
};
var ZodFirstPartyTypeKind$e;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$e || (ZodFirstPartyTypeKind$e = {}));
const numberType$d = ZodNumber$e.create;
ZodNever$e.create;
ZodArray$e.create;
const objectType$e = ZodObject$e.create;
const unionType$6 = ZodUnion$e.create;
ZodIntersection$e.create;
ZodTuple$e.create;
ZodEnum$e.create;
ZodPromise$e.create;
ZodOptional$e.create;
ZodNullable$e.create;
const BlitOptionsSchemaComplex = objectType$e({
  src: JimpClassSchema,
  /** the x position to blit the image */
  x: numberType$d().optional(),
  /** the y position to blit the image */
  y: numberType$d().optional(),
  /** the x position from which to crop the source image */
  srcX: numberType$d().optional(),
  /** the y position from which to crop the source image */
  srcY: numberType$d().optional(),
  /** the width to which to crop the source image */
  srcW: numberType$d().optional(),
  /** the height to which to crop the source image */
  srcH: numberType$d().optional()
});
const BlitOptionsSchema = unionType$6([JimpClassSchema, BlitOptionsSchemaComplex]);
const methods$h = {
  /**
   * Short for "bit-block transfer".
   * It involves the transfer of a block of pixel data from one area of a computer's memory to another area, typically for the purpose of rendering images on the screen or manipulating them in various ways.
   * It's a fundamental operation in computer graphics utilized in various applications, from operating systems to video games.
   *
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   * const parrot = await Jimp.read("test/party-parrot.png");
   *
   * image.blit({ src: parrot, x: 10, y: 10 });
   * ```
   */
  blit(image, options) {
    const parsed = BlitOptionsSchema.parse(options);
    let {
      // eslint-disable-next-line prefer-const
      src: src2,
      x: x2 = 0,
      y: y2 = 0,
      srcX = 0,
      srcY = 0,
      srcW = src2.bitmap.width,
      srcH = src2.bitmap.height
    } = "bitmap" in parsed ? { src: parsed } : parsed;
    if (!("bitmap" in src2)) {
      throw new Error("The source must be a Jimp image");
    }
    if (typeof x2 !== "number" || typeof y2 !== "number") {
      throw new Error("x and y must be numbers");
    }
    x2 = Math.round(x2);
    y2 = Math.round(y2);
    srcX = Math.round(srcX);
    srcY = Math.round(srcY);
    srcW = Math.round(srcW);
    srcH = Math.round(srcH);
    const maxWidth = image.bitmap.width;
    const maxHeight = image.bitmap.height;
    scan(src2, srcX, srcY, srcW, srcH, function(sx, sy, idx) {
      const xOffset = x2 + sx - srcX;
      const yOffset = y2 + sy - srcY;
      if (xOffset >= 0 && yOffset >= 0 && maxWidth - xOffset > 0 && maxHeight - yOffset > 0) {
        const dstIdx = image.getPixelIndex(xOffset, yOffset);
        const srcColor = {
          r: src2.bitmap.data[idx] || 0,
          g: src2.bitmap.data[idx + 1] || 0,
          b: src2.bitmap.data[idx + 2] || 0,
          a: src2.bitmap.data[idx + 3] || 0
        };
        const dst = {
          r: image.bitmap.data[dstIdx] || 0,
          g: image.bitmap.data[dstIdx + 1] || 0,
          b: image.bitmap.data[dstIdx + 2] || 0,
          a: image.bitmap.data[dstIdx + 3] || 0
        };
        image.bitmap.data[dstIdx] = (srcColor.a * (srcColor.r - dst.r) - dst.r + 255 >> 8) + dst.r;
        image.bitmap.data[dstIdx + 1] = (srcColor.a * (srcColor.g - dst.g) - dst.g + 255 >> 8) + dst.g;
        image.bitmap.data[dstIdx + 2] = (srcColor.a * (srcColor.b - dst.b) - dst.b + 255 >> 8) + dst.b;
        image.bitmap.data[dstIdx + 3] = limit255(dst.a + srcColor.a);
      }
    });
    return image;
  }
};
const mulTable = [
  1,
  57,
  41,
  21,
  203,
  34,
  97,
  73,
  227,
  91,
  149,
  62,
  105,
  45,
  39,
  137,
  241,
  107,
  3,
  173,
  39,
  71,
  65,
  238,
  219,
  101,
  187,
  87,
  81,
  151,
  141,
  133,
  249,
  117,
  221,
  209,
  197,
  187,
  177,
  169,
  5,
  153,
  73,
  139,
  133,
  127,
  243,
  233,
  223,
  107,
  103,
  99,
  191,
  23,
  177,
  171,
  165,
  159,
  77,
  149,
  9,
  139,
  135,
  131,
  253,
  245,
  119,
  231,
  224,
  109,
  211,
  103,
  25,
  195,
  189,
  23,
  45,
  175,
  171,
  83,
  81,
  79,
  155,
  151,
  147,
  9,
  141,
  137,
  67,
  131,
  129,
  251,
  123,
  30,
  235,
  115,
  113,
  221,
  217,
  53,
  13,
  51,
  50,
  49,
  193,
  189,
  185,
  91,
  179,
  175,
  43,
  169,
  83,
  163,
  5,
  79,
  155,
  19,
  75,
  147,
  145,
  143,
  35,
  69,
  17,
  67,
  33,
  65,
  255,
  251,
  247,
  243,
  239,
  59,
  29,
  229,
  113,
  111,
  219,
  27,
  213,
  105,
  207,
  51,
  201,
  199,
  49,
  193,
  191,
  47,
  93,
  183,
  181,
  179,
  11,
  87,
  43,
  85,
  167,
  165,
  163,
  161,
  159,
  157,
  155,
  77,
  19,
  75,
  37,
  73,
  145,
  143,
  141,
  35,
  138,
  137,
  135,
  67,
  33,
  131,
  129,
  255,
  63,
  250,
  247,
  61,
  121,
  239,
  237,
  117,
  29,
  229,
  227,
  225,
  111,
  55,
  109,
  216,
  213,
  211,
  209,
  207,
  205,
  203,
  201,
  199,
  197,
  195,
  193,
  48,
  190,
  47,
  93,
  185,
  183,
  181,
  179,
  178,
  176,
  175,
  173,
  171,
  85,
  21,
  167,
  165,
  41,
  163,
  161,
  5,
  79,
  157,
  78,
  154,
  153,
  19,
  75,
  149,
  74,
  147,
  73,
  144,
  143,
  71,
  141,
  140,
  139,
  137,
  17,
  135,
  134,
  133,
  66,
  131,
  65,
  129,
  1
];
const shgTable = [
  0,
  9,
  10,
  10,
  14,
  12,
  14,
  14,
  16,
  15,
  16,
  15,
  16,
  15,
  15,
  17,
  18,
  17,
  12,
  18,
  16,
  17,
  17,
  19,
  19,
  18,
  19,
  18,
  18,
  19,
  19,
  19,
  20,
  19,
  20,
  20,
  20,
  20,
  20,
  20,
  15,
  20,
  19,
  20,
  20,
  20,
  21,
  21,
  21,
  20,
  20,
  20,
  21,
  18,
  21,
  21,
  21,
  21,
  20,
  21,
  17,
  21,
  21,
  21,
  22,
  22,
  21,
  22,
  22,
  21,
  22,
  21,
  19,
  22,
  22,
  19,
  20,
  22,
  22,
  21,
  21,
  21,
  22,
  22,
  22,
  18,
  22,
  22,
  21,
  22,
  22,
  23,
  22,
  20,
  23,
  22,
  22,
  23,
  23,
  21,
  19,
  21,
  21,
  21,
  23,
  23,
  23,
  22,
  23,
  23,
  21,
  23,
  22,
  23,
  18,
  22,
  23,
  20,
  22,
  23,
  23,
  23,
  21,
  22,
  20,
  22,
  21,
  22,
  24,
  24,
  24,
  24,
  24,
  22,
  21,
  24,
  23,
  23,
  24,
  21,
  24,
  23,
  24,
  22,
  24,
  24,
  22,
  24,
  24,
  22,
  23,
  24,
  24,
  24,
  20,
  23,
  22,
  23,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  23,
  21,
  23,
  22,
  23,
  24,
  24,
  24,
  22,
  24,
  24,
  24,
  23,
  22,
  24,
  24,
  25,
  23,
  25,
  25,
  23,
  24,
  25,
  25,
  24,
  22,
  25,
  25,
  25,
  24,
  23,
  24,
  25,
  25,
  25,
  25,
  25,
  25,
  25,
  25,
  25,
  25,
  25,
  25,
  23,
  25,
  23,
  24,
  25,
  25,
  25,
  25,
  25,
  25,
  25,
  25,
  25,
  24,
  22,
  25,
  25,
  23,
  25,
  25,
  20,
  24,
  25,
  24,
  25,
  25,
  22,
  24,
  25,
  24,
  25,
  24,
  25,
  25,
  24,
  25,
  25,
  25,
  25,
  22,
  25,
  25,
  25,
  24,
  25,
  24,
  25,
  18
];
const methods$g = {
  /**
   * A fast blur algorithm that produces similar effect to a Gaussian blur - but MUCH quicker
   * @param r the pixel radius of the blur
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.blur(5);
   * ```
   */
  blur(image, r) {
    if (typeof r !== "number") {
      throw new Error("r must be a number");
    }
    if (r < 1) {
      throw new Error("r must be greater than 0");
    }
    let rsum;
    let gsum;
    let bsum;
    let asum;
    let x2;
    let y2;
    let i;
    let p;
    let p1;
    let p2;
    let yp;
    let yi;
    let yw;
    const wm = image.bitmap.width - 1;
    const hm = image.bitmap.height - 1;
    const rad1 = r + 1;
    const mulSum = mulTable[r];
    const shgSum = shgTable[r];
    const red = [];
    const green = [];
    const blue = [];
    const alpha = [];
    const vmin = [];
    const vmax = [];
    let iterations = 2;
    while (iterations-- > 0) {
      yi = 0;
      yw = 0;
      for (y2 = 0; y2 < image.bitmap.height; y2++) {
        rsum = image.bitmap.data[yw] * rad1;
        gsum = image.bitmap.data[yw + 1] * rad1;
        bsum = image.bitmap.data[yw + 2] * rad1;
        asum = image.bitmap.data[yw + 3] * rad1;
        for (i = 1; i <= r; i++) {
          p = yw + ((i > wm ? wm : i) << 2);
          rsum += image.bitmap.data[p++];
          gsum += image.bitmap.data[p++];
          bsum += image.bitmap.data[p++];
          asum += image.bitmap.data[p];
        }
        for (x2 = 0; x2 < image.bitmap.width; x2++) {
          red[yi] = rsum;
          green[yi] = gsum;
          blue[yi] = bsum;
          alpha[yi] = asum;
          if (y2 === 0) {
            vmin[x2] = ((p = x2 + rad1) < wm ? p : wm) << 2;
            vmax[x2] = (p = x2 - r) > 0 ? p << 2 : 0;
          }
          p1 = yw + vmin[x2];
          p2 = yw + vmax[x2];
          rsum += image.bitmap.data[p1++] - image.bitmap.data[p2++];
          gsum += image.bitmap.data[p1++] - image.bitmap.data[p2++];
          bsum += image.bitmap.data[p1++] - image.bitmap.data[p2++];
          asum += image.bitmap.data[p1] - image.bitmap.data[p2++];
          yi++;
        }
        yw += image.bitmap.width << 2;
      }
      for (x2 = 0; x2 < image.bitmap.width; x2++) {
        yp = x2;
        rsum = red[yp] * rad1;
        gsum = green[yp] * rad1;
        bsum = blue[yp] * rad1;
        asum = alpha[yp] * rad1;
        for (i = 1; i <= r; i++) {
          yp += i > hm ? 0 : image.bitmap.width;
          rsum += red[yp];
          gsum += green[yp];
          bsum += blue[yp];
          asum += alpha[yp];
        }
        yi = x2 << 2;
        for (y2 = 0; y2 < image.bitmap.height; y2++) {
          image.bitmap.data[yi] = limit255(rsum * mulSum >>> shgSum);
          image.bitmap.data[yi + 1] = limit255(gsum * mulSum >>> shgSum);
          image.bitmap.data[yi + 2] = limit255(bsum * mulSum >>> shgSum);
          image.bitmap.data[yi + 3] = limit255(asum * mulSum >>> shgSum);
          if (x2 === 0) {
            vmin[y2] = ((p = y2 + rad1) < hm ? p : hm) * image.bitmap.width;
            vmax[y2] = (p = y2 - r) > 0 ? p * image.bitmap.width : 0;
          }
          p1 = x2 + vmin[y2];
          p2 = x2 + vmax[y2];
          rsum += red[p1] - red[p2];
          gsum += green[p1] - green[p2];
          bsum += blue[p1] - blue[p2];
          asum += alpha[p1] - alpha[p2];
          yi += image.bitmap.width << 2;
        }
      }
    }
    return image;
  },
  // http://blog.ivank.net/fastest-gaussian-blur.html
  /**
   * Applies a true Gaussian blur to the image (warning: this is VERY slow)
   * @param r the pixel radius of the blur
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.gaussian(15);
   * ```
   */
  gaussian(image, r) {
    if (typeof r !== "number") {
      throw new Error("r must be a number");
    }
    if (r < 1) {
      throw new Error("r must be greater than 0");
    }
    const rs = Math.ceil(r * 2.57);
    const range = rs * 2 + 1;
    const rr2 = r * r * 2;
    const rr2pi = rr2 * Math.PI;
    const weights = [];
    for (let y2 = 0; y2 < range; y2++) {
      const weightsRow = [];
      for (let x2 = 0; x2 < range; x2++) {
        const dsq = (x2 - rs) ** 2 + (y2 - rs) ** 2;
        weightsRow[x2] = Math.exp(-dsq / rr2) / rr2pi;
      }
      weights.push(weightsRow);
    }
    for (let y2 = 0; y2 < image.bitmap.height; y2++) {
      for (let x2 = 0; x2 < image.bitmap.width; x2++) {
        let red = 0;
        let green = 0;
        let blue = 0;
        let alpha = 0;
        let wsum = 0;
        for (let iy = 0; iy < range; iy++) {
          for (let ix = 0; ix < range; ix++) {
            const x1 = Math.min(image.bitmap.width - 1, Math.max(0, ix + x2 - rs));
            const y1 = Math.min(image.bitmap.height - 1, Math.max(0, iy + y2 - rs));
            const weight = weights[iy][ix];
            const idx2 = y1 * image.bitmap.width + x1 << 2;
            red += image.bitmap.data[idx2] * weight;
            green += image.bitmap.data[idx2 + 1] * weight;
            blue += image.bitmap.data[idx2 + 2] * weight;
            alpha += image.bitmap.data[idx2 + 3] * weight;
            wsum += weight;
          }
          const idx = y2 * image.bitmap.width + x2 << 2;
          image.bitmap.data[idx] = Math.round(red / wsum);
          image.bitmap.data[idx + 1] = Math.round(green / wsum);
          image.bitmap.data[idx + 2] = Math.round(blue / wsum);
          image.bitmap.data[idx + 3] = Math.round(alpha / wsum);
        }
      }
    }
    return image;
  }
};
var util$e;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$e || (util$e = {}));
var objectUtil$d;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$d || (objectUtil$d = {}));
const ZodParsedType$d = util$e.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$d = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$d.undefined;
    case "string":
      return ZodParsedType$d.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType$d.nan : ZodParsedType$d.number;
    case "boolean":
      return ZodParsedType$d.boolean;
    case "function":
      return ZodParsedType$d.function;
    case "bigint":
      return ZodParsedType$d.bigint;
    case "symbol":
      return ZodParsedType$d.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$d.array;
      }
      if (data === null) {
        return ZodParsedType$d.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$d.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$d.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$d.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$d.date;
      }
      return ZodParsedType$d.object;
    default:
      return ZodParsedType$d.unknown;
  }
};
const ZodIssueCode$d = util$e.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
let ZodError$d = class ZodError4 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue2 of error.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError4)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$e.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$d.create = (issues) => {
  const error = new ZodError$d(issues);
  return error;
};
const errorMap$d = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode$d.invalid_type:
      if (issue2.received === ZodParsedType$d.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode$d.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util$e.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$d.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$e.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode$d.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$d.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$e.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode$d.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$e.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode$d.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$d.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$d.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$d.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util$e.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$d.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$d.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$d.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$d.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$d.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode$d.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$e.assertNever(issue2);
  }
  return { message };
};
let overrideErrorMap$d = errorMap$d;
function getErrorMap$d() {
  return overrideErrorMap$d;
}
const makeIssue$d = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext$d(ctx, issueData) {
  const overrideMap = getErrorMap$d();
  const issue2 = makeIssue$d({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$d ? void 0 : errorMap$d
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue2);
}
let ParseStatus$d = class ParseStatus4 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$d;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus4.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$d;
      if (value.status === "aborted")
        return INVALID$d;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$d = Object.freeze({
  status: "aborted"
});
const DIRTY$d = (value) => ({ status: "dirty", value });
const OK$d = (value) => ({ status: "valid", value });
const isAborted$d = (x2) => x2.status === "aborted";
const isDirty$d = (x2) => x2.status === "dirty";
const isValid$d = (x2) => x2.status === "valid";
const isAsync$d = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil$d;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil$d || (errorUtil$d = {}));
let ParseInputLazyPath$d = class ParseInputLazyPath4 {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$d = (ctx, result) => {
  if (isValid$d(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$d(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$d(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$d = class ZodType4 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$d(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$d(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$d(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$d(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$d(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: (params == null ? void 0 : params.async) ?? false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$d(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$d(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$d(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$d(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$d(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$d(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$d(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$d(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$d.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$d({
      schema: this,
      typeName: ZodFirstPartyTypeKind$d.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$d.create(this, this._def);
  }
  nullable() {
    return ZodNullable$d.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$d.create(this);
  }
  promise() {
    return ZodPromise$d.create(this, this._def);
  }
  or(option) {
    return ZodUnion$d.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$d.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects$d({
      ...processCreateParams$d(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$d.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault$d({
      ...processCreateParams$d(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$d.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$d({
      typeName: ZodFirstPartyTypeKind$d.ZodBranded,
      type: this,
      ...processCreateParams$d(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch$d({
      ...processCreateParams$d(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$d.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$d.create(this, target);
  }
  readonly() {
    return ZodReadonly$d.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$d = /^c[^\s-]{8,}$/i;
const cuid2Regex$d = /^[0-9a-z]+$/;
const ulidRegex$d = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$d = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$d = /^[a-z0-9_-]{21}$/i;
const jwtRegex$d = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$d = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$d = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$d = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$d;
const ipv4Regex$d = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$d = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$d = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$d = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$d = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$d = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$d = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$d = new RegExp(`^${dateRegexSource$d}$`);
function timeRegexSource$d(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex$d(args) {
  return new RegExp(`^${timeRegexSource$d(args)}$`);
}
function datetimeRegex$d(args) {
  let regex = `${dateRegexSource$d}T${timeRegexSource$d(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$d(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex$d.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex$d.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$d(jwt, alg) {
  if (!jwtRegex$d.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr$d(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex$d.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex$d.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$d = class ZodString4 extends ZodType$d {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$d.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$d(ctx2, {
        code: ZodIssueCode$d.invalid_type,
        expected: ZodParsedType$d.string,
        received: ctx2.parsedType
      });
      return INVALID$d;
    }
    const status = new ParseStatus$d();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            code: ZodIssueCode$d.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            code: ZodIssueCode$d.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$d(ctx, {
              code: ZodIssueCode$d.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$d(ctx, {
              code: ZodIssueCode$d.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$d.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            validation: "email",
            code: ZodIssueCode$d.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$d) {
          emojiRegex$d = new RegExp(_emojiRegex$d, "u");
        }
        if (!emojiRegex$d.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            validation: "emoji",
            code: ZodIssueCode$d.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$d.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            validation: "uuid",
            code: ZodIssueCode$d.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$d.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$d.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$d.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            validation: "cuid",
            code: ZodIssueCode$d.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$d.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$d.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$d.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            validation: "ulid",
            code: ZodIssueCode$d.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            validation: "url",
            code: ZodIssueCode$d.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            validation: "regex",
            code: ZodIssueCode$d.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            code: ZodIssueCode$d.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            code: ZodIssueCode$d.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            code: ZodIssueCode$d.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$d(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            code: ZodIssueCode$d.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$d;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            code: ZodIssueCode$d.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$d(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            code: ZodIssueCode$d.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$d.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            validation: "duration",
            code: ZodIssueCode$d.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$d(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            validation: "ip",
            code: ZodIssueCode$d.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$d(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            validation: "jwt",
            code: ZodIssueCode$d.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$d(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            validation: "cidr",
            code: ZodIssueCode$d.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$d.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            validation: "base64",
            code: ZodIssueCode$d.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$d.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            validation: "base64url",
            code: ZodIssueCode$d.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$e.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$d.invalid_string,
      ...errorUtil$d.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString4({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$d.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$d.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$d.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$d.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$d.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$d.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$d.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$d.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$d.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$d.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$d.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$d.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$d.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (options == null ? void 0 : options.offset) ?? false,
      local: (options == null ? void 0 : options.local) ?? false,
      ...errorUtil$d.errToObj(options == null ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      ...errorUtil$d.errToObj(options == null ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$d.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$d.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position,
      ...errorUtil$d.errToObj(options == null ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$d.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$d.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$d.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$d.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$d.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$d.errToObj(message));
  }
  trim() {
    return new ZodString4({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString4({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString4({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$d.create = (params) => {
  return new ZodString$d({
    checks: [],
    typeName: ZodFirstPartyTypeKind$d.ZodString,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$d(params)
  });
};
function floatSafeRemainder$d(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
let ZodNumber$d = class ZodNumber4 extends ZodType$d {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$d.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$d(ctx2, {
        code: ZodIssueCode$d.invalid_type,
        expected: ZodParsedType$d.number,
        received: ctx2.parsedType
      });
      return INVALID$d;
    }
    let ctx = void 0;
    const status = new ParseStatus$d();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$e.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            code: ZodIssueCode$d.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            code: ZodIssueCode$d.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            code: ZodIssueCode$d.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$d(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            code: ZodIssueCode$d.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            code: ZodIssueCode$d.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$e.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$d.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$d.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$d.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$d.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber4({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$d.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber4({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$d.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$d.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$d.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$d.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$d.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$d.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$d.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$d.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$d.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$e.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$d.create = (params) => {
  return new ZodNumber$d({
    checks: [],
    typeName: ZodFirstPartyTypeKind$d.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$d(params)
  });
};
let ZodBigInt$d = class ZodBigInt4 extends ZodType$d {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$d.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$d();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            code: ZodIssueCode$d.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            code: ZodIssueCode$d.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            code: ZodIssueCode$d.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$e.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$d(ctx, {
      code: ZodIssueCode$d.invalid_type,
      expected: ZodParsedType$d.bigint,
      received: ctx.parsedType
    });
    return INVALID$d;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$d.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$d.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$d.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$d.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt4({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$d.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt4({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$d.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$d.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$d.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$d.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$d.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$d.create = (params) => {
  return new ZodBigInt$d({
    checks: [],
    typeName: ZodFirstPartyTypeKind$d.ZodBigInt,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$d(params)
  });
};
let ZodBoolean$d = class ZodBoolean4 extends ZodType$d {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$d.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$d(ctx, {
        code: ZodIssueCode$d.invalid_type,
        expected: ZodParsedType$d.boolean,
        received: ctx.parsedType
      });
      return INVALID$d;
    }
    return OK$d(input.data);
  }
};
ZodBoolean$d.create = (params) => {
  return new ZodBoolean$d({
    typeName: ZodFirstPartyTypeKind$d.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$d(params)
  });
};
let ZodDate$d = class ZodDate4 extends ZodType$d {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$d.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$d(ctx2, {
        code: ZodIssueCode$d.invalid_type,
        expected: ZodParsedType$d.date,
        received: ctx2.parsedType
      });
      return INVALID$d;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$d(ctx2, {
        code: ZodIssueCode$d.invalid_date
      });
      return INVALID$d;
    }
    const status = new ParseStatus$d();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            code: ZodIssueCode$d.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$d(ctx, {
            code: ZodIssueCode$d.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$e.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate4({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$d.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$d.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$d.create = (params) => {
  return new ZodDate$d({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$d.ZodDate,
    ...processCreateParams$d(params)
  });
};
let ZodSymbol$d = class ZodSymbol4 extends ZodType$d {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$d.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$d(ctx, {
        code: ZodIssueCode$d.invalid_type,
        expected: ZodParsedType$d.symbol,
        received: ctx.parsedType
      });
      return INVALID$d;
    }
    return OK$d(input.data);
  }
};
ZodSymbol$d.create = (params) => {
  return new ZodSymbol$d({
    typeName: ZodFirstPartyTypeKind$d.ZodSymbol,
    ...processCreateParams$d(params)
  });
};
let ZodUndefined$d = class ZodUndefined4 extends ZodType$d {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$d.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$d(ctx, {
        code: ZodIssueCode$d.invalid_type,
        expected: ZodParsedType$d.undefined,
        received: ctx.parsedType
      });
      return INVALID$d;
    }
    return OK$d(input.data);
  }
};
ZodUndefined$d.create = (params) => {
  return new ZodUndefined$d({
    typeName: ZodFirstPartyTypeKind$d.ZodUndefined,
    ...processCreateParams$d(params)
  });
};
let ZodNull$d = class ZodNull4 extends ZodType$d {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$d.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$d(ctx, {
        code: ZodIssueCode$d.invalid_type,
        expected: ZodParsedType$d.null,
        received: ctx.parsedType
      });
      return INVALID$d;
    }
    return OK$d(input.data);
  }
};
ZodNull$d.create = (params) => {
  return new ZodNull$d({
    typeName: ZodFirstPartyTypeKind$d.ZodNull,
    ...processCreateParams$d(params)
  });
};
let ZodAny$d = class ZodAny4 extends ZodType$d {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$d(input.data);
  }
};
ZodAny$d.create = (params) => {
  return new ZodAny$d({
    typeName: ZodFirstPartyTypeKind$d.ZodAny,
    ...processCreateParams$d(params)
  });
};
let ZodUnknown$d = class ZodUnknown4 extends ZodType$d {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$d(input.data);
  }
};
ZodUnknown$d.create = (params) => {
  return new ZodUnknown$d({
    typeName: ZodFirstPartyTypeKind$d.ZodUnknown,
    ...processCreateParams$d(params)
  });
};
let ZodNever$d = class ZodNever4 extends ZodType$d {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$d(ctx, {
      code: ZodIssueCode$d.invalid_type,
      expected: ZodParsedType$d.never,
      received: ctx.parsedType
    });
    return INVALID$d;
  }
};
ZodNever$d.create = (params) => {
  return new ZodNever$d({
    typeName: ZodFirstPartyTypeKind$d.ZodNever,
    ...processCreateParams$d(params)
  });
};
let ZodVoid$d = class ZodVoid4 extends ZodType$d {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$d.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$d(ctx, {
        code: ZodIssueCode$d.invalid_type,
        expected: ZodParsedType$d.void,
        received: ctx.parsedType
      });
      return INVALID$d;
    }
    return OK$d(input.data);
  }
};
ZodVoid$d.create = (params) => {
  return new ZodVoid$d({
    typeName: ZodFirstPartyTypeKind$d.ZodVoid,
    ...processCreateParams$d(params)
  });
};
let ZodArray$d = class ZodArray4 extends ZodType$d {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType$d.array) {
      addIssueToContext$d(ctx, {
        code: ZodIssueCode$d.invalid_type,
        expected: ZodParsedType$d.array,
        received: ctx.parsedType
      });
      return INVALID$d;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$d(ctx, {
          code: tooBig ? ZodIssueCode$d.too_big : ZodIssueCode$d.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext$d(ctx, {
          code: ZodIssueCode$d.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext$d(ctx, {
          code: ZodIssueCode$d.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath$d(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$d.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath$d(ctx, item, ctx.path, i));
    });
    return ParseStatus$d.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray4({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$d.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray4({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$d.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray4({
      ...this._def,
      exactLength: { value: len, message: errorUtil$d.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$d.create = (schema, params) => {
  return new ZodArray$d({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$d.ZodArray,
    ...processCreateParams$d(params)
  });
};
function deepPartialify$d(schema) {
  if (schema instanceof ZodObject$d) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$d.create(deepPartialify$d(fieldSchema));
    }
    return new ZodObject$d({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$d) {
    return new ZodArray$d({
      ...schema._def,
      type: deepPartialify$d(schema.element)
    });
  } else if (schema instanceof ZodOptional$d) {
    return ZodOptional$d.create(deepPartialify$d(schema.unwrap()));
  } else if (schema instanceof ZodNullable$d) {
    return ZodNullable$d.create(deepPartialify$d(schema.unwrap()));
  } else if (schema instanceof ZodTuple$d) {
    return ZodTuple$d.create(schema.items.map((item) => deepPartialify$d(item)));
  } else {
    return schema;
  }
}
let ZodObject$d = class ZodObject4 extends ZodType$d {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$e.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$d.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$d(ctx2, {
        code: ZodIssueCode$d.invalid_type,
        expected: ZodParsedType$d.object,
        received: ctx2.parsedType
      });
      return INVALID$d;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$d && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$d(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$d) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$d(ctx, {
            code: ZodIssueCode$d.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$d(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$d.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$d.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$d.errToObj;
    return new ZodObject4({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          var _a, _b;
          const defaultError = ((_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue2, ctx).message) ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil$d.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject4({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject4({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject4({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject4({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$d.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject4({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util$e.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject4({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util$e.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject4({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$d(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util$e.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject4({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util$e.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$d) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject4({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$d(util$e.objectKeys(this.shape));
  }
};
ZodObject$d.create = (shape, params) => {
  return new ZodObject$d({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$d.create(),
    typeName: ZodFirstPartyTypeKind$d.ZodObject,
    ...processCreateParams$d(params)
  });
};
ZodObject$d.strictCreate = (shape, params) => {
  return new ZodObject$d({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$d.create(),
    typeName: ZodFirstPartyTypeKind$d.ZodObject,
    ...processCreateParams$d(params)
  });
};
ZodObject$d.lazycreate = (shape, params) => {
  return new ZodObject$d({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$d.create(),
    typeName: ZodFirstPartyTypeKind$d.ZodObject,
    ...processCreateParams$d(params)
  });
};
let ZodUnion$d = class ZodUnion4 extends ZodType$d {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$d(result.ctx.common.issues));
      addIssueToContext$d(ctx, {
        code: ZodIssueCode$d.invalid_union,
        unionErrors
      });
      return INVALID$d;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$d(issues2));
      addIssueToContext$d(ctx, {
        code: ZodIssueCode$d.invalid_union,
        unionErrors
      });
      return INVALID$d;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$d.create = (types, params) => {
  return new ZodUnion$d({
    options: types,
    typeName: ZodFirstPartyTypeKind$d.ZodUnion,
    ...processCreateParams$d(params)
  });
};
function mergeValues$d(a, b) {
  const aType = getParsedType$d(a);
  const bType = getParsedType$d(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$d.object && bType === ZodParsedType$d.object) {
    const bKeys = util$e.objectKeys(b);
    const sharedKeys = util$e.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$d(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$d.array && bType === ZodParsedType$d.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$d(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$d.date && bType === ZodParsedType$d.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$d = class ZodIntersection4 extends ZodType$d {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$d(parsedLeft) || isAborted$d(parsedRight)) {
        return INVALID$d;
      }
      const merged = mergeValues$d(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$d(ctx, {
          code: ZodIssueCode$d.invalid_intersection_types
        });
        return INVALID$d;
      }
      if (isDirty$d(parsedLeft) || isDirty$d(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$d.create = (left, right, params) => {
  return new ZodIntersection$d({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$d.ZodIntersection,
    ...processCreateParams$d(params)
  });
};
let ZodTuple$d = class ZodTuple4 extends ZodType$d {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$d.array) {
      addIssueToContext$d(ctx, {
        code: ZodIssueCode$d.invalid_type,
        expected: ZodParsedType$d.array,
        received: ctx.parsedType
      });
      return INVALID$d;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$d(ctx, {
        code: ZodIssueCode$d.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$d;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$d(ctx, {
        code: ZodIssueCode$d.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$d(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$d.mergeArray(status, results);
      });
    } else {
      return ParseStatus$d.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple4({
      ...this._def,
      rest
    });
  }
};
ZodTuple$d.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$d({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$d.ZodTuple,
    rest: null,
    ...processCreateParams$d(params)
  });
};
let ZodMap$d = class ZodMap4 extends ZodType$d {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$d.map) {
      addIssueToContext$d(ctx, {
        code: ZodIssueCode$d.invalid_type,
        expected: ZodParsedType$d.map,
        received: ctx.parsedType
      });
      return INVALID$d;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$d(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$d(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$d;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$d;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$d.create = (keyType, valueType, params) => {
  return new ZodMap$d({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$d.ZodMap,
    ...processCreateParams$d(params)
  });
};
let ZodSet$d = class ZodSet4 extends ZodType$d {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$d.set) {
      addIssueToContext$d(ctx, {
        code: ZodIssueCode$d.invalid_type,
        expected: ZodParsedType$d.set,
        received: ctx.parsedType
      });
      return INVALID$d;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext$d(ctx, {
          code: ZodIssueCode$d.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext$d(ctx, {
          code: ZodIssueCode$d.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID$d;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$d(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet4({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$d.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet4({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$d.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$d.create = (valueType, params) => {
  return new ZodSet$d({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$d.ZodSet,
    ...processCreateParams$d(params)
  });
};
let ZodLazy$d = class ZodLazy4 extends ZodType$d {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$d.create = (getter, params) => {
  return new ZodLazy$d({
    getter,
    typeName: ZodFirstPartyTypeKind$d.ZodLazy,
    ...processCreateParams$d(params)
  });
};
let ZodLiteral$d = class ZodLiteral4 extends ZodType$d {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$d(ctx, {
        received: ctx.data,
        code: ZodIssueCode$d.invalid_literal,
        expected: this._def.value
      });
      return INVALID$d;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$d.create = (value, params) => {
  return new ZodLiteral$d({
    value,
    typeName: ZodFirstPartyTypeKind$d.ZodLiteral,
    ...processCreateParams$d(params)
  });
};
function createZodEnum$d(values, params) {
  return new ZodEnum$d({
    values,
    typeName: ZodFirstPartyTypeKind$d.ZodEnum,
    ...processCreateParams$d(params)
  });
}
let ZodEnum$d = class ZodEnum4 extends ZodType$d {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$d(ctx, {
        expected: util$e.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$d.invalid_type
      });
      return INVALID$d;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$d(ctx, {
        received: ctx.data,
        code: ZodIssueCode$d.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$d;
    }
    return OK$d(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum4.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum4.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum$d.create = createZodEnum$d;
let ZodNativeEnum$d = class ZodNativeEnum4 extends ZodType$d {
  _parse(input) {
    const nativeEnumValues = util$e.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$d.string && ctx.parsedType !== ZodParsedType$d.number) {
      const expectedValues = util$e.objectValues(nativeEnumValues);
      addIssueToContext$d(ctx, {
        expected: util$e.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$d.invalid_type
      });
      return INVALID$d;
    }
    if (!this._cache) {
      this._cache = new Set(util$e.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util$e.objectValues(nativeEnumValues);
      addIssueToContext$d(ctx, {
        received: ctx.data,
        code: ZodIssueCode$d.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$d;
    }
    return OK$d(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum$d.create = (values, params) => {
  return new ZodNativeEnum$d({
    values,
    typeName: ZodFirstPartyTypeKind$d.ZodNativeEnum,
    ...processCreateParams$d(params)
  });
};
let ZodPromise$d = class ZodPromise4 extends ZodType$d {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$d.promise && ctx.common.async === false) {
      addIssueToContext$d(ctx, {
        code: ZodIssueCode$d.invalid_type,
        expected: ZodParsedType$d.promise,
        received: ctx.parsedType
      });
      return INVALID$d;
    }
    const promisified = ctx.parsedType === ZodParsedType$d.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$d(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$d.create = (schema, params) => {
  return new ZodPromise$d({
    type: schema,
    typeName: ZodFirstPartyTypeKind$d.ZodPromise,
    ...processCreateParams$d(params)
  });
};
let ZodEffects$d = class ZodEffects4 extends ZodType$d {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$d.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$d(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$d;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$d;
          if (result.status === "dirty")
            return DIRTY$d(result.value);
          if (status.value === "dirty")
            return DIRTY$d(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$d;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$d;
        if (result.status === "dirty")
          return DIRTY$d(result.value);
        if (status.value === "dirty")
          return DIRTY$d(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$d;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$d;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$d(base))
          return INVALID$d;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$d(base))
            return INVALID$d;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util$e.assertNever(effect);
  }
};
ZodEffects$d.create = (schema, effect, params) => {
  return new ZodEffects$d({
    schema,
    typeName: ZodFirstPartyTypeKind$d.ZodEffects,
    effect,
    ...processCreateParams$d(params)
  });
};
ZodEffects$d.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$d({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$d.ZodEffects,
    ...processCreateParams$d(params)
  });
};
let ZodOptional$d = class ZodOptional4 extends ZodType$d {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$d.undefined) {
      return OK$d(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$d.create = (type, params) => {
  return new ZodOptional$d({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$d.ZodOptional,
    ...processCreateParams$d(params)
  });
};
let ZodNullable$d = class ZodNullable4 extends ZodType$d {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$d.null) {
      return OK$d(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$d.create = (type, params) => {
  return new ZodNullable$d({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$d.ZodNullable,
    ...processCreateParams$d(params)
  });
};
let ZodDefault$d = class ZodDefault4 extends ZodType$d {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$d.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$d.create = (type, params) => {
  return new ZodDefault$d({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$d.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$d(params)
  });
};
let ZodCatch$d = class ZodCatch4 extends ZodType$d {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$d(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$d(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$d(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$d.create = (type, params) => {
  return new ZodCatch$d({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$d.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$d(params)
  });
};
let ZodNaN$d = class ZodNaN4 extends ZodType$d {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$d.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$d(ctx, {
        code: ZodIssueCode$d.invalid_type,
        expected: ZodParsedType$d.nan,
        received: ctx.parsedType
      });
      return INVALID$d;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$d.create = (params) => {
  return new ZodNaN$d({
    typeName: ZodFirstPartyTypeKind$d.ZodNaN,
    ...processCreateParams$d(params)
  });
};
let ZodBranded$d = class ZodBranded4 extends ZodType$d {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$d = class ZodPipeline4 extends ZodType$d {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$d;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$d(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$d;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline4({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$d.ZodPipeline
    });
  }
};
let ZodReadonly$d = class ZodReadonly4 extends ZodType$d {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$d(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$d(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$d.create = (type, params) => {
  return new ZodReadonly$d({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$d.ZodReadonly,
    ...processCreateParams$d(params)
  });
};
var ZodFirstPartyTypeKind$d;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$d || (ZodFirstPartyTypeKind$d = {}));
const numberType$c = ZodNumber$d.create;
ZodNever$d.create;
ZodArray$d.create;
const objectType$d = ZodObject$d.create;
ZodUnion$d.create;
ZodIntersection$d.create;
ZodTuple$d.create;
ZodEnum$d.create;
ZodPromise$d.create;
ZodOptional$d.create;
ZodNullable$d.create;
const CircleOptionsSchema = objectType$d({
  /** the x position to draw the circle */
  x: numberType$c().optional(),
  /** the y position to draw the circle */
  y: numberType$c().optional(),
  /** the radius of the circle */
  radius: numberType$c().min(0).optional()
});
const methods$f = {
  /**
   * Creates a circle out of an image.
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.circle();
   * // or
   * image.circle({ radius: 50, x: 25, y: 25 });
   * ```
   */
  circle(image, options = {}) {
    const parsed = CircleOptionsSchema.parse(options);
    const radius = parsed.radius || (image.bitmap.width > image.bitmap.height ? image.bitmap.height : image.bitmap.width) / 2;
    const center = {
      x: typeof parsed.x === "number" ? parsed.x : image.bitmap.width / 2,
      y: typeof parsed.y === "number" ? parsed.y : image.bitmap.height / 2
    };
    image.scan((x2, y2, idx) => {
      const curR = Math.sqrt(Math.pow(x2 - center.x, 2) + Math.pow(y2 - center.y, 2));
      if (radius - curR <= 0) {
        image.bitmap.data[idx + 3] = 0;
      } else if (radius - curR < 1) {
        image.bitmap.data[idx + 3] = 255 * (radius - curR);
      }
    });
    return image;
  }
};
var util$d;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$d || (util$d = {}));
var objectUtil$c;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$c || (objectUtil$c = {}));
const ZodParsedType$c = util$d.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$c = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$c.undefined;
    case "string":
      return ZodParsedType$c.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType$c.nan : ZodParsedType$c.number;
    case "boolean":
      return ZodParsedType$c.boolean;
    case "function":
      return ZodParsedType$c.function;
    case "bigint":
      return ZodParsedType$c.bigint;
    case "symbol":
      return ZodParsedType$c.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$c.array;
      }
      if (data === null) {
        return ZodParsedType$c.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$c.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$c.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$c.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$c.date;
      }
      return ZodParsedType$c.object;
    default:
      return ZodParsedType$c.unknown;
  }
};
const ZodIssueCode$c = util$d.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
let ZodError$c = class ZodError5 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue2 of error.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError5)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$d.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$c.create = (issues) => {
  const error = new ZodError$c(issues);
  return error;
};
const errorMap$c = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode$c.invalid_type:
      if (issue2.received === ZodParsedType$c.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode$c.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util$d.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$c.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$d.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode$c.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$c.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$d.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode$c.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$d.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode$c.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$c.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$c.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$c.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util$d.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$c.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$c.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$c.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$c.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$c.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode$c.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$d.assertNever(issue2);
  }
  return { message };
};
let overrideErrorMap$c = errorMap$c;
function getErrorMap$c() {
  return overrideErrorMap$c;
}
const makeIssue$c = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext$c(ctx, issueData) {
  const overrideMap = getErrorMap$c();
  const issue2 = makeIssue$c({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$c ? void 0 : errorMap$c
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue2);
}
let ParseStatus$c = class ParseStatus5 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$c;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus5.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$c;
      if (value.status === "aborted")
        return INVALID$c;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$c = Object.freeze({
  status: "aborted"
});
const DIRTY$c = (value) => ({ status: "dirty", value });
const OK$c = (value) => ({ status: "valid", value });
const isAborted$c = (x2) => x2.status === "aborted";
const isDirty$c = (x2) => x2.status === "dirty";
const isValid$c = (x2) => x2.status === "valid";
const isAsync$c = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil$c;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil$c || (errorUtil$c = {}));
let ParseInputLazyPath$c = class ParseInputLazyPath5 {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$c = (ctx, result) => {
  if (isValid$c(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$c(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$c(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$c = class ZodType5 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$c(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$c(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$c(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$c(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$c(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: (params == null ? void 0 : params.async) ?? false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$c(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$c(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$c(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$c(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$c(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$c(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$c(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$c(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$c.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$c({
      schema: this,
      typeName: ZodFirstPartyTypeKind$c.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$c.create(this, this._def);
  }
  nullable() {
    return ZodNullable$c.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$c.create(this);
  }
  promise() {
    return ZodPromise$c.create(this, this._def);
  }
  or(option) {
    return ZodUnion$c.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$c.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects$c({
      ...processCreateParams$c(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$c.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault$c({
      ...processCreateParams$c(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$c.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$c({
      typeName: ZodFirstPartyTypeKind$c.ZodBranded,
      type: this,
      ...processCreateParams$c(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch$c({
      ...processCreateParams$c(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$c.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$c.create(this, target);
  }
  readonly() {
    return ZodReadonly$c.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$c = /^c[^\s-]{8,}$/i;
const cuid2Regex$c = /^[0-9a-z]+$/;
const ulidRegex$c = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$c = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$c = /^[a-z0-9_-]{21}$/i;
const jwtRegex$c = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$c = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$c = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$c = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$c;
const ipv4Regex$c = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$c = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$c = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$c = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$c = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$c = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$c = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$c = new RegExp(`^${dateRegexSource$c}$`);
function timeRegexSource$c(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex$c(args) {
  return new RegExp(`^${timeRegexSource$c(args)}$`);
}
function datetimeRegex$c(args) {
  let regex = `${dateRegexSource$c}T${timeRegexSource$c(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$c(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex$c.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex$c.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$c(jwt, alg) {
  if (!jwtRegex$c.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr$c(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex$c.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex$c.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$c = class ZodString5 extends ZodType$c {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$c.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$c(ctx2, {
        code: ZodIssueCode$c.invalid_type,
        expected: ZodParsedType$c.string,
        received: ctx2.parsedType
      });
      return INVALID$c;
    }
    const status = new ParseStatus$c();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            code: ZodIssueCode$c.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            code: ZodIssueCode$c.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$c(ctx, {
              code: ZodIssueCode$c.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$c(ctx, {
              code: ZodIssueCode$c.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$c.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            validation: "email",
            code: ZodIssueCode$c.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$c) {
          emojiRegex$c = new RegExp(_emojiRegex$c, "u");
        }
        if (!emojiRegex$c.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            validation: "emoji",
            code: ZodIssueCode$c.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$c.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            validation: "uuid",
            code: ZodIssueCode$c.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$c.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$c.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$c.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            validation: "cuid",
            code: ZodIssueCode$c.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$c.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$c.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$c.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            validation: "ulid",
            code: ZodIssueCode$c.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            validation: "url",
            code: ZodIssueCode$c.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            validation: "regex",
            code: ZodIssueCode$c.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            code: ZodIssueCode$c.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            code: ZodIssueCode$c.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            code: ZodIssueCode$c.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$c(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            code: ZodIssueCode$c.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$c;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            code: ZodIssueCode$c.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$c(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            code: ZodIssueCode$c.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$c.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            validation: "duration",
            code: ZodIssueCode$c.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$c(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            validation: "ip",
            code: ZodIssueCode$c.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$c(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            validation: "jwt",
            code: ZodIssueCode$c.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$c(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            validation: "cidr",
            code: ZodIssueCode$c.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$c.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            validation: "base64",
            code: ZodIssueCode$c.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$c.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            validation: "base64url",
            code: ZodIssueCode$c.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$d.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$c.invalid_string,
      ...errorUtil$c.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString5({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$c.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$c.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$c.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$c.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$c.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$c.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$c.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$c.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$c.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$c.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$c.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$c.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$c.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (options == null ? void 0 : options.offset) ?? false,
      local: (options == null ? void 0 : options.local) ?? false,
      ...errorUtil$c.errToObj(options == null ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      ...errorUtil$c.errToObj(options == null ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$c.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$c.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position,
      ...errorUtil$c.errToObj(options == null ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$c.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$c.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$c.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$c.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$c.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$c.errToObj(message));
  }
  trim() {
    return new ZodString5({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString5({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString5({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$c.create = (params) => {
  return new ZodString$c({
    checks: [],
    typeName: ZodFirstPartyTypeKind$c.ZodString,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$c(params)
  });
};
function floatSafeRemainder$c(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
let ZodNumber$c = class ZodNumber5 extends ZodType$c {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$c.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$c(ctx2, {
        code: ZodIssueCode$c.invalid_type,
        expected: ZodParsedType$c.number,
        received: ctx2.parsedType
      });
      return INVALID$c;
    }
    let ctx = void 0;
    const status = new ParseStatus$c();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$d.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            code: ZodIssueCode$c.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            code: ZodIssueCode$c.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            code: ZodIssueCode$c.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$c(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            code: ZodIssueCode$c.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            code: ZodIssueCode$c.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$d.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$c.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$c.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$c.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$c.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber5({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$c.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber5({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$c.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$c.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$c.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$c.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$c.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$c.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$c.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$c.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$c.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$d.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$c.create = (params) => {
  return new ZodNumber$c({
    checks: [],
    typeName: ZodFirstPartyTypeKind$c.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$c(params)
  });
};
let ZodBigInt$c = class ZodBigInt5 extends ZodType$c {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$c.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$c();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            code: ZodIssueCode$c.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            code: ZodIssueCode$c.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            code: ZodIssueCode$c.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$d.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$c(ctx, {
      code: ZodIssueCode$c.invalid_type,
      expected: ZodParsedType$c.bigint,
      received: ctx.parsedType
    });
    return INVALID$c;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$c.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$c.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$c.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$c.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt5({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$c.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt5({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$c.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$c.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$c.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$c.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$c.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$c.create = (params) => {
  return new ZodBigInt$c({
    checks: [],
    typeName: ZodFirstPartyTypeKind$c.ZodBigInt,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$c(params)
  });
};
let ZodBoolean$c = class ZodBoolean5 extends ZodType$c {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$c.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$c(ctx, {
        code: ZodIssueCode$c.invalid_type,
        expected: ZodParsedType$c.boolean,
        received: ctx.parsedType
      });
      return INVALID$c;
    }
    return OK$c(input.data);
  }
};
ZodBoolean$c.create = (params) => {
  return new ZodBoolean$c({
    typeName: ZodFirstPartyTypeKind$c.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$c(params)
  });
};
let ZodDate$c = class ZodDate5 extends ZodType$c {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$c.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$c(ctx2, {
        code: ZodIssueCode$c.invalid_type,
        expected: ZodParsedType$c.date,
        received: ctx2.parsedType
      });
      return INVALID$c;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$c(ctx2, {
        code: ZodIssueCode$c.invalid_date
      });
      return INVALID$c;
    }
    const status = new ParseStatus$c();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            code: ZodIssueCode$c.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$c(ctx, {
            code: ZodIssueCode$c.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$d.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate5({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$c.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$c.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$c.create = (params) => {
  return new ZodDate$c({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$c.ZodDate,
    ...processCreateParams$c(params)
  });
};
let ZodSymbol$c = class ZodSymbol5 extends ZodType$c {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$c.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$c(ctx, {
        code: ZodIssueCode$c.invalid_type,
        expected: ZodParsedType$c.symbol,
        received: ctx.parsedType
      });
      return INVALID$c;
    }
    return OK$c(input.data);
  }
};
ZodSymbol$c.create = (params) => {
  return new ZodSymbol$c({
    typeName: ZodFirstPartyTypeKind$c.ZodSymbol,
    ...processCreateParams$c(params)
  });
};
let ZodUndefined$c = class ZodUndefined5 extends ZodType$c {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$c.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$c(ctx, {
        code: ZodIssueCode$c.invalid_type,
        expected: ZodParsedType$c.undefined,
        received: ctx.parsedType
      });
      return INVALID$c;
    }
    return OK$c(input.data);
  }
};
ZodUndefined$c.create = (params) => {
  return new ZodUndefined$c({
    typeName: ZodFirstPartyTypeKind$c.ZodUndefined,
    ...processCreateParams$c(params)
  });
};
let ZodNull$c = class ZodNull5 extends ZodType$c {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$c.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$c(ctx, {
        code: ZodIssueCode$c.invalid_type,
        expected: ZodParsedType$c.null,
        received: ctx.parsedType
      });
      return INVALID$c;
    }
    return OK$c(input.data);
  }
};
ZodNull$c.create = (params) => {
  return new ZodNull$c({
    typeName: ZodFirstPartyTypeKind$c.ZodNull,
    ...processCreateParams$c(params)
  });
};
let ZodAny$c = class ZodAny5 extends ZodType$c {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$c(input.data);
  }
};
ZodAny$c.create = (params) => {
  return new ZodAny$c({
    typeName: ZodFirstPartyTypeKind$c.ZodAny,
    ...processCreateParams$c(params)
  });
};
let ZodUnknown$c = class ZodUnknown5 extends ZodType$c {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$c(input.data);
  }
};
ZodUnknown$c.create = (params) => {
  return new ZodUnknown$c({
    typeName: ZodFirstPartyTypeKind$c.ZodUnknown,
    ...processCreateParams$c(params)
  });
};
let ZodNever$c = class ZodNever5 extends ZodType$c {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$c(ctx, {
      code: ZodIssueCode$c.invalid_type,
      expected: ZodParsedType$c.never,
      received: ctx.parsedType
    });
    return INVALID$c;
  }
};
ZodNever$c.create = (params) => {
  return new ZodNever$c({
    typeName: ZodFirstPartyTypeKind$c.ZodNever,
    ...processCreateParams$c(params)
  });
};
let ZodVoid$c = class ZodVoid5 extends ZodType$c {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$c.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$c(ctx, {
        code: ZodIssueCode$c.invalid_type,
        expected: ZodParsedType$c.void,
        received: ctx.parsedType
      });
      return INVALID$c;
    }
    return OK$c(input.data);
  }
};
ZodVoid$c.create = (params) => {
  return new ZodVoid$c({
    typeName: ZodFirstPartyTypeKind$c.ZodVoid,
    ...processCreateParams$c(params)
  });
};
let ZodArray$c = class ZodArray5 extends ZodType$c {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType$c.array) {
      addIssueToContext$c(ctx, {
        code: ZodIssueCode$c.invalid_type,
        expected: ZodParsedType$c.array,
        received: ctx.parsedType
      });
      return INVALID$c;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$c(ctx, {
          code: tooBig ? ZodIssueCode$c.too_big : ZodIssueCode$c.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext$c(ctx, {
          code: ZodIssueCode$c.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext$c(ctx, {
          code: ZodIssueCode$c.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath$c(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$c.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath$c(ctx, item, ctx.path, i));
    });
    return ParseStatus$c.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray5({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$c.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray5({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$c.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray5({
      ...this._def,
      exactLength: { value: len, message: errorUtil$c.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$c.create = (schema, params) => {
  return new ZodArray$c({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$c.ZodArray,
    ...processCreateParams$c(params)
  });
};
function deepPartialify$c(schema) {
  if (schema instanceof ZodObject$c) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$c.create(deepPartialify$c(fieldSchema));
    }
    return new ZodObject$c({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$c) {
    return new ZodArray$c({
      ...schema._def,
      type: deepPartialify$c(schema.element)
    });
  } else if (schema instanceof ZodOptional$c) {
    return ZodOptional$c.create(deepPartialify$c(schema.unwrap()));
  } else if (schema instanceof ZodNullable$c) {
    return ZodNullable$c.create(deepPartialify$c(schema.unwrap()));
  } else if (schema instanceof ZodTuple$c) {
    return ZodTuple$c.create(schema.items.map((item) => deepPartialify$c(item)));
  } else {
    return schema;
  }
}
let ZodObject$c = class ZodObject5 extends ZodType$c {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$d.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$c.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$c(ctx2, {
        code: ZodIssueCode$c.invalid_type,
        expected: ZodParsedType$c.object,
        received: ctx2.parsedType
      });
      return INVALID$c;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$c && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$c(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$c) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$c(ctx, {
            code: ZodIssueCode$c.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$c(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$c.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$c.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$c.errToObj;
    return new ZodObject5({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          var _a, _b;
          const defaultError = ((_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue2, ctx).message) ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil$c.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject5({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject5({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject5({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject5({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$c.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject5({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util$d.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject5({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util$d.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject5({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$c(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util$d.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject5({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util$d.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$c) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject5({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$c(util$d.objectKeys(this.shape));
  }
};
ZodObject$c.create = (shape, params) => {
  return new ZodObject$c({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$c.create(),
    typeName: ZodFirstPartyTypeKind$c.ZodObject,
    ...processCreateParams$c(params)
  });
};
ZodObject$c.strictCreate = (shape, params) => {
  return new ZodObject$c({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$c.create(),
    typeName: ZodFirstPartyTypeKind$c.ZodObject,
    ...processCreateParams$c(params)
  });
};
ZodObject$c.lazycreate = (shape, params) => {
  return new ZodObject$c({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$c.create(),
    typeName: ZodFirstPartyTypeKind$c.ZodObject,
    ...processCreateParams$c(params)
  });
};
let ZodUnion$c = class ZodUnion5 extends ZodType$c {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$c(result.ctx.common.issues));
      addIssueToContext$c(ctx, {
        code: ZodIssueCode$c.invalid_union,
        unionErrors
      });
      return INVALID$c;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$c(issues2));
      addIssueToContext$c(ctx, {
        code: ZodIssueCode$c.invalid_union,
        unionErrors
      });
      return INVALID$c;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$c.create = (types, params) => {
  return new ZodUnion$c({
    options: types,
    typeName: ZodFirstPartyTypeKind$c.ZodUnion,
    ...processCreateParams$c(params)
  });
};
function mergeValues$c(a, b) {
  const aType = getParsedType$c(a);
  const bType = getParsedType$c(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$c.object && bType === ZodParsedType$c.object) {
    const bKeys = util$d.objectKeys(b);
    const sharedKeys = util$d.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$c(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$c.array && bType === ZodParsedType$c.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$c(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$c.date && bType === ZodParsedType$c.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$c = class ZodIntersection5 extends ZodType$c {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$c(parsedLeft) || isAborted$c(parsedRight)) {
        return INVALID$c;
      }
      const merged = mergeValues$c(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$c(ctx, {
          code: ZodIssueCode$c.invalid_intersection_types
        });
        return INVALID$c;
      }
      if (isDirty$c(parsedLeft) || isDirty$c(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$c.create = (left, right, params) => {
  return new ZodIntersection$c({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$c.ZodIntersection,
    ...processCreateParams$c(params)
  });
};
let ZodTuple$c = class ZodTuple5 extends ZodType$c {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$c.array) {
      addIssueToContext$c(ctx, {
        code: ZodIssueCode$c.invalid_type,
        expected: ZodParsedType$c.array,
        received: ctx.parsedType
      });
      return INVALID$c;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$c(ctx, {
        code: ZodIssueCode$c.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$c;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$c(ctx, {
        code: ZodIssueCode$c.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$c(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$c.mergeArray(status, results);
      });
    } else {
      return ParseStatus$c.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple5({
      ...this._def,
      rest
    });
  }
};
ZodTuple$c.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$c({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$c.ZodTuple,
    rest: null,
    ...processCreateParams$c(params)
  });
};
let ZodMap$c = class ZodMap5 extends ZodType$c {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$c.map) {
      addIssueToContext$c(ctx, {
        code: ZodIssueCode$c.invalid_type,
        expected: ZodParsedType$c.map,
        received: ctx.parsedType
      });
      return INVALID$c;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$c(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$c(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$c;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$c;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$c.create = (keyType, valueType, params) => {
  return new ZodMap$c({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$c.ZodMap,
    ...processCreateParams$c(params)
  });
};
let ZodSet$c = class ZodSet5 extends ZodType$c {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$c.set) {
      addIssueToContext$c(ctx, {
        code: ZodIssueCode$c.invalid_type,
        expected: ZodParsedType$c.set,
        received: ctx.parsedType
      });
      return INVALID$c;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext$c(ctx, {
          code: ZodIssueCode$c.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext$c(ctx, {
          code: ZodIssueCode$c.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID$c;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$c(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet5({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$c.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet5({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$c.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$c.create = (valueType, params) => {
  return new ZodSet$c({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$c.ZodSet,
    ...processCreateParams$c(params)
  });
};
let ZodLazy$c = class ZodLazy5 extends ZodType$c {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$c.create = (getter, params) => {
  return new ZodLazy$c({
    getter,
    typeName: ZodFirstPartyTypeKind$c.ZodLazy,
    ...processCreateParams$c(params)
  });
};
let ZodLiteral$c = class ZodLiteral5 extends ZodType$c {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$c(ctx, {
        received: ctx.data,
        code: ZodIssueCode$c.invalid_literal,
        expected: this._def.value
      });
      return INVALID$c;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$c.create = (value, params) => {
  return new ZodLiteral$c({
    value,
    typeName: ZodFirstPartyTypeKind$c.ZodLiteral,
    ...processCreateParams$c(params)
  });
};
function createZodEnum$c(values, params) {
  return new ZodEnum$c({
    values,
    typeName: ZodFirstPartyTypeKind$c.ZodEnum,
    ...processCreateParams$c(params)
  });
}
let ZodEnum$c = class ZodEnum5 extends ZodType$c {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$c(ctx, {
        expected: util$d.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$c.invalid_type
      });
      return INVALID$c;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$c(ctx, {
        received: ctx.data,
        code: ZodIssueCode$c.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$c;
    }
    return OK$c(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum5.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum5.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum$c.create = createZodEnum$c;
let ZodNativeEnum$c = class ZodNativeEnum5 extends ZodType$c {
  _parse(input) {
    const nativeEnumValues = util$d.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$c.string && ctx.parsedType !== ZodParsedType$c.number) {
      const expectedValues = util$d.objectValues(nativeEnumValues);
      addIssueToContext$c(ctx, {
        expected: util$d.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$c.invalid_type
      });
      return INVALID$c;
    }
    if (!this._cache) {
      this._cache = new Set(util$d.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util$d.objectValues(nativeEnumValues);
      addIssueToContext$c(ctx, {
        received: ctx.data,
        code: ZodIssueCode$c.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$c;
    }
    return OK$c(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum$c.create = (values, params) => {
  return new ZodNativeEnum$c({
    values,
    typeName: ZodFirstPartyTypeKind$c.ZodNativeEnum,
    ...processCreateParams$c(params)
  });
};
let ZodPromise$c = class ZodPromise5 extends ZodType$c {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$c.promise && ctx.common.async === false) {
      addIssueToContext$c(ctx, {
        code: ZodIssueCode$c.invalid_type,
        expected: ZodParsedType$c.promise,
        received: ctx.parsedType
      });
      return INVALID$c;
    }
    const promisified = ctx.parsedType === ZodParsedType$c.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$c(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$c.create = (schema, params) => {
  return new ZodPromise$c({
    type: schema,
    typeName: ZodFirstPartyTypeKind$c.ZodPromise,
    ...processCreateParams$c(params)
  });
};
let ZodEffects$c = class ZodEffects5 extends ZodType$c {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$c.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$c(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$c;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$c;
          if (result.status === "dirty")
            return DIRTY$c(result.value);
          if (status.value === "dirty")
            return DIRTY$c(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$c;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$c;
        if (result.status === "dirty")
          return DIRTY$c(result.value);
        if (status.value === "dirty")
          return DIRTY$c(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$c;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$c;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$c(base))
          return INVALID$c;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$c(base))
            return INVALID$c;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util$d.assertNever(effect);
  }
};
ZodEffects$c.create = (schema, effect, params) => {
  return new ZodEffects$c({
    schema,
    typeName: ZodFirstPartyTypeKind$c.ZodEffects,
    effect,
    ...processCreateParams$c(params)
  });
};
ZodEffects$c.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$c({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$c.ZodEffects,
    ...processCreateParams$c(params)
  });
};
let ZodOptional$c = class ZodOptional5 extends ZodType$c {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$c.undefined) {
      return OK$c(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$c.create = (type, params) => {
  return new ZodOptional$c({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$c.ZodOptional,
    ...processCreateParams$c(params)
  });
};
let ZodNullable$c = class ZodNullable5 extends ZodType$c {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$c.null) {
      return OK$c(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$c.create = (type, params) => {
  return new ZodNullable$c({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$c.ZodNullable,
    ...processCreateParams$c(params)
  });
};
let ZodDefault$c = class ZodDefault5 extends ZodType$c {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$c.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$c.create = (type, params) => {
  return new ZodDefault$c({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$c.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$c(params)
  });
};
let ZodCatch$c = class ZodCatch5 extends ZodType$c {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$c(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$c(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$c(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$c.create = (type, params) => {
  return new ZodCatch$c({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$c.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$c(params)
  });
};
let ZodNaN$c = class ZodNaN5 extends ZodType$c {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$c.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$c(ctx, {
        code: ZodIssueCode$c.invalid_type,
        expected: ZodParsedType$c.nan,
        received: ctx.parsedType
      });
      return INVALID$c;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$c.create = (params) => {
  return new ZodNaN$c({
    typeName: ZodFirstPartyTypeKind$c.ZodNaN,
    ...processCreateParams$c(params)
  });
};
let ZodBranded$c = class ZodBranded5 extends ZodType$c {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$c = class ZodPipeline5 extends ZodType$c {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$c;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$c(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$c;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline5({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$c.ZodPipeline
    });
  }
};
let ZodReadonly$c = class ZodReadonly5 extends ZodType$c {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$c(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$c(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$c.create = (type, params) => {
  return new ZodReadonly$c({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$c.ZodReadonly,
    ...processCreateParams$c(params)
  });
};
var ZodFirstPartyTypeKind$c;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$c || (ZodFirstPartyTypeKind$c = {}));
const numberType$b = ZodNumber$c.create;
ZodNever$c.create;
const arrayType$1 = ZodArray$c.create;
const objectType$c = ZodObject$c.create;
const unionType$5 = ZodUnion$c.create;
ZodIntersection$c.create;
const tupleType$2 = ZodTuple$c.create;
const literalType$1 = ZodLiteral$c.create;
ZodEnum$c.create;
const nativeEnumType$6 = ZodNativeEnum$c.create;
ZodPromise$c.create;
ZodOptional$c.create;
ZodNullable$c.create;
const ConvolutionMatrixSchema = arrayType$1(numberType$b()).min(1).array();
const ConvolutionComplexOptionsSchema = objectType$c({
  /** a matrix to weight the neighbors sum */
  kernel: ConvolutionMatrixSchema,
  /**define how to sum pixels from outside the border */
  edgeHandling: nativeEnumType$6(Edge).optional()
});
const ConvolutionOptionsSchema = unionType$5([
  ConvolutionMatrixSchema,
  ConvolutionComplexOptionsSchema
]);
const ConvoluteComplexOptionsSchema = objectType$c({
  /** the convolution kernel */
  kernel: ConvolutionMatrixSchema,
  /** the x position of the region to apply convolution to */
  x: numberType$b().optional(),
  /** the y position of the region to apply convolution to */
  y: numberType$b().optional(),
  /** the width of the region to apply convolution to */
  w: numberType$b().optional(),
  /** the height of the region to apply convolution to */
  h: numberType$b().optional()
});
const ConvoluteOptionsSchema = unionType$5([
  ConvolutionMatrixSchema,
  ConvoluteComplexOptionsSchema
]);
const PixelateSize = numberType$b().min(1).max(Infinity);
const PixelateComplexOptionsSchema = objectType$c({
  /** the size of the pixels */
  size: PixelateSize,
  /** the x position of the region to pixelate */
  x: numberType$b().optional(),
  /** the y position of the region to pixelate */
  y: numberType$b().optional(),
  /** the width of the region to pixelate */
  w: numberType$b().optional(),
  /** the height of the region to pixelate */
  h: numberType$b().optional()
});
const PixelateOptionsSchema = unionType$5([
  PixelateSize,
  PixelateComplexOptionsSchema
]);
function applyKernel(image, kernel, x2, y2) {
  const value = [0, 0, 0, 0];
  const size = (kernel.length - 1) / 2;
  for (let kx = 0; kx < kernel.length; kx += 1) {
    for (let ky = 0; ky < kernel[kx].length; ky += 1) {
      const idx = image.getPixelIndex(x2 + kx - size, y2 + ky - size);
      value[0] += image.bitmap.data[idx] * kernel[kx][ky];
      value[1] += image.bitmap.data[idx + 1] * kernel[kx][ky];
      value[2] += image.bitmap.data[idx + 2] * kernel[kx][ky];
      value[3] += image.bitmap.data[idx + 3] * kernel[kx][ky];
    }
  }
  return value;
}
function mix(clr, clr2, p = 50) {
  return {
    r: (clr2.r - clr.r) * (p / 100) + clr.r,
    g: (clr2.g - clr.g) * (p / 100) + clr.g,
    b: (clr2.b - clr.b) * (p / 100) + clr.b
  };
}
const HueActionSchema = objectType$c({
  apply: literalType$1("hue"),
  params: tupleType$2([numberType$b().min(-360).max(360)])
});
const SpinActionSchema = objectType$c({
  apply: literalType$1("spin"),
  params: tupleType$2([numberType$b().min(-360).max(360)])
});
const LightenActionSchema = objectType$c({
  apply: literalType$1("lighten"),
  params: tupleType$2([numberType$b().min(0).max(100)]).optional()
});
const RGBColorSchema = objectType$c({
  r: numberType$b().min(0).max(255),
  g: numberType$b().min(0).max(255),
  b: numberType$b().min(0).max(255)
});
const MixActionSchema = objectType$c({
  apply: literalType$1("mix"),
  params: unionType$5([
    tupleType$2([RGBColorSchema]),
    tupleType$2([RGBColorSchema, numberType$b().min(0).max(100)])
  ])
});
const TintActionSchema = objectType$c({
  apply: literalType$1("tint"),
  params: tupleType$2([numberType$b().min(0).max(100)]).optional()
});
const ShadeActionSchema = objectType$c({
  apply: literalType$1("shade"),
  params: tupleType$2([numberType$b().min(0).max(100)]).optional()
});
const XorActionSchema = objectType$c({
  apply: literalType$1("xor"),
  params: tupleType$2([RGBColorSchema])
});
const RedActionSchema = objectType$c({
  apply: literalType$1("red"),
  params: tupleType$2([numberType$b().min(-255).max(255)])
});
const GreenActionSchema = objectType$c({
  apply: literalType$1("green"),
  params: tupleType$2([numberType$b().min(-255).max(255)])
});
const BlueActionSchema = objectType$c({
  apply: literalType$1("blue"),
  params: tupleType$2([numberType$b().min(-255).max(255)])
});
const BrightenActionSchema = objectType$c({
  apply: literalType$1("brighten"),
  params: tupleType$2([numberType$b().min(0).max(100)]).optional()
});
const DarkenActionSchema = objectType$c({
  apply: literalType$1("darken"),
  params: tupleType$2([numberType$b().min(0).max(100)]).optional()
});
const DesaturateActionSchema = objectType$c({
  apply: literalType$1("desaturate"),
  params: tupleType$2([numberType$b().min(0).max(100)]).optional()
});
const SaturateActionSchema = objectType$c({
  apply: literalType$1("saturate"),
  params: tupleType$2([numberType$b().min(0).max(100)]).optional()
});
const GrayscaleActionSchema = objectType$c({
  apply: literalType$1("greyscale"),
  params: tupleType$2([]).optional()
});
const ColorActionNameSchema = unionType$5([
  HueActionSchema,
  SpinActionSchema,
  LightenActionSchema,
  MixActionSchema,
  TintActionSchema,
  ShadeActionSchema,
  XorActionSchema,
  RedActionSchema,
  GreenActionSchema,
  BlueActionSchema,
  BrightenActionSchema,
  DarkenActionSchema,
  DesaturateActionSchema,
  SaturateActionSchema,
  GrayscaleActionSchema
]);
function histogram(image) {
  const histogram2 = {
    r: new Array(256).fill(0),
    g: new Array(256).fill(0),
    b: new Array(256).fill(0)
  };
  image.scan((_, __, index) => {
    histogram2.r[image.bitmap.data[index + 0]]++;
    histogram2.g[image.bitmap.data[index + 1]]++;
    histogram2.b[image.bitmap.data[index + 2]]++;
  });
  return histogram2;
}
const normalizeValue = function(value, min, max) {
  return (value - min) * 255 / (max - min);
};
const getBounds = function(histogramChannel) {
  return [
    histogramChannel.findIndex((value) => value > 0),
    255 - histogramChannel.slice().reverse().findIndex((value) => value > 0)
  ];
};
const methods$e = {
  /**
   * Normalizes the image.
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.normalize();
   * ```
   */
  normalize(image) {
    const h = histogram(image);
    const bounds = {
      r: getBounds(h.r),
      g: getBounds(h.g),
      b: getBounds(h.b)
    };
    image.scan((_, __, idx) => {
      const r = image.bitmap.data[idx + 0];
      const g = image.bitmap.data[idx + 1];
      const b = image.bitmap.data[idx + 2];
      image.bitmap.data[idx + 0] = normalizeValue(r, bounds.r[0], bounds.r[1]);
      image.bitmap.data[idx + 1] = normalizeValue(g, bounds.g[0], bounds.g[1]);
      image.bitmap.data[idx + 2] = normalizeValue(b, bounds.b[0], bounds.b[1]);
    });
    return image;
  },
  /**
   * Inverts the colors in the image.
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.invert();
   * ```
   */
  invert(image) {
    image.scan((_, __, idx) => {
      image.bitmap.data[idx] = 255 - image.bitmap.data[idx];
      image.bitmap.data[idx + 1] = 255 - image.bitmap.data[idx + 1];
      image.bitmap.data[idx + 2] = 255 - image.bitmap.data[idx + 2];
    });
    return image;
  },
  /**
   * Adjusts the brightness of the image
   * @param val the amount to adjust the brightness.
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.brightness(0.5);
   * ```
   */
  brightness(image, val) {
    if (typeof val !== "number") {
      throw new Error("val must be numbers");
    }
    image.scan((_, __, idx) => {
      image.bitmap.data[idx] = limit255(image.bitmap.data[idx] * val);
      image.bitmap.data[idx + 1] = limit255(image.bitmap.data[idx + 1] * val);
      image.bitmap.data[idx + 2] = limit255(image.bitmap.data[idx + 2] * val);
    });
    return image;
  },
  /**
   * Adjusts the contrast of the image
   * @param val the amount to adjust the contrast, a number between -1 and +1
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.contrast(0.75);
   * ```
   */
  contrast(image, val) {
    if (typeof val !== "number") {
      throw new Error("val must be numbers");
    }
    if (val < -1 || val > 1) {
      throw new Error("val must be a number between -1 and +1");
    }
    const factor = (val + 1) / (1 - val);
    function adjust(value) {
      value = Math.floor(factor * (value - 127) + 127);
      return value < 0 ? 0 : value > 255 ? 255 : value;
    }
    image.scan((_, __, idx) => {
      image.bitmap.data[idx] = adjust(image.bitmap.data[idx]);
      image.bitmap.data[idx + 1] = adjust(image.bitmap.data[idx + 1]);
      image.bitmap.data[idx + 2] = adjust(image.bitmap.data[idx + 2]);
    });
    return image;
  },
  /**
   * Apply a posterize effect
   * @param  n the amount to adjust the contrast, minimum threshold is two
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.posterize(5);
   * ```
   */
  posterize(image, n) {
    if (typeof n !== "number") {
      throw new Error("n must be numbers");
    }
    if (n < 2) {
      n = 2;
    }
    image.scan((_, __, idx) => {
      const r = image.bitmap.data[idx];
      const g = image.bitmap.data[idx + 1];
      const b = image.bitmap.data[idx + 2];
      image.bitmap.data[idx] = Math.floor(r / 255 * (n - 1)) / (n - 1) * 255;
      image.bitmap.data[idx + 1] = Math.floor(g / 255 * (n - 1)) / (n - 1) * 255;
      image.bitmap.data[idx + 2] = Math.floor(b / 255 * (n - 1)) / (n - 1) * 255;
    });
    return image;
  },
  /**
   * Removes colour from the image using ITU Rec 709 luminance values
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.greyscale();
   * ```
   */
  greyscale(image) {
    image.scan((_, __, idx) => {
      const grey = 0.2126 * image.bitmap.data[idx] + 0.7152 * image.bitmap.data[idx + 1] + 0.0722 * image.bitmap.data[idx + 2];
      image.bitmap.data[idx] = grey;
      image.bitmap.data[idx + 1] = grey;
      image.bitmap.data[idx + 2] = grey;
    });
    return image;
  },
  /**
   * Multiplies the opacity of each pixel by a factor between 0 and 1
   * @param f A number, the factor by which to multiply the opacity of each pixel
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.opacity(0.5);
   * ```
   */
  opacity(image, f) {
    if (typeof f !== "number") {
      throw new Error("f must be a number");
    }
    if (f < 0 || f > 1) {
      throw new Error("f must be a number from 0 to 1");
    }
    image.scan((_, __, idx) => {
      const v = image.bitmap.data[idx + 3] * f;
      image.bitmap.data[idx + 3] = v;
    });
    return image;
  },
  /**
   * Applies a sepia tone to the image.
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.sepia();
   * ```
   */
  sepia(image) {
    image.scan((_, __, idx) => {
      let red = image.bitmap.data[idx];
      let green = image.bitmap.data[idx + 1];
      let blue = image.bitmap.data[idx + 2];
      red = red * 0.393 + green * 0.769 + blue * 0.189;
      green = red * 0.349 + green * 0.686 + blue * 0.168;
      blue = red * 0.272 + green * 0.534 + blue * 0.131;
      image.bitmap.data[idx] = red < 255 ? red : 255;
      image.bitmap.data[idx + 1] = green < 255 ? green : 255;
      image.bitmap.data[idx + 2] = blue < 255 ? blue : 255;
    });
    return image;
  },
  /**
   * Fades each pixel by a factor between 0 and 1
   * @param f A number from 0 to 1. 0 will haven no effect. 1 will turn the image completely transparent.
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.fade(0.7);
   * ```
   */
  fade(image, f) {
    if (typeof f !== "number") {
      throw new Error("f must be a number");
    }
    if (f < 0 || f > 1) {
      throw new Error("f must be a number from 0 to 1");
    }
    return this.opacity(image, 1 - f);
  },
  /**
   * Adds each element of the image to its local neighbors, weighted by the kernel
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.convolute([
   *   [-1, -1, 0],
   *   [-1, 1, 1],
   *   [0, 1, 1],
   * ]);
   * ```
   */
  convolution(image, options) {
    const parsed = ConvolutionOptionsSchema.parse(options);
    const { kernel, edgeHandling = Edge.EXTEND } = "kernel" in parsed ? parsed : { kernel: parsed, edgeHandling: void 0 };
    if (!kernel[0]) {
      throw new Error("kernel must be a matrix");
    }
    const newData = Buffer.from(image.bitmap.data);
    const kRows = kernel.length;
    const kCols = kernel[0].length;
    const rowEnd = Math.floor(kRows / 2);
    const colEnd = Math.floor(kCols / 2);
    const rowIni = -rowEnd;
    const colIni = -colEnd;
    let weight;
    let rSum;
    let gSum;
    let bSum;
    let ri;
    let gi;
    let bi;
    let xi;
    let yi;
    let idxi;
    image.scan((x2, y2, idx) => {
      bSum = 0;
      gSum = 0;
      rSum = 0;
      for (let row = rowIni; row <= rowEnd; row++) {
        for (let col = colIni; col <= colEnd; col++) {
          xi = x2 + col;
          yi = y2 + row;
          weight = kernel[row + rowEnd][col + colEnd];
          idxi = image.getPixelIndex(xi, yi, edgeHandling);
          if (idxi === -1) {
            bi = 0;
            gi = 0;
            ri = 0;
          } else {
            ri = image.bitmap.data[idxi + 0];
            gi = image.bitmap.data[idxi + 1];
            bi = image.bitmap.data[idxi + 2];
          }
          rSum += weight * ri;
          gSum += weight * gi;
          bSum += weight * bi;
        }
      }
      if (rSum < 0) {
        rSum = 0;
      }
      if (gSum < 0) {
        gSum = 0;
      }
      if (bSum < 0) {
        bSum = 0;
      }
      if (rSum > 255) {
        rSum = 255;
      }
      if (gSum > 255) {
        gSum = 255;
      }
      if (bSum > 255) {
        bSum = 255;
      }
      newData[idx + 0] = rSum;
      newData[idx + 1] = gSum;
      newData[idx + 2] = bSum;
    });
    image.bitmap.data = newData;
    return image;
  },
  /**
   * Set the alpha channel on every pixel to fully opaque.
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.opaque();
   * ```
   */
  opaque(image) {
    image.scan((_, __, idx) => {
      image.bitmap.data[idx + 3] = 255;
    });
    return image;
  },
  /**
   * Pixelates the image or a region
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * // pixelate the whole image
   * image.pixelate(10);
   *
   * // pixelate a region
   * image.pixelate(10, 10, 10, 20, 20);
   * ```
   */
  pixelate(image, options) {
    const parsed = PixelateOptionsSchema.parse(options);
    const { size, x: x2 = 0, y: y2 = 0, w = image.bitmap.width - x2, h = image.bitmap.height - y2 } = typeof parsed === "number" ? { size: parsed } : parsed;
    const kernel = [
      [1 / 16, 2 / 16, 1 / 16],
      [2 / 16, 4 / 16, 2 / 16],
      [1 / 16, 2 / 16, 1 / 16]
    ];
    const source = clone(image);
    scan(source, x2, y2, w, h, (xx, yx, idx) => {
      xx = size * Math.floor(xx / size);
      yx = size * Math.floor(yx / size);
      const value = applyKernel(source, kernel, xx, yx);
      image.bitmap.data[idx] = value[0];
      image.bitmap.data[idx + 1] = value[1];
      image.bitmap.data[idx + 2] = value[2];
      image.bitmap.data[idx + 3] = value[3];
    });
    return image;
  },
  /**
   * Applies a convolution kernel to the image or a region
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * // apply a convolution kernel to the whole image
   * image.convolution([
   *   [-1, -1, 0],
   *   [-1, 1, 1],
   *   [0, 1, 1],
   * ]);
   *
   * // apply a convolution kernel to a region
   * image.convolution([
   *   [-1, -1, 0],
   *   [-1, 1, 1],
   *   [0, 1, 1],
   * ], 10, 10, 10, 20);
   * ```
   */
  convolute(image, options) {
    const parsed = ConvoluteOptionsSchema.parse(options);
    const { kernel, x: x2 = 0, y: y2 = 0, w = image.bitmap.width - x2, h = image.bitmap.height - y2 } = "kernel" in parsed ? parsed : { kernel: parsed };
    const source = clone(image);
    scan(source, x2, y2, w, h, (xx, yx, idx) => {
      const value = applyKernel(source, kernel, xx, yx);
      image.bitmap.data[idx] = limit255(value[0]);
      image.bitmap.data[idx + 1] = limit255(value[1]);
      image.bitmap.data[idx + 2] = limit255(value[2]);
      image.bitmap.data[idx + 3] = limit255(value[3]);
    });
    return image;
  },
  /**
   * Apply multiple color modification rules
   * @param  actions list of color modification rules, in following format: { apply: '<rule-name>', params: [ <rule-parameters> ]  }
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.color([
   *   { apply: "hue", params: [-90] },
   *   { apply: "lighten", params: [50] },
   *   { apply: "xor", params: ["#06D"] },
   * ]);
   * ```
   */
  color(image, actions) {
    if (!actions || !Array.isArray(actions)) {
      throw new Error("actions must be an array");
    }
    actions.forEach((action) => ColorActionNameSchema.parse(action));
    actions = actions.map((action) => {
      if (action.apply === "xor" || action.apply === "mix") {
        action.params[0] = tinycolor(action.params[0]).toRgb();
      }
      return action;
    });
    image.scan((_, __, idx) => {
      let clr = {
        r: image.bitmap.data[idx],
        g: image.bitmap.data[idx + 1],
        b: image.bitmap.data[idx + 2]
      };
      const colorModifier = (i, amount) => limit255(clr[i] + amount);
      actions.forEach((action) => {
        var _a, _b;
        if (action.apply === "mix") {
          clr = mix(clr, action.params[0], action.params[1]);
        } else if (action.apply === "tint") {
          clr = mix(clr, { r: 255, g: 255, b: 255 }, (_a = action.params) == null ? void 0 : _a[0]);
        } else if (action.apply === "shade") {
          clr = mix(clr, { r: 0, g: 0, b: 0 }, (_b = action.params) == null ? void 0 : _b[0]);
        } else if (action.apply === "xor") {
          clr = {
            r: clr.r ^ action.params[0].r,
            g: clr.g ^ action.params[0].g,
            b: clr.b ^ action.params[0].b
          };
        } else if (action.apply === "red") {
          clr.r = colorModifier("r", action.params[0]);
        } else if (action.apply === "green") {
          clr.g = colorModifier("g", action.params[0]);
        } else if (action.apply === "blue") {
          clr.b = colorModifier("b", action.params[0]);
        } else {
          if (action.apply === "hue") {
            action.apply = "spin";
          }
          const tnyClr = tinycolor(clr);
          const fn = tnyClr[action.apply].bind(tnyClr);
          if (!fn) {
            throw new Error("action " + action.apply + " not supported");
          }
          clr = fn(...action.params || []).toRgb();
        }
      });
      image.bitmap.data[idx] = clr.r;
      image.bitmap.data[idx + 1] = clr.g;
      image.bitmap.data[idx + 2] = clr.b;
    });
    return image;
  }
};
var lib$1 = {};
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e)) < 1) {
      e--;
      c2 *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c2;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e++;
      c2 /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c2 - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d] |= s * 128;
};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnsiStringType = exports.StringType = exports.BufferType = exports.Uint8ArrayType = exports.IgnoreType = exports.Float80_LE = exports.Float80_BE = exports.Float64_LE = exports.Float64_BE = exports.Float32_LE = exports.Float32_BE = exports.Float16_LE = exports.Float16_BE = exports.INT64_BE = exports.UINT64_BE = exports.INT64_LE = exports.UINT64_LE = exports.INT32_LE = exports.INT32_BE = exports.INT24_BE = exports.INT24_LE = exports.INT16_LE = exports.INT16_BE = exports.INT8 = exports.UINT32_BE = exports.UINT32_LE = exports.UINT24_BE = exports.UINT24_LE = exports.UINT16_BE = exports.UINT16_LE = exports.UINT8 = void 0;
  const ieee754$1 = ieee754;
  function dv(array2) {
    return new DataView(array2.buffer, array2.byteOffset);
  }
  exports.UINT8 = {
    len: 1,
    get(array2, offset) {
      return dv(array2).getUint8(offset);
    },
    put(array2, offset, value) {
      dv(array2).setUint8(offset, value);
      return offset + 1;
    }
  };
  exports.UINT16_LE = {
    len: 2,
    get(array2, offset) {
      return dv(array2).getUint16(offset, true);
    },
    put(array2, offset, value) {
      dv(array2).setUint16(offset, value, true);
      return offset + 2;
    }
  };
  exports.UINT16_BE = {
    len: 2,
    get(array2, offset) {
      return dv(array2).getUint16(offset);
    },
    put(array2, offset, value) {
      dv(array2).setUint16(offset, value);
      return offset + 2;
    }
  };
  exports.UINT24_LE = {
    len: 3,
    get(array2, offset) {
      const dataView = dv(array2);
      return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);
    },
    put(array2, offset, value) {
      const dataView = dv(array2);
      dataView.setUint8(offset, value & 255);
      dataView.setUint16(offset + 1, value >> 8, true);
      return offset + 3;
    }
  };
  exports.UINT24_BE = {
    len: 3,
    get(array2, offset) {
      const dataView = dv(array2);
      return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
    },
    put(array2, offset, value) {
      const dataView = dv(array2);
      dataView.setUint16(offset, value >> 8);
      dataView.setUint8(offset + 2, value & 255);
      return offset + 3;
    }
  };
  exports.UINT32_LE = {
    len: 4,
    get(array2, offset) {
      return dv(array2).getUint32(offset, true);
    },
    put(array2, offset, value) {
      dv(array2).setUint32(offset, value, true);
      return offset + 4;
    }
  };
  exports.UINT32_BE = {
    len: 4,
    get(array2, offset) {
      return dv(array2).getUint32(offset);
    },
    put(array2, offset, value) {
      dv(array2).setUint32(offset, value);
      return offset + 4;
    }
  };
  exports.INT8 = {
    len: 1,
    get(array2, offset) {
      return dv(array2).getInt8(offset);
    },
    put(array2, offset, value) {
      dv(array2).setInt8(offset, value);
      return offset + 1;
    }
  };
  exports.INT16_BE = {
    len: 2,
    get(array2, offset) {
      return dv(array2).getInt16(offset);
    },
    put(array2, offset, value) {
      dv(array2).setInt16(offset, value);
      return offset + 2;
    }
  };
  exports.INT16_LE = {
    len: 2,
    get(array2, offset) {
      return dv(array2).getInt16(offset, true);
    },
    put(array2, offset, value) {
      dv(array2).setInt16(offset, value, true);
      return offset + 2;
    }
  };
  exports.INT24_LE = {
    len: 3,
    get(array2, offset) {
      const unsigned = exports.UINT24_LE.get(array2, offset);
      return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
    },
    put(array2, offset, value) {
      const dataView = dv(array2);
      dataView.setUint8(offset, value & 255);
      dataView.setUint16(offset + 1, value >> 8, true);
      return offset + 3;
    }
  };
  exports.INT24_BE = {
    len: 3,
    get(array2, offset) {
      const unsigned = exports.UINT24_BE.get(array2, offset);
      return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
    },
    put(array2, offset, value) {
      const dataView = dv(array2);
      dataView.setUint16(offset, value >> 8);
      dataView.setUint8(offset + 2, value & 255);
      return offset + 3;
    }
  };
  exports.INT32_BE = {
    len: 4,
    get(array2, offset) {
      return dv(array2).getInt32(offset);
    },
    put(array2, offset, value) {
      dv(array2).setInt32(offset, value);
      return offset + 4;
    }
  };
  exports.INT32_LE = {
    len: 4,
    get(array2, offset) {
      return dv(array2).getInt32(offset, true);
    },
    put(array2, offset, value) {
      dv(array2).setInt32(offset, value, true);
      return offset + 4;
    }
  };
  exports.UINT64_LE = {
    len: 8,
    get(array2, offset) {
      return dv(array2).getBigUint64(offset, true);
    },
    put(array2, offset, value) {
      dv(array2).setBigUint64(offset, value, true);
      return offset + 8;
    }
  };
  exports.INT64_LE = {
    len: 8,
    get(array2, offset) {
      return dv(array2).getBigInt64(offset, true);
    },
    put(array2, offset, value) {
      dv(array2).setBigInt64(offset, value, true);
      return offset + 8;
    }
  };
  exports.UINT64_BE = {
    len: 8,
    get(array2, offset) {
      return dv(array2).getBigUint64(offset);
    },
    put(array2, offset, value) {
      dv(array2).setBigUint64(offset, value);
      return offset + 8;
    }
  };
  exports.INT64_BE = {
    len: 8,
    get(array2, offset) {
      return dv(array2).getBigInt64(offset);
    },
    put(array2, offset, value) {
      dv(array2).setBigInt64(offset, value);
      return offset + 8;
    }
  };
  exports.Float16_BE = {
    len: 2,
    get(dataView, offset) {
      return ieee754$1.read(dataView, offset, false, 10, this.len);
    },
    put(dataView, offset, value) {
      ieee754$1.write(dataView, value, offset, false, 10, this.len);
      return offset + this.len;
    }
  };
  exports.Float16_LE = {
    len: 2,
    get(array2, offset) {
      return ieee754$1.read(array2, offset, true, 10, this.len);
    },
    put(array2, offset, value) {
      ieee754$1.write(array2, value, offset, true, 10, this.len);
      return offset + this.len;
    }
  };
  exports.Float32_BE = {
    len: 4,
    get(array2, offset) {
      return dv(array2).getFloat32(offset);
    },
    put(array2, offset, value) {
      dv(array2).setFloat32(offset, value);
      return offset + 4;
    }
  };
  exports.Float32_LE = {
    len: 4,
    get(array2, offset) {
      return dv(array2).getFloat32(offset, true);
    },
    put(array2, offset, value) {
      dv(array2).setFloat32(offset, value, true);
      return offset + 4;
    }
  };
  exports.Float64_BE = {
    len: 8,
    get(array2, offset) {
      return dv(array2).getFloat64(offset);
    },
    put(array2, offset, value) {
      dv(array2).setFloat64(offset, value);
      return offset + 8;
    }
  };
  exports.Float64_LE = {
    len: 8,
    get(array2, offset) {
      return dv(array2).getFloat64(offset, true);
    },
    put(array2, offset, value) {
      dv(array2).setFloat64(offset, value, true);
      return offset + 8;
    }
  };
  exports.Float80_BE = {
    len: 10,
    get(array2, offset) {
      return ieee754$1.read(array2, offset, false, 63, this.len);
    },
    put(array2, offset, value) {
      ieee754$1.write(array2, value, offset, false, 63, this.len);
      return offset + this.len;
    }
  };
  exports.Float80_LE = {
    len: 10,
    get(array2, offset) {
      return ieee754$1.read(array2, offset, true, 63, this.len);
    },
    put(array2, offset, value) {
      ieee754$1.write(array2, value, offset, true, 63, this.len);
      return offset + this.len;
    }
  };
  class IgnoreType {
    /**
     * @param len number of bytes to ignore
     */
    constructor(len) {
      this.len = len;
    }
    // ToDo: don't read, but skip data
    get(array2, off) {
    }
  }
  exports.IgnoreType = IgnoreType;
  class Uint8ArrayType {
    constructor(len) {
      this.len = len;
    }
    get(array2, offset) {
      return array2.subarray(offset, offset + this.len);
    }
  }
  exports.Uint8ArrayType = Uint8ArrayType;
  class BufferType {
    constructor(len) {
      this.len = len;
    }
    get(uint8Array, off) {
      return Buffer.from(uint8Array.subarray(off, off + this.len));
    }
  }
  exports.BufferType = BufferType;
  class StringType {
    constructor(len, encoding) {
      this.len = len;
      this.encoding = encoding;
    }
    get(uint8Array, offset) {
      return Buffer.from(uint8Array).toString(this.encoding, offset, offset + this.len);
    }
  }
  exports.StringType = StringType;
  class AnsiStringType {
    constructor(len) {
      this.len = len;
    }
    static decode(buffer, offset, until) {
      let str = "";
      for (let i = offset; i < until; ++i) {
        str += AnsiStringType.codePointToString(AnsiStringType.singleByteDecoder(buffer[i]));
      }
      return str;
    }
    static inRange(a, min, max) {
      return min <= a && a <= max;
    }
    static codePointToString(cp) {
      if (cp <= 65535) {
        return String.fromCharCode(cp);
      } else {
        cp -= 65536;
        return String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
      }
    }
    static singleByteDecoder(bite) {
      if (AnsiStringType.inRange(bite, 0, 127)) {
        return bite;
      }
      const codePoint = AnsiStringType.windows1252[bite - 128];
      if (codePoint === null) {
        throw Error("invaliding encoding");
      }
      return codePoint;
    }
    get(buffer, offset = 0) {
      return AnsiStringType.decode(buffer, offset, offset + this.len);
    }
  }
  exports.AnsiStringType = AnsiStringType;
  AnsiStringType.windows1252 = [
    8364,
    129,
    8218,
    402,
    8222,
    8230,
    8224,
    8225,
    710,
    8240,
    352,
    8249,
    338,
    141,
    381,
    143,
    144,
    8216,
    8217,
    8220,
    8221,
    8226,
    8211,
    8212,
    732,
    8482,
    353,
    8250,
    339,
    157,
    382,
    376,
    160,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    173,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255
  ];
})(lib$1);
var core$1 = {};
var ReadStreamTokenizer$1 = {};
var AbstractTokenizer$1 = {};
var lib = {};
var EndOfFileStream = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndOfStreamError = exports.defaultMessages = void 0;
  exports.defaultMessages = "End-Of-Stream";
  class EndOfStreamError extends Error {
    constructor() {
      super(exports.defaultMessages);
    }
  }
  exports.EndOfStreamError = EndOfStreamError;
})(EndOfFileStream);
var StreamReader = {};
var Deferred$1 = {};
Object.defineProperty(Deferred$1, "__esModule", { value: true });
Deferred$1.Deferred = void 0;
class Deferred {
  constructor() {
    this.resolve = () => null;
    this.reject = () => null;
    this.promise = new Promise((resolve2, reject2) => {
      this.reject = reject2;
      this.resolve = resolve2;
    });
  }
}
Deferred$1.Deferred = Deferred;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamReader = exports.EndOfStreamError = void 0;
  const EndOfFileStream_1 = EndOfFileStream;
  const Deferred_1 = Deferred$1;
  var EndOfFileStream_2 = EndOfFileStream;
  Object.defineProperty(exports, "EndOfStreamError", { enumerable: true, get: function() {
    return EndOfFileStream_2.EndOfStreamError;
  } });
  const maxStreamReadSize = 1 * 1024 * 1024;
  class StreamReader2 {
    constructor(s) {
      this.s = s;
      this.deferred = null;
      this.endOfStream = false;
      this.peekQueue = [];
      if (!s.read || !s.once) {
        throw new Error("Expected an instance of stream.Readable");
      }
      this.s.once("end", () => this.reject(new EndOfFileStream_1.EndOfStreamError()));
      this.s.once("error", (err) => this.reject(err));
      this.s.once("close", () => this.reject(new Error("Stream closed")));
    }
    /**
     * Read ahead (peek) from stream. Subsequent read or peeks will return the same data
     * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in
     * @param offset - Offset target
     * @param length - Number of bytes to read
     * @returns Number of bytes peeked
     */
    async peek(uint8Array, offset, length) {
      const bytesRead = await this.read(uint8Array, offset, length);
      this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead));
      return bytesRead;
    }
    /**
     * Read chunk from stream
     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
     * @param offset - Offset target
     * @param length - Number of bytes to read
     * @returns Number of bytes read
     */
    async read(buffer, offset, length) {
      if (length === 0) {
        return 0;
      }
      if (this.peekQueue.length === 0 && this.endOfStream) {
        throw new EndOfFileStream_1.EndOfStreamError();
      }
      let remaining = length;
      let bytesRead = 0;
      while (this.peekQueue.length > 0 && remaining > 0) {
        const peekData = this.peekQueue.pop();
        if (!peekData)
          throw new Error("peekData should be defined");
        const lenCopy = Math.min(peekData.length, remaining);
        buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
        bytesRead += lenCopy;
        remaining -= lenCopy;
        if (lenCopy < peekData.length) {
          this.peekQueue.push(peekData.subarray(lenCopy));
        }
      }
      while (remaining > 0 && !this.endOfStream) {
        const reqLen = Math.min(remaining, maxStreamReadSize);
        const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
        bytesRead += chunkLen;
        if (chunkLen < reqLen)
          break;
        remaining -= chunkLen;
      }
      return bytesRead;
    }
    /**
     * Read chunk from stream
     * @param buffer Target Uint8Array (or Buffer) to store data read from stream in
     * @param offset Offset target
     * @param length Number of bytes to read
     * @returns Number of bytes read
     */
    async readFromStream(buffer, offset, length) {
      const readBuffer = this.s.read(length);
      if (readBuffer) {
        buffer.set(readBuffer, offset);
        return readBuffer.length;
      } else {
        const request = {
          buffer,
          offset,
          length,
          deferred: new Deferred_1.Deferred()
        };
        this.deferred = request.deferred;
        this.s.once("readable", () => {
          this.readDeferred(request);
        });
        return request.deferred.promise;
      }
    }
    /**
     * Process deferred read request
     * @param request Deferred read request
     */
    readDeferred(request) {
      const readBuffer = this.s.read(request.length);
      if (readBuffer) {
        request.buffer.set(readBuffer, request.offset);
        request.deferred.resolve(readBuffer.length);
        this.deferred = null;
      } else {
        this.s.once("readable", () => {
          this.readDeferred(request);
        });
      }
    }
    reject(err) {
      this.endOfStream = true;
      if (this.deferred) {
        this.deferred.reject(err);
        this.deferred = null;
      }
    }
  }
  exports.StreamReader = StreamReader2;
})(StreamReader);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamReader = exports.EndOfStreamError = void 0;
  var EndOfFileStream_1 = EndOfFileStream;
  Object.defineProperty(exports, "EndOfStreamError", { enumerable: true, get: function() {
    return EndOfFileStream_1.EndOfStreamError;
  } });
  var StreamReader_1 = StreamReader;
  Object.defineProperty(exports, "StreamReader", { enumerable: true, get: function() {
    return StreamReader_1.StreamReader;
  } });
})(lib);
Object.defineProperty(AbstractTokenizer$1, "__esModule", { value: true });
AbstractTokenizer$1.AbstractTokenizer = void 0;
const peek_readable_1$2 = lib;
class AbstractTokenizer {
  constructor(fileInfo) {
    this.position = 0;
    this.numBuffer = new Uint8Array(8);
    this.fileInfo = fileInfo ? fileInfo : {};
  }
  /**
   * Read a token from the tokenizer-stream
   * @param token - The token to read
   * @param position - If provided, the desired position in the tokenizer-stream
   * @returns Promise with token data
   */
  async readToken(token, position = this.position) {
    const uint8Array = Buffer.alloc(token.len);
    const len = await this.readBuffer(uint8Array, { position });
    if (len < token.len)
      throw new peek_readable_1$2.EndOfStreamError();
    return token.get(uint8Array, 0);
  }
  /**
   * Peek a token from the tokenizer-stream.
   * @param token - Token to peek from the tokenizer-stream.
   * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
   * @returns Promise with token data
   */
  async peekToken(token, position = this.position) {
    const uint8Array = Buffer.alloc(token.len);
    const len = await this.peekBuffer(uint8Array, { position });
    if (len < token.len)
      throw new peek_readable_1$2.EndOfStreamError();
    return token.get(uint8Array, 0);
  }
  /**
   * Read a numeric token from the stream
   * @param token - Numeric token
   * @returns Promise with number
   */
  async readNumber(token) {
    const len = await this.readBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new peek_readable_1$2.EndOfStreamError();
    return token.get(this.numBuffer, 0);
  }
  /**
   * Read a numeric token from the stream
   * @param token - Numeric token
   * @returns Promise with number
   */
  async peekNumber(token) {
    const len = await this.peekBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new peek_readable_1$2.EndOfStreamError();
    return token.get(this.numBuffer, 0);
  }
  /**
   * Ignore number of bytes, advances the pointer in under tokenizer-stream.
   * @param length - Number of bytes to ignore
   * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
   */
  async ignore(length) {
    if (this.fileInfo.size !== void 0) {
      const bytesLeft = this.fileInfo.size - this.position;
      if (length > bytesLeft) {
        this.position += bytesLeft;
        return bytesLeft;
      }
    }
    this.position += length;
    return length;
  }
  async close() {
  }
  normalizeOptions(uint8Array, options) {
    if (options && options.position !== void 0 && options.position < this.position) {
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    }
    if (options) {
      return {
        mayBeLess: options.mayBeLess === true,
        offset: options.offset ? options.offset : 0,
        length: options.length ? options.length : uint8Array.length - (options.offset ? options.offset : 0),
        position: options.position ? options.position : this.position
      };
    }
    return {
      mayBeLess: false,
      offset: 0,
      length: uint8Array.length,
      position: this.position
    };
  }
}
AbstractTokenizer$1.AbstractTokenizer = AbstractTokenizer;
Object.defineProperty(ReadStreamTokenizer$1, "__esModule", { value: true });
ReadStreamTokenizer$1.ReadStreamTokenizer = void 0;
const AbstractTokenizer_1$1 = AbstractTokenizer$1;
const peek_readable_1$1 = lib;
const maxBufferSize = 256e3;
class ReadStreamTokenizer extends AbstractTokenizer_1$1.AbstractTokenizer {
  constructor(stream2, fileInfo) {
    super(fileInfo);
    this.streamReader = new peek_readable_1$1.StreamReader(stream2);
  }
  /**
   * Get file information, an HTTP-client may implement this doing a HEAD request
   * @return Promise with file information
   */
  async getFileInfo() {
    return this.fileInfo;
  }
  /**
   * Read buffer from tokenizer
   * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
   * @param options - Read behaviour options
   * @returns Promise with number of bytes read
   */
  async readBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const skipBytes = normOptions.position - this.position;
    if (skipBytes > 0) {
      await this.ignore(skipBytes);
      return this.readBuffer(uint8Array, options);
    } else if (skipBytes < 0) {
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    }
    if (normOptions.length === 0) {
      return 0;
    }
    const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
    this.position += bytesRead;
    if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
      throw new peek_readable_1$1.EndOfStreamError();
    }
    return bytesRead;
  }
  /**
   * Peek (read ahead) buffer from tokenizer
   * @param uint8Array - Uint8Array (or Buffer) to write data to
   * @param options - Read behaviour options
   * @returns Promise with number of bytes peeked
   */
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    let bytesRead = 0;
    if (normOptions.position) {
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
        bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
        uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
        return bytesRead - skipBytes;
      } else if (skipBytes < 0) {
        throw new Error("Cannot peek from a negative offset in a stream");
      }
    }
    if (normOptions.length > 0) {
      try {
        bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
      } catch (err) {
        if (options && options.mayBeLess && err instanceof peek_readable_1$1.EndOfStreamError) {
          return 0;
        }
        throw err;
      }
      if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
        throw new peek_readable_1$1.EndOfStreamError();
      }
    }
    return bytesRead;
  }
  async ignore(length) {
    const bufSize = Math.min(maxBufferSize, length);
    const buf = new Uint8Array(bufSize);
    let totBytesRead = 0;
    while (totBytesRead < length) {
      const remaining = length - totBytesRead;
      const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
      if (bytesRead < 0) {
        return bytesRead;
      }
      totBytesRead += bytesRead;
    }
    return totBytesRead;
  }
}
ReadStreamTokenizer$1.ReadStreamTokenizer = ReadStreamTokenizer;
var BufferTokenizer$1 = {};
Object.defineProperty(BufferTokenizer$1, "__esModule", { value: true });
BufferTokenizer$1.BufferTokenizer = void 0;
const peek_readable_1 = lib;
const AbstractTokenizer_1 = AbstractTokenizer$1;
class BufferTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
  /**
   * Construct BufferTokenizer
   * @param uint8Array - Uint8Array to tokenize
   * @param fileInfo - Pass additional file information to the tokenizer
   */
  constructor(uint8Array, fileInfo) {
    super(fileInfo);
    this.uint8Array = uint8Array;
    this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : uint8Array.length;
  }
  /**
   * Read buffer from tokenizer
   * @param uint8Array - Uint8Array to tokenize
   * @param options - Read behaviour options
   * @returns {Promise<number>}
   */
  async readBuffer(uint8Array, options) {
    if (options && options.position) {
      if (options.position < this.position) {
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      }
      this.position = options.position;
    }
    const bytesRead = await this.peekBuffer(uint8Array, options);
    this.position += bytesRead;
    return bytesRead;
  }
  /**
   * Peek (read ahead) buffer from tokenizer
   * @param uint8Array
   * @param options - Read behaviour options
   * @returns {Promise<number>}
   */
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
    if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
      throw new peek_readable_1.EndOfStreamError();
    } else {
      uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
      return bytes2read;
    }
  }
  async close() {
  }
}
BufferTokenizer$1.BufferTokenizer = BufferTokenizer;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromBuffer = exports.fromStream = exports.EndOfStreamError = void 0;
  const ReadStreamTokenizer_1 = ReadStreamTokenizer$1;
  const BufferTokenizer_1 = BufferTokenizer$1;
  var peek_readable_12 = lib;
  Object.defineProperty(exports, "EndOfStreamError", { enumerable: true, get: function() {
    return peek_readable_12.EndOfStreamError;
  } });
  function fromStream2(stream2, fileInfo) {
    fileInfo = fileInfo ? fileInfo : {};
    return new ReadStreamTokenizer_1.ReadStreamTokenizer(stream2, fileInfo);
  }
  exports.fromStream = fromStream2;
  function fromBuffer2(uint8Array, fileInfo) {
    return new BufferTokenizer_1.BufferTokenizer(uint8Array, fileInfo);
  }
  exports.fromBuffer = fromBuffer2;
})(core$1);
var util$c = {};
util$c.stringToBytes = (string2) => [...string2].map((character) => character.charCodeAt(0));
util$c.tarHeaderChecksumMatches = (buffer, offset = 0) => {
  const readSum = parseInt(buffer.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
  if (isNaN(readSum)) {
    return false;
  }
  let sum = 8 * 32;
  for (let i = offset; i < offset + 148; i++) {
    sum += buffer[i];
  }
  for (let i = offset + 156; i < offset + 512; i++) {
    sum += buffer[i];
  }
  return readSum === sum;
};
util$c.uint32SyncSafeToken = {
  get: (buffer, offset) => {
    return buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21;
  },
  len: 4
};
var supported$1 = {
  extensions: [
    "jpg",
    "png",
    "apng",
    "gif",
    "webp",
    "flif",
    "xcf",
    "cr2",
    "cr3",
    "orf",
    "arw",
    "dng",
    "nef",
    "rw2",
    "raf",
    "tif",
    "bmp",
    "icns",
    "jxr",
    "psd",
    "indd",
    "zip",
    "tar",
    "rar",
    "gz",
    "bz2",
    "7z",
    "dmg",
    "mp4",
    "mid",
    "mkv",
    "webm",
    "mov",
    "avi",
    "mpg",
    "mp2",
    "mp3",
    "m4a",
    "oga",
    "ogg",
    "ogv",
    "opus",
    "flac",
    "wav",
    "spx",
    "amr",
    "pdf",
    "epub",
    "exe",
    "swf",
    "rtf",
    "wasm",
    "woff",
    "woff2",
    "eot",
    "ttf",
    "otf",
    "ico",
    "flv",
    "ps",
    "xz",
    "sqlite",
    "nes",
    "crx",
    "xpi",
    "cab",
    "deb",
    "ar",
    "rpm",
    "Z",
    "lz",
    "cfb",
    "mxf",
    "mts",
    "blend",
    "bpg",
    "docx",
    "pptx",
    "xlsx",
    "3gp",
    "3g2",
    "jp2",
    "jpm",
    "jpx",
    "mj2",
    "aif",
    "qcp",
    "odt",
    "ods",
    "odp",
    "xml",
    "mobi",
    "heic",
    "cur",
    "ktx",
    "ape",
    "wv",
    "dcm",
    "ics",
    "glb",
    "pcap",
    "dsf",
    "lnk",
    "alias",
    "voc",
    "ac3",
    "m4v",
    "m4p",
    "m4b",
    "f4v",
    "f4p",
    "f4b",
    "f4a",
    "mie",
    "asf",
    "ogm",
    "ogx",
    "mpc",
    "arrow",
    "shp",
    "aac",
    "mp1",
    "it",
    "s3m",
    "xm",
    "ai",
    "skp",
    "avif",
    "eps",
    "lzh",
    "pgp",
    "asar",
    "stl",
    "chm",
    "3mf",
    "zst",
    "jxl",
    "vcf"
  ],
  mimeTypes: [
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp",
    "image/flif",
    "image/x-xcf",
    "image/x-canon-cr2",
    "image/x-canon-cr3",
    "image/tiff",
    "image/bmp",
    "image/vnd.ms-photo",
    "image/vnd.adobe.photoshop",
    "application/x-indesign",
    "application/epub+zip",
    "application/x-xpinstall",
    "application/vnd.oasis.opendocument.text",
    "application/vnd.oasis.opendocument.spreadsheet",
    "application/vnd.oasis.opendocument.presentation",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/zip",
    "application/x-tar",
    "application/x-rar-compressed",
    "application/gzip",
    "application/x-bzip2",
    "application/x-7z-compressed",
    "application/x-apple-diskimage",
    "application/x-apache-arrow",
    "video/mp4",
    "audio/midi",
    "video/x-matroska",
    "video/webm",
    "video/quicktime",
    "video/vnd.avi",
    "audio/vnd.wave",
    "audio/qcelp",
    "audio/x-ms-asf",
    "video/x-ms-asf",
    "application/vnd.ms-asf",
    "video/mpeg",
    "video/3gpp",
    "audio/mpeg",
    "audio/mp4",
    // RFC 4337
    "audio/opus",
    "video/ogg",
    "audio/ogg",
    "application/ogg",
    "audio/x-flac",
    "audio/ape",
    "audio/wavpack",
    "audio/amr",
    "application/pdf",
    "application/x-msdownload",
    "application/x-shockwave-flash",
    "application/rtf",
    "application/wasm",
    "font/woff",
    "font/woff2",
    "application/vnd.ms-fontobject",
    "font/ttf",
    "font/otf",
    "image/x-icon",
    "video/x-flv",
    "application/postscript",
    "application/eps",
    "application/x-xz",
    "application/x-sqlite3",
    "application/x-nintendo-nes-rom",
    "application/x-google-chrome-extension",
    "application/vnd.ms-cab-compressed",
    "application/x-deb",
    "application/x-unix-archive",
    "application/x-rpm",
    "application/x-compress",
    "application/x-lzip",
    "application/x-cfb",
    "application/x-mie",
    "application/mxf",
    "video/mp2t",
    "application/x-blender",
    "image/bpg",
    "image/jp2",
    "image/jpx",
    "image/jpm",
    "image/mj2",
    "audio/aiff",
    "application/xml",
    "application/x-mobipocket-ebook",
    "image/heif",
    "image/heif-sequence",
    "image/heic",
    "image/heic-sequence",
    "image/icns",
    "image/ktx",
    "application/dicom",
    "audio/x-musepack",
    "text/calendar",
    "text/vcard",
    "model/gltf-binary",
    "application/vnd.tcpdump.pcap",
    "audio/x-dsf",
    // Non-standard
    "application/x.ms.shortcut",
    // Invented by us
    "application/x.apple.alias",
    // Invented by us
    "audio/x-voc",
    "audio/vnd.dolby.dd-raw",
    "audio/x-m4a",
    "image/apng",
    "image/x-olympus-orf",
    "image/x-sony-arw",
    "image/x-adobe-dng",
    "image/x-nikon-nef",
    "image/x-panasonic-rw2",
    "image/x-fujifilm-raf",
    "video/x-m4v",
    "video/3gpp2",
    "application/x-esri-shape",
    "audio/aac",
    "audio/x-it",
    "audio/x-s3m",
    "audio/x-xm",
    "video/MP1S",
    "video/MP2P",
    "application/vnd.sketchup.skp",
    "image/avif",
    "application/x-lzh-compressed",
    "application/pgp-encrypted",
    "application/x-asar",
    "model/stl",
    "application/vnd.ms-htmlhelp",
    "model/3mf",
    "image/jxl",
    "application/zstd"
  ]
};
const Token = lib$1;
const strtok3 = core$1;
const {
  stringToBytes,
  tarHeaderChecksumMatches,
  uint32SyncSafeToken
} = util$c;
const supported = supported$1;
const minimumBytes = 4100;
async function fromStream(stream2) {
  const tokenizer = await strtok3.fromStream(stream2);
  try {
    return await fromTokenizer(tokenizer);
  } finally {
    await tokenizer.close();
  }
}
async function fromBuffer(input) {
  if (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {
    throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
  }
  const buffer = input instanceof Buffer ? input : Buffer.from(input);
  if (!(buffer && buffer.length > 1)) {
    return;
  }
  const tokenizer = strtok3.fromBuffer(buffer);
  return fromTokenizer(tokenizer);
}
function _check(buffer, headers, options) {
  options = {
    offset: 0,
    ...options
  };
  for (const [index, header] of headers.entries()) {
    if (options.mask) {
      if (header !== (options.mask[index] & buffer[index + options.offset])) {
        return false;
      }
    } else if (header !== buffer[index + options.offset]) {
      return false;
    }
  }
  return true;
}
async function fromTokenizer(tokenizer) {
  try {
    return _fromTokenizer(tokenizer);
  } catch (error) {
    if (!(error instanceof strtok3.EndOfStreamError)) {
      throw error;
    }
  }
}
async function _fromTokenizer(tokenizer) {
  let buffer = Buffer.alloc(minimumBytes);
  const bytesRead = 12;
  const check = (header, options) => _check(buffer, header, options);
  const checkString = (header, options) => check(stringToBytes(header), options);
  if (!tokenizer.fileInfo.size) {
    tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
  }
  await tokenizer.peekBuffer(buffer, { length: bytesRead, mayBeLess: true });
  if (check([66, 77])) {
    return {
      ext: "bmp",
      mime: "image/bmp"
    };
  }
  if (check([11, 119])) {
    return {
      ext: "ac3",
      mime: "audio/vnd.dolby.dd-raw"
    };
  }
  if (check([120, 1])) {
    return {
      ext: "dmg",
      mime: "application/x-apple-diskimage"
    };
  }
  if (check([77, 90])) {
    return {
      ext: "exe",
      mime: "application/x-msdownload"
    };
  }
  if (check([37, 33])) {
    await tokenizer.peekBuffer(buffer, { length: 24, mayBeLess: true });
    if (checkString("PS-Adobe-", { offset: 2 }) && checkString(" EPSF-", { offset: 14 })) {
      return {
        ext: "eps",
        mime: "application/eps"
      };
    }
    return {
      ext: "ps",
      mime: "application/postscript"
    };
  }
  if (check([31, 160]) || check([31, 157])) {
    return {
      ext: "Z",
      mime: "application/x-compress"
    };
  }
  if (check([255, 216, 255])) {
    return {
      ext: "jpg",
      mime: "image/jpeg"
    };
  }
  if (check([73, 73, 188])) {
    return {
      ext: "jxr",
      mime: "image/vnd.ms-photo"
    };
  }
  if (check([31, 139, 8])) {
    return {
      ext: "gz",
      mime: "application/gzip"
    };
  }
  if (check([66, 90, 104])) {
    return {
      ext: "bz2",
      mime: "application/x-bzip2"
    };
  }
  if (checkString("ID3")) {
    await tokenizer.ignore(6);
    const id3HeaderLen = await tokenizer.readToken(uint32SyncSafeToken);
    if (tokenizer.position + id3HeaderLen > tokenizer.fileInfo.size) {
      return {
        ext: "mp3",
        mime: "audio/mpeg"
      };
    }
    await tokenizer.ignore(id3HeaderLen);
    return fromTokenizer(tokenizer);
  }
  if (checkString("MP+")) {
    return {
      ext: "mpc",
      mime: "audio/x-musepack"
    };
  }
  if ((buffer[0] === 67 || buffer[0] === 70) && check([87, 83], { offset: 1 })) {
    return {
      ext: "swf",
      mime: "application/x-shockwave-flash"
    };
  }
  if (check([71, 73, 70])) {
    return {
      ext: "gif",
      mime: "image/gif"
    };
  }
  if (checkString("FLIF")) {
    return {
      ext: "flif",
      mime: "image/flif"
    };
  }
  if (checkString("8BPS")) {
    return {
      ext: "psd",
      mime: "image/vnd.adobe.photoshop"
    };
  }
  if (checkString("WEBP", { offset: 8 })) {
    return {
      ext: "webp",
      mime: "image/webp"
    };
  }
  if (checkString("MPCK")) {
    return {
      ext: "mpc",
      mime: "audio/x-musepack"
    };
  }
  if (checkString("FORM")) {
    return {
      ext: "aif",
      mime: "audio/aiff"
    };
  }
  if (checkString("icns", { offset: 0 })) {
    return {
      ext: "icns",
      mime: "image/icns"
    };
  }
  if (check([80, 75, 3, 4])) {
    try {
      while (tokenizer.position + 30 < tokenizer.fileInfo.size) {
        await tokenizer.readBuffer(buffer, { length: 30 });
        const zipHeader = {
          compressedSize: buffer.readUInt32LE(18),
          uncompressedSize: buffer.readUInt32LE(22),
          filenameLength: buffer.readUInt16LE(26),
          extraFieldLength: buffer.readUInt16LE(28)
        };
        zipHeader.filename = await tokenizer.readToken(new Token.StringType(zipHeader.filenameLength, "utf-8"));
        await tokenizer.ignore(zipHeader.extraFieldLength);
        if (zipHeader.filename === "META-INF/mozilla.rsa") {
          return {
            ext: "xpi",
            mime: "application/x-xpinstall"
          };
        }
        if (zipHeader.filename.endsWith(".rels") || zipHeader.filename.endsWith(".xml")) {
          const type = zipHeader.filename.split("/")[0];
          switch (type) {
            case "_rels":
              break;
            case "word":
              return {
                ext: "docx",
                mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
              };
            case "ppt":
              return {
                ext: "pptx",
                mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
              };
            case "xl":
              return {
                ext: "xlsx",
                mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
              };
            default:
              break;
          }
        }
        if (zipHeader.filename.startsWith("xl/")) {
          return {
            ext: "xlsx",
            mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
          };
        }
        if (zipHeader.filename.startsWith("3D/") && zipHeader.filename.endsWith(".model")) {
          return {
            ext: "3mf",
            mime: "model/3mf"
          };
        }
        if (zipHeader.filename === "mimetype" && zipHeader.compressedSize === zipHeader.uncompressedSize) {
          const mimeType = await tokenizer.readToken(new Token.StringType(zipHeader.compressedSize, "utf-8"));
          switch (mimeType) {
            case "application/epub+zip":
              return {
                ext: "epub",
                mime: "application/epub+zip"
              };
            case "application/vnd.oasis.opendocument.text":
              return {
                ext: "odt",
                mime: "application/vnd.oasis.opendocument.text"
              };
            case "application/vnd.oasis.opendocument.spreadsheet":
              return {
                ext: "ods",
                mime: "application/vnd.oasis.opendocument.spreadsheet"
              };
            case "application/vnd.oasis.opendocument.presentation":
              return {
                ext: "odp",
                mime: "application/vnd.oasis.opendocument.presentation"
              };
            default:
          }
        }
        if (zipHeader.compressedSize === 0) {
          let nextHeaderIndex = -1;
          while (nextHeaderIndex < 0 && tokenizer.position < tokenizer.fileInfo.size) {
            await tokenizer.peekBuffer(buffer, { mayBeLess: true });
            nextHeaderIndex = buffer.indexOf("504B0304", 0, "hex");
            await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : buffer.length);
          }
        } else {
          await tokenizer.ignore(zipHeader.compressedSize);
        }
      }
    } catch (error) {
      if (!(error instanceof strtok3.EndOfStreamError)) {
        throw error;
      }
    }
    return {
      ext: "zip",
      mime: "application/zip"
    };
  }
  if (checkString("OggS")) {
    await tokenizer.ignore(28);
    const type = Buffer.alloc(8);
    await tokenizer.readBuffer(type);
    if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
      return {
        ext: "opus",
        mime: "audio/opus"
      };
    }
    if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
      return {
        ext: "ogv",
        mime: "video/ogg"
      };
    }
    if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
      return {
        ext: "ogm",
        mime: "video/ogg"
      };
    }
    if (_check(type, [127, 70, 76, 65, 67])) {
      return {
        ext: "oga",
        mime: "audio/ogg"
      };
    }
    if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
      return {
        ext: "spx",
        mime: "audio/ogg"
      };
    }
    if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
      return {
        ext: "ogg",
        mime: "audio/ogg"
      };
    }
    return {
      ext: "ogx",
      mime: "application/ogg"
    };
  }
  if (check([80, 75]) && (buffer[2] === 3 || buffer[2] === 5 || buffer[2] === 7) && (buffer[3] === 4 || buffer[3] === 6 || buffer[3] === 8)) {
    return {
      ext: "zip",
      mime: "application/zip"
    };
  }
  if (checkString("ftyp", { offset: 4 }) && (buffer[8] & 96) !== 0) {
    const brandMajor = buffer.toString("binary", 8, 12).replace("\0", " ").trim();
    switch (brandMajor) {
      case "avif":
        return { ext: "avif", mime: "image/avif" };
      case "mif1":
        return { ext: "heic", mime: "image/heif" };
      case "msf1":
        return { ext: "heic", mime: "image/heif-sequence" };
      case "heic":
      case "heix":
        return { ext: "heic", mime: "image/heic" };
      case "hevc":
      case "hevx":
        return { ext: "heic", mime: "image/heic-sequence" };
      case "qt":
        return { ext: "mov", mime: "video/quicktime" };
      case "M4V":
      case "M4VH":
      case "M4VP":
        return { ext: "m4v", mime: "video/x-m4v" };
      case "M4P":
        return { ext: "m4p", mime: "video/mp4" };
      case "M4B":
        return { ext: "m4b", mime: "audio/mp4" };
      case "M4A":
        return { ext: "m4a", mime: "audio/x-m4a" };
      case "F4V":
        return { ext: "f4v", mime: "video/mp4" };
      case "F4P":
        return { ext: "f4p", mime: "video/mp4" };
      case "F4A":
        return { ext: "f4a", mime: "audio/mp4" };
      case "F4B":
        return { ext: "f4b", mime: "audio/mp4" };
      case "crx":
        return { ext: "cr3", mime: "image/x-canon-cr3" };
      default:
        if (brandMajor.startsWith("3g")) {
          if (brandMajor.startsWith("3g2")) {
            return { ext: "3g2", mime: "video/3gpp2" };
          }
          return { ext: "3gp", mime: "video/3gpp" };
        }
        return { ext: "mp4", mime: "video/mp4" };
    }
  }
  if (checkString("MThd")) {
    return {
      ext: "mid",
      mime: "audio/midi"
    };
  }
  if (checkString("wOFF") && (check([0, 1, 0, 0], { offset: 4 }) || checkString("OTTO", { offset: 4 }))) {
    return {
      ext: "woff",
      mime: "font/woff"
    };
  }
  if (checkString("wOF2") && (check([0, 1, 0, 0], { offset: 4 }) || checkString("OTTO", { offset: 4 }))) {
    return {
      ext: "woff2",
      mime: "font/woff2"
    };
  }
  if (check([212, 195, 178, 161]) || check([161, 178, 195, 212])) {
    return {
      ext: "pcap",
      mime: "application/vnd.tcpdump.pcap"
    };
  }
  if (checkString("DSD ")) {
    return {
      ext: "dsf",
      mime: "audio/x-dsf"
      // Non-standard
    };
  }
  if (checkString("LZIP")) {
    return {
      ext: "lz",
      mime: "application/x-lzip"
    };
  }
  if (checkString("fLaC")) {
    return {
      ext: "flac",
      mime: "audio/x-flac"
    };
  }
  if (check([66, 80, 71, 251])) {
    return {
      ext: "bpg",
      mime: "image/bpg"
    };
  }
  if (checkString("wvpk")) {
    return {
      ext: "wv",
      mime: "audio/wavpack"
    };
  }
  if (checkString("%PDF")) {
    await tokenizer.ignore(1350);
    const maxBufferSize2 = 10 * 1024 * 1024;
    const buffer2 = Buffer.alloc(Math.min(maxBufferSize2, tokenizer.fileInfo.size));
    await tokenizer.readBuffer(buffer2, { mayBeLess: true });
    if (buffer2.includes(Buffer.from("AIPrivateData"))) {
      return {
        ext: "ai",
        mime: "application/postscript"
      };
    }
    return {
      ext: "pdf",
      mime: "application/pdf"
    };
  }
  if (check([0, 97, 115, 109])) {
    return {
      ext: "wasm",
      mime: "application/wasm"
    };
  }
  if (check([73, 73, 42, 0])) {
    if (checkString("CR", { offset: 8 })) {
      return {
        ext: "cr2",
        mime: "image/x-canon-cr2"
      };
    }
    if (check([28, 0, 254, 0], { offset: 8 }) || check([31, 0, 11, 0], { offset: 8 })) {
      return {
        ext: "nef",
        mime: "image/x-nikon-nef"
      };
    }
    if (check([8, 0, 0, 0], { offset: 4 }) && (check([45, 0, 254, 0], { offset: 8 }) || check([39, 0, 254, 0], { offset: 8 }))) {
      return {
        ext: "dng",
        mime: "image/x-adobe-dng"
      };
    }
    buffer = Buffer.alloc(24);
    await tokenizer.peekBuffer(buffer);
    if ((check([16, 251, 134, 1], { offset: 4 }) || check([8, 0, 0, 0], { offset: 4 })) && // This pattern differentiates ARW from other TIFF-ish file types:
    check([0, 254, 0, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 1], { offset: 9 })) {
      return {
        ext: "arw",
        mime: "image/x-sony-arw"
      };
    }
    return {
      ext: "tif",
      mime: "image/tiff"
    };
  }
  if (check([77, 77, 0, 42])) {
    return {
      ext: "tif",
      mime: "image/tiff"
    };
  }
  if (checkString("MAC ")) {
    return {
      ext: "ape",
      mime: "audio/ape"
    };
  }
  if (check([26, 69, 223, 163])) {
    async function readField() {
      const msb = await tokenizer.peekNumber(Token.UINT8);
      let mask = 128;
      let ic = 0;
      while ((msb & mask) === 0 && mask !== 0) {
        ++ic;
        mask >>= 1;
      }
      const id = Buffer.alloc(ic + 1);
      await tokenizer.readBuffer(id);
      return id;
    }
    async function readElement() {
      const id = await readField();
      const lenField = await readField();
      lenField[0] ^= 128 >> lenField.length - 1;
      const nrLen = Math.min(6, lenField.length);
      return {
        id: id.readUIntBE(0, id.length),
        len: lenField.readUIntBE(lenField.length - nrLen, nrLen)
      };
    }
    async function readChildren(level, children) {
      while (children > 0) {
        const e = await readElement();
        if (e.id === 17026) {
          return tokenizer.readToken(new Token.StringType(e.len, "utf-8"));
        }
        await tokenizer.ignore(e.len);
        --children;
      }
    }
    const re = await readElement();
    const docType = await readChildren(1, re.len);
    switch (docType) {
      case "webm":
        return {
          ext: "webm",
          mime: "video/webm"
        };
      case "matroska":
        return {
          ext: "mkv",
          mime: "video/x-matroska"
        };
      default:
        return;
    }
  }
  if (check([82, 73, 70, 70])) {
    if (check([65, 86, 73], { offset: 8 })) {
      return {
        ext: "avi",
        mime: "video/vnd.avi"
      };
    }
    if (check([87, 65, 86, 69], { offset: 8 })) {
      return {
        ext: "wav",
        mime: "audio/vnd.wave"
      };
    }
    if (check([81, 76, 67, 77], { offset: 8 })) {
      return {
        ext: "qcp",
        mime: "audio/qcelp"
      };
    }
  }
  if (checkString("SQLi")) {
    return {
      ext: "sqlite",
      mime: "application/x-sqlite3"
    };
  }
  if (check([78, 69, 83, 26])) {
    return {
      ext: "nes",
      mime: "application/x-nintendo-nes-rom"
    };
  }
  if (checkString("Cr24")) {
    return {
      ext: "crx",
      mime: "application/x-google-chrome-extension"
    };
  }
  if (checkString("MSCF") || checkString("ISc(")) {
    return {
      ext: "cab",
      mime: "application/vnd.ms-cab-compressed"
    };
  }
  if (check([237, 171, 238, 219])) {
    return {
      ext: "rpm",
      mime: "application/x-rpm"
    };
  }
  if (check([197, 208, 211, 198])) {
    return {
      ext: "eps",
      mime: "application/eps"
    };
  }
  if (check([40, 181, 47, 253])) {
    return {
      ext: "zst",
      mime: "application/zstd"
    };
  }
  if (check([79, 84, 84, 79, 0])) {
    return {
      ext: "otf",
      mime: "font/otf"
    };
  }
  if (checkString("#!AMR")) {
    return {
      ext: "amr",
      mime: "audio/amr"
    };
  }
  if (checkString("{\\rtf")) {
    return {
      ext: "rtf",
      mime: "application/rtf"
    };
  }
  if (check([70, 76, 86, 1])) {
    return {
      ext: "flv",
      mime: "video/x-flv"
    };
  }
  if (checkString("IMPM")) {
    return {
      ext: "it",
      mime: "audio/x-it"
    };
  }
  if (checkString("-lh0-", { offset: 2 }) || checkString("-lh1-", { offset: 2 }) || checkString("-lh2-", { offset: 2 }) || checkString("-lh3-", { offset: 2 }) || checkString("-lh4-", { offset: 2 }) || checkString("-lh5-", { offset: 2 }) || checkString("-lh6-", { offset: 2 }) || checkString("-lh7-", { offset: 2 }) || checkString("-lzs-", { offset: 2 }) || checkString("-lz4-", { offset: 2 }) || checkString("-lz5-", { offset: 2 }) || checkString("-lhd-", { offset: 2 })) {
    return {
      ext: "lzh",
      mime: "application/x-lzh-compressed"
    };
  }
  if (check([0, 0, 1, 186])) {
    if (check([33], { offset: 4, mask: [241] })) {
      return {
        ext: "mpg",
        // May also be .ps, .mpeg
        mime: "video/MP1S"
      };
    }
    if (check([68], { offset: 4, mask: [196] })) {
      return {
        ext: "mpg",
        // May also be .mpg, .m2p, .vob or .sub
        mime: "video/MP2P"
      };
    }
  }
  if (checkString("ITSF")) {
    return {
      ext: "chm",
      mime: "application/vnd.ms-htmlhelp"
    };
  }
  if (check([253, 55, 122, 88, 90, 0])) {
    return {
      ext: "xz",
      mime: "application/x-xz"
    };
  }
  if (checkString("<?xml ")) {
    return {
      ext: "xml",
      mime: "application/xml"
    };
  }
  if (check([55, 122, 188, 175, 39, 28])) {
    return {
      ext: "7z",
      mime: "application/x-7z-compressed"
    };
  }
  if (check([82, 97, 114, 33, 26, 7]) && (buffer[6] === 0 || buffer[6] === 1)) {
    return {
      ext: "rar",
      mime: "application/x-rar-compressed"
    };
  }
  if (checkString("solid ")) {
    return {
      ext: "stl",
      mime: "model/stl"
    };
  }
  if (checkString("BLENDER")) {
    return {
      ext: "blend",
      mime: "application/x-blender"
    };
  }
  if (checkString("!<arch>")) {
    await tokenizer.ignore(8);
    const str = await tokenizer.readToken(new Token.StringType(13, "ascii"));
    if (str === "debian-binary") {
      return {
        ext: "deb",
        mime: "application/x-deb"
      };
    }
    return {
      ext: "ar",
      mime: "application/x-unix-archive"
    };
  }
  if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
    await tokenizer.ignore(8);
    async function readChunkHeader() {
      return {
        length: await tokenizer.readToken(Token.INT32_BE),
        type: await tokenizer.readToken(new Token.StringType(4, "binary"))
      };
    }
    do {
      const chunk = await readChunkHeader();
      if (chunk.length < 0) {
        return;
      }
      switch (chunk.type) {
        case "IDAT":
          return {
            ext: "png",
            mime: "image/png"
          };
        case "acTL":
          return {
            ext: "apng",
            mime: "image/apng"
          };
        default:
          await tokenizer.ignore(chunk.length + 4);
      }
    } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
    return {
      ext: "png",
      mime: "image/png"
    };
  }
  if (check([65, 82, 82, 79, 87, 49, 0, 0])) {
    return {
      ext: "arrow",
      mime: "application/x-apache-arrow"
    };
  }
  if (check([103, 108, 84, 70, 2, 0, 0, 0])) {
    return {
      ext: "glb",
      mime: "model/gltf-binary"
    };
  }
  if (check([102, 114, 101, 101], { offset: 4 }) || // `free`
  check([109, 100, 97, 116], { offset: 4 }) || // `mdat` MJPEG
  check([109, 111, 111, 118], { offset: 4 }) || // `moov`
  check([119, 105, 100, 101], { offset: 4 })) {
    return {
      ext: "mov",
      mime: "video/quicktime"
    };
  }
  if (check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
    return {
      ext: "orf",
      mime: "image/x-olympus-orf"
    };
  }
  if (checkString("gimp xcf ")) {
    return {
      ext: "xcf",
      mime: "image/x-xcf"
    };
  }
  if (check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
    return {
      ext: "rw2",
      mime: "image/x-panasonic-rw2"
    };
  }
  if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
    async function readHeader2() {
      const guid2 = Buffer.alloc(16);
      await tokenizer.readBuffer(guid2);
      return {
        id: guid2,
        size: Number(await tokenizer.readToken(Token.UINT64_LE))
      };
    }
    await tokenizer.ignore(30);
    while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
      const header = await readHeader2();
      let payload = header.size - 24;
      if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
        const typeId = Buffer.alloc(16);
        payload -= await tokenizer.readBuffer(typeId);
        if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
          return {
            ext: "asf",
            mime: "audio/x-ms-asf"
          };
        }
        if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
          return {
            ext: "asf",
            mime: "video/x-ms-asf"
          };
        }
        break;
      }
      await tokenizer.ignore(payload);
    }
    return {
      ext: "asf",
      mime: "application/vnd.ms-asf"
    };
  }
  if (check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
    return {
      ext: "ktx",
      mime: "image/ktx"
    };
  }
  if ((check([126, 16, 4]) || check([126, 24, 4])) && check([48, 77, 73, 69], { offset: 4 })) {
    return {
      ext: "mie",
      mime: "application/x-mie"
    };
  }
  if (check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
    return {
      ext: "shp",
      mime: "application/x-esri-shape"
    };
  }
  if (check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
    await tokenizer.ignore(20);
    const type = await tokenizer.readToken(new Token.StringType(4, "ascii"));
    switch (type) {
      case "jp2 ":
        return {
          ext: "jp2",
          mime: "image/jp2"
        };
      case "jpx ":
        return {
          ext: "jpx",
          mime: "image/jpx"
        };
      case "jpm ":
        return {
          ext: "jpm",
          mime: "image/jpm"
        };
      case "mjp2":
        return {
          ext: "mj2",
          mime: "image/mj2"
        };
      default:
        return;
    }
  }
  if (check([255, 10]) || check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
    return {
      ext: "jxl",
      mime: "image/jxl"
    };
  }
  if (check([0, 0, 1, 186]) || check([0, 0, 1, 179])) {
    return {
      ext: "mpg",
      mime: "video/mpeg"
    };
  }
  if (check([0, 1, 0, 0, 0])) {
    return {
      ext: "ttf",
      mime: "font/ttf"
    };
  }
  if (check([0, 0, 1, 0])) {
    return {
      ext: "ico",
      mime: "image/x-icon"
    };
  }
  if (check([0, 0, 2, 0])) {
    return {
      ext: "cur",
      mime: "image/x-icon"
    };
  }
  if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
    return {
      ext: "cfb",
      mime: "application/x-cfb"
    };
  }
  await tokenizer.peekBuffer(buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
  if (checkString("BEGIN:")) {
    if (checkString("VCARD", { offset: 6 })) {
      return {
        ext: "vcf",
        mime: "text/vcard"
      };
    }
    if (checkString("VCALENDAR", { offset: 6 })) {
      return {
        ext: "ics",
        mime: "text/calendar"
      };
    }
  }
  if (checkString("FUJIFILMCCD-RAW")) {
    return {
      ext: "raf",
      mime: "image/x-fujifilm-raf"
    };
  }
  if (checkString("Extended Module:")) {
    return {
      ext: "xm",
      mime: "audio/x-xm"
    };
  }
  if (checkString("Creative Voice File")) {
    return {
      ext: "voc",
      mime: "audio/x-voc"
    };
  }
  if (check([4, 0, 0, 0]) && buffer.length >= 16) {
    const jsonSize = buffer.readUInt32LE(12);
    if (jsonSize > 12 && buffer.length >= jsonSize + 16) {
      try {
        const header = buffer.slice(16, jsonSize + 16).toString();
        const json = JSON.parse(header);
        if (json.files) {
          return {
            ext: "asar",
            mime: "application/x-asar"
          };
        }
      } catch (_) {
      }
    }
  }
  if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
    return {
      ext: "mxf",
      mime: "application/mxf"
    };
  }
  if (checkString("SCRM", { offset: 44 })) {
    return {
      ext: "s3m",
      mime: "audio/x-s3m"
    };
  }
  if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 }))) {
    return {
      ext: "mts",
      mime: "video/mp2t"
    };
  }
  if (check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
    return {
      ext: "mobi",
      mime: "application/x-mobipocket-ebook"
    };
  }
  if (check([68, 73, 67, 77], { offset: 128 })) {
    return {
      ext: "dcm",
      mime: "application/dicom"
    };
  }
  if (check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
    return {
      ext: "lnk",
      mime: "application/x.ms.shortcut"
      // Invented by us
    };
  }
  if (check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
    return {
      ext: "alias",
      mime: "application/x.apple.alias"
      // Invented by us
    };
  }
  if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
    return {
      ext: "eot",
      mime: "application/vnd.ms-fontobject"
    };
  }
  if (check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
    return {
      ext: "indd",
      mime: "application/x-indesign"
    };
  }
  await tokenizer.peekBuffer(buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
  if (tarHeaderChecksumMatches(buffer)) {
    return {
      ext: "tar",
      mime: "application/x-tar"
    };
  }
  if (check([255, 254, 255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0])) {
    return {
      ext: "skp",
      mime: "application/vnd.sketchup.skp"
    };
  }
  if (checkString("-----BEGIN PGP MESSAGE-----")) {
    return {
      ext: "pgp",
      mime: "application/pgp-encrypted"
    };
  }
  if (buffer.length >= 2 && check([255, 224], { offset: 0, mask: [255, 224] })) {
    if (check([16], { offset: 1, mask: [22] })) {
      if (check([8], { offset: 1, mask: [8] })) {
        return {
          ext: "aac",
          mime: "audio/aac"
        };
      }
      return {
        ext: "aac",
        mime: "audio/aac"
      };
    }
    if (check([2], { offset: 1, mask: [6] })) {
      return {
        ext: "mp3",
        mime: "audio/mpeg"
      };
    }
    if (check([4], { offset: 1, mask: [6] })) {
      return {
        ext: "mp2",
        mime: "audio/mpeg"
      };
    }
    if (check([6], { offset: 1, mask: [6] })) {
      return {
        ext: "mp1",
        mime: "audio/mpeg"
      };
    }
  }
}
const stream = (readableStream) => new Promise((resolve, reject) => {
  const stream = eval("require")("stream");
  readableStream.on("error", reject);
  readableStream.once("readable", async () => {
    const pass = new stream.PassThrough();
    let outputStream;
    if (stream.pipeline) {
      outputStream = stream.pipeline(readableStream, pass, () => {
      });
    } else {
      outputStream = readableStream.pipe(pass);
    }
    const chunk = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);
    try {
      const fileType2 = await fromBuffer(chunk);
      pass.fileType = fileType2;
    } catch (error) {
      reject(error);
    }
    resolve(outputStream);
  });
});
const fileType = {
  fromStream,
  fromTokenizer,
  fromBuffer,
  stream
};
Object.defineProperty(fileType, "extensions", {
  get() {
    return new Set(supported.extensions);
  }
});
Object.defineProperty(fileType, "mimeTypes", {
  get() {
    return new Set(supported.mimeTypes);
  }
});
var core = fileType;
const fileType$1 = /* @__PURE__ */ getDefaultExportFromCjs(core);
function to(promise, errorExt) {
  return promise.then(function(data) {
    return [null, data];
  }).catch(function(err) {
    return [err, void 0];
  });
}
const readFile = promises.readFile;
const writeFile = promises.writeFile;
function Mime$1() {
  this._types = /* @__PURE__ */ Object.create(null);
  this._extensions = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < arguments.length; i++) {
    this.define(arguments[i]);
  }
  this.define = this.define.bind(this);
  this.getType = this.getType.bind(this);
  this.getExtension = this.getExtension.bind(this);
}
Mime$1.prototype.define = function(typeMap, force) {
  for (let type in typeMap) {
    let extensions = typeMap[type].map(function(t) {
      return t.toLowerCase();
    });
    type = type.toLowerCase();
    for (let i = 0; i < extensions.length; i++) {
      const ext = extensions[i];
      if (ext[0] === "*") {
        continue;
      }
      if (!force && ext in this._types) {
        throw new Error(
          'Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".'
        );
      }
      this._types[ext] = type;
    }
    if (force || !this._extensions[type]) {
      const ext = extensions[0];
      this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
    }
  }
};
Mime$1.prototype.getType = function(path2) {
  path2 = String(path2);
  let last = path2.replace(/^.*[/\\]/, "").toLowerCase();
  let ext = last.replace(/^.*\./, "").toLowerCase();
  let hasPath = last.length < path2.length;
  let hasDot = ext.length < last.length - 1;
  return (hasDot || !hasPath) && this._types[ext] || null;
};
Mime$1.prototype.getExtension = function(type) {
  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
  return type && this._extensions[type.toLowerCase()] || null;
};
var Mime_1 = Mime$1;
var standard = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
let Mime = Mime_1;
var lite = new Mime(standard);
const mime = /* @__PURE__ */ getDefaultExportFromCjs(lite);
var HorizontalAlign;
(function(HorizontalAlign2) {
  HorizontalAlign2[HorizontalAlign2["LEFT"] = 1] = "LEFT";
  HorizontalAlign2[HorizontalAlign2["CENTER"] = 2] = "CENTER";
  HorizontalAlign2[HorizontalAlign2["RIGHT"] = 4] = "RIGHT";
})(HorizontalAlign || (HorizontalAlign = {}));
var VerticalAlign;
(function(VerticalAlign2) {
  VerticalAlign2[VerticalAlign2["TOP"] = 8] = "TOP";
  VerticalAlign2[VerticalAlign2["MIDDLE"] = 16] = "MIDDLE";
  VerticalAlign2[VerticalAlign2["BOTTOM"] = 32] = "BOTTOM";
})(VerticalAlign || (VerticalAlign = {}));
var BlendMode;
(function(BlendMode2) {
  BlendMode2["SRC_OVER"] = "srcOver";
  BlendMode2["DST_OVER"] = "dstOver";
  BlendMode2["MULTIPLY"] = "multiply";
  BlendMode2["ADD"] = "add";
  BlendMode2["SCREEN"] = "screen";
  BlendMode2["OVERLAY"] = "overlay";
  BlendMode2["DARKEN"] = "darken";
  BlendMode2["LIGHTEN"] = "lighten";
  BlendMode2["HARD_LIGHT"] = "hardLight";
  BlendMode2["DIFFERENCE"] = "difference";
  BlendMode2["EXCLUSION"] = "exclusion";
})(BlendMode || (BlendMode = {}));
function srcOver(src2, dst, ops = 1) {
  src2.a *= ops;
  const a = dst.a + src2.a - dst.a * src2.a;
  const r = (src2.r * src2.a + dst.r * dst.a * (1 - src2.a)) / a;
  const g = (src2.g * src2.a + dst.g * dst.a * (1 - src2.a)) / a;
  const b = (src2.b * src2.a + dst.b * dst.a * (1 - src2.a)) / a;
  return { r, g, b, a };
}
function dstOver(src2, dst, ops = 1) {
  src2.a *= ops;
  const a = dst.a + src2.a - dst.a * src2.a;
  const r = (dst.r * dst.a + src2.r * src2.a * (1 - dst.a)) / a;
  const g = (dst.g * dst.a + src2.g * src2.a * (1 - dst.a)) / a;
  const b = (dst.b * dst.a + src2.b * src2.a * (1 - dst.a)) / a;
  return { r, g, b, a };
}
function multiply(src2, dst, ops = 1) {
  src2.a *= ops;
  const a = dst.a + src2.a - dst.a * src2.a;
  const sra = src2.r * src2.a;
  const sga = src2.g * src2.a;
  const sba = src2.b * src2.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (sra * dra + sra * (1 - dst.a) + dra * (1 - src2.a)) / a;
  const g = (sga * dga + sga * (1 - dst.a) + dga * (1 - src2.a)) / a;
  const b = (sba * dba + sba * (1 - dst.a) + dba * (1 - src2.a)) / a;
  return { r, g, b, a };
}
function add(src2, dst, ops = 1) {
  src2.a *= ops;
  const a = dst.a + src2.a - dst.a * src2.a;
  const sra = src2.r * src2.a;
  const sga = src2.g * src2.a;
  const sba = src2.b * src2.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (sra + dra) / a;
  const g = (sga + dga) / a;
  const b = (sba + dba) / a;
  return { r, g, b, a };
}
function screen(src2, dst, ops = 1) {
  src2.a *= ops;
  const a = dst.a + src2.a - dst.a * src2.a;
  const sra = src2.r * src2.a;
  const sga = src2.g * src2.a;
  const sba = src2.b * src2.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (sra * dst.a + dra * src2.a - sra * dra + sra * (1 - dst.a) + dra * (1 - src2.a)) / a;
  const g = (sga * dst.a + dga * src2.a - sga * dga + sga * (1 - dst.a) + dga * (1 - src2.a)) / a;
  const b = (sba * dst.a + dba * src2.a - sba * dba + sba * (1 - dst.a) + dba * (1 - src2.a)) / a;
  return { r, g, b, a };
}
function overlay(src2, dst, ops = 1) {
  src2.a *= ops;
  const a = dst.a + src2.a - dst.a * src2.a;
  const sra = src2.r * src2.a;
  const sga = src2.g * src2.a;
  const sba = src2.b * src2.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (2 * dra <= dst.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src2.a) : sra * (1 + dst.a) + dra * (1 + src2.a) - 2 * dra * sra - dst.a * src2.a) / a;
  const g = (2 * dga <= dst.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src2.a) : sga * (1 + dst.a) + dga * (1 + src2.a) - 2 * dga * sga - dst.a * src2.a) / a;
  const b = (2 * dba <= dst.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src2.a) : sba * (1 + dst.a) + dba * (1 + src2.a) - 2 * dba * sba - dst.a * src2.a) / a;
  return { r, g, b, a };
}
function darken(src2, dst, ops = 1) {
  src2.a *= ops;
  const a = dst.a + src2.a - dst.a * src2.a;
  const sra = src2.r * src2.a;
  const sga = src2.g * src2.a;
  const sba = src2.b * src2.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (Math.min(sra * dst.a, dra * src2.a) + sra * (1 - dst.a) + dra * (1 - src2.a)) / a;
  const g = (Math.min(sga * dst.a, dga * src2.a) + sga * (1 - dst.a) + dga * (1 - src2.a)) / a;
  const b = (Math.min(sba * dst.a, dba * src2.a) + sba * (1 - dst.a) + dba * (1 - src2.a)) / a;
  return { r, g, b, a };
}
function lighten(src2, dst, ops = 1) {
  src2.a *= ops;
  const a = dst.a + src2.a - dst.a * src2.a;
  const sra = src2.r * src2.a;
  const sga = src2.g * src2.a;
  const sba = src2.b * src2.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (Math.max(sra * dst.a, dra * src2.a) + sra * (1 - dst.a) + dra * (1 - src2.a)) / a;
  const g = (Math.max(sga * dst.a, dga * src2.a) + sga * (1 - dst.a) + dga * (1 - src2.a)) / a;
  const b = (Math.max(sba * dst.a, dba * src2.a) + sba * (1 - dst.a) + dba * (1 - src2.a)) / a;
  return { r, g, b, a };
}
function hardLight(src2, dst, ops = 1) {
  src2.a *= ops;
  const a = dst.a + src2.a - dst.a * src2.a;
  const sra = src2.r * src2.a;
  const sga = src2.g * src2.a;
  const sba = src2.b * src2.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (2 * sra <= src2.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src2.a) : sra * (1 + dst.a) + dra * (1 + src2.a) - 2 * dra * sra - dst.a * src2.a) / a;
  const g = (2 * sga <= src2.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src2.a) : sga * (1 + dst.a) + dga * (1 + src2.a) - 2 * dga * sga - dst.a * src2.a) / a;
  const b = (2 * sba <= src2.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src2.a) : sba * (1 + dst.a) + dba * (1 + src2.a) - 2 * dba * sba - dst.a * src2.a) / a;
  return { r, g, b, a };
}
function difference(src2, dst, ops = 1) {
  src2.a *= ops;
  const a = dst.a + src2.a - dst.a * src2.a;
  const sra = src2.r * src2.a;
  const sga = src2.g * src2.a;
  const sba = src2.b * src2.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (sra + dra - 2 * Math.min(sra * dst.a, dra * src2.a)) / a;
  const g = (sga + dga - 2 * Math.min(sga * dst.a, dga * src2.a)) / a;
  const b = (sba + dba - 2 * Math.min(sba * dst.a, dba * src2.a)) / a;
  return { r, g, b, a };
}
function exclusion(src2, dst, ops = 1) {
  src2.a *= ops;
  const a = dst.a + src2.a - dst.a * src2.a;
  const sra = src2.r * src2.a;
  const sga = src2.g * src2.a;
  const sba = src2.b * src2.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (sra * dst.a + dra * src2.a - 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src2.a)) / a;
  const g = (sga * dst.a + dga * src2.a - 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src2.a)) / a;
  const b = (sba * dst.a + dba * src2.a - 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src2.a)) / a;
  return { r, g, b, a };
}
const names = [
  srcOver,
  dstOver,
  multiply,
  add,
  screen,
  overlay,
  darken,
  lighten,
  hardLight,
  difference,
  exclusion
];
const compositeModes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add,
  darken,
  difference,
  dstOver,
  exclusion,
  hardLight,
  lighten,
  multiply,
  names,
  overlay,
  screen,
  srcOver
}, Symbol.toStringTag, { value: "Module" }));
function composite(baseImage, src2, x2 = 0, y2 = 0, options = {}) {
  if (!(src2 instanceof baseImage.constructor)) {
    throw new Error("The source must be a Jimp image");
  }
  if (typeof x2 !== "number" || typeof y2 !== "number") {
    throw new Error("x and y must be numbers");
  }
  const { mode = BlendMode.SRC_OVER } = options;
  let { opacitySource = 1, opacityDest = 1 } = options;
  if (typeof opacitySource !== "number" || opacitySource < 0 || opacitySource > 1) {
    opacitySource = 1;
  }
  if (typeof opacityDest !== "number" || opacityDest < 0 || opacityDest > 1) {
    opacityDest = 1;
  }
  const blendmode = compositeModes[mode];
  x2 = Math.round(x2);
  y2 = Math.round(y2);
  if (opacityDest !== 1) {
    baseImage.scan((_, __, idx) => {
      const v = baseImage.bitmap.data[idx + 3] * opacityDest;
      baseImage.bitmap.data[idx + 3] = v;
    });
  }
  src2.scan((sx, sy, idx) => {
    const dstIdx = baseImage.getPixelIndex(x2 + sx, y2 + sy, Edge.CROP);
    if (dstIdx === -1) {
      return;
    }
    const blended = blendmode({
      r: src2.bitmap.data[idx + 0] / 255,
      g: src2.bitmap.data[idx + 1] / 255,
      b: src2.bitmap.data[idx + 2] / 255,
      a: src2.bitmap.data[idx + 3] / 255
    }, {
      r: baseImage.bitmap.data[dstIdx + 0] / 255,
      g: baseImage.bitmap.data[dstIdx + 1] / 255,
      b: baseImage.bitmap.data[dstIdx + 2] / 255,
      a: baseImage.bitmap.data[dstIdx + 3] / 255
    }, opacitySource);
    baseImage.bitmap.data[dstIdx + 0] = limit255(blended.r * 255);
    baseImage.bitmap.data[dstIdx + 1] = limit255(blended.g * 255);
    baseImage.bitmap.data[dstIdx + 2] = limit255(blended.b * 255);
    baseImage.bitmap.data[dstIdx + 3] = limit255(blended.a * 255);
  });
  return baseImage;
}
var jpeg$1 = {
  parseSections: function(stream2, iterator) {
    var len, markerType;
    stream2.setBigEndian(true);
    while (stream2.remainingLength() > 0 && markerType !== 218) {
      if (stream2.nextUInt8() !== 255) {
        throw new Error("Invalid JPEG section offset");
      }
      markerType = stream2.nextUInt8();
      if (markerType >= 208 && markerType <= 217 || markerType === 218) {
        len = 0;
      } else {
        len = stream2.nextUInt16() - 2;
      }
      iterator(markerType, stream2.branch(0, len));
      stream2.skip(len);
    }
  },
  //stream should be located after SOF section size and in big endian mode, like passed to parseSections iterator
  getSizeFromSOFSection: function(stream2) {
    stream2.skip(1);
    return {
      height: stream2.nextUInt16(),
      width: stream2.nextUInt16()
    };
  },
  getSectionName: function(markerType) {
    var name, index;
    switch (markerType) {
      case 216:
        name = "SOI";
        break;
      case 196:
        name = "DHT";
        break;
      case 219:
        name = "DQT";
        break;
      case 221:
        name = "DRI";
        break;
      case 218:
        name = "SOS";
        break;
      case 254:
        name = "COM";
        break;
      case 217:
        name = "EOI";
        break;
      default:
        if (markerType >= 224 && markerType <= 239) {
          name = "APP";
          index = markerType - 224;
        } else if (markerType >= 192 && markerType <= 207 && markerType !== 196 && markerType !== 200 && markerType !== 204) {
          name = "SOF";
          index = markerType - 192;
        } else if (markerType >= 208 && markerType <= 215) {
          name = "RST";
          index = markerType - 208;
        }
        break;
    }
    var nameStruct = {
      name
    };
    if (typeof index === "number") {
      nameStruct.index = index;
    }
    return nameStruct;
  }
};
function readExifValue(format, stream2) {
  switch (format) {
    case 1:
      return stream2.nextUInt8();
    case 3:
      return stream2.nextUInt16();
    case 4:
      return stream2.nextUInt32();
    case 5:
      return [stream2.nextUInt32(), stream2.nextUInt32()];
    case 6:
      return stream2.nextInt8();
    case 8:
      return stream2.nextUInt16();
    case 9:
      return stream2.nextUInt32();
    case 10:
      return [stream2.nextInt32(), stream2.nextInt32()];
    case 11:
      return stream2.nextFloat();
    case 12:
      return stream2.nextDouble();
    default:
      throw new Error("Invalid format while decoding: " + format);
  }
}
function getBytesPerComponent(format) {
  switch (format) {
    case 1:
    case 2:
    case 6:
    case 7:
      return 1;
    case 3:
    case 8:
      return 2;
    case 4:
    case 9:
    case 11:
      return 4;
    case 5:
    case 10:
    case 12:
      return 8;
    default:
      return 0;
  }
}
function readExifTag(tiffMarker, stream2) {
  var tagType = stream2.nextUInt16(), format = stream2.nextUInt16(), bytesPerComponent = getBytesPerComponent(format), components = stream2.nextUInt32(), valueBytes = bytesPerComponent * components, values, c2;
  if (valueBytes > 4) {
    stream2 = tiffMarker.openWithOffset(stream2.nextUInt32());
  }
  if (format === 2) {
    values = stream2.nextString(components);
    var lastNull = values.indexOf("\0");
    if (lastNull !== -1) {
      values = values.substr(0, lastNull);
    }
  } else if (format === 7) {
    values = stream2.nextBuffer(components);
  } else if (format !== 0) {
    values = [];
    for (c2 = 0; c2 < components; ++c2) {
      values.push(readExifValue(format, stream2));
    }
  }
  if (valueBytes < 4) {
    stream2.skip(4 - valueBytes);
  }
  return [tagType, values, format];
}
function readIFDSection(tiffMarker, stream2, iterator) {
  var numberOfEntries = stream2.nextUInt16(), tag, i;
  for (i = 0; i < numberOfEntries; ++i) {
    tag = readExifTag(tiffMarker, stream2);
    iterator(tag[0], tag[1], tag[2]);
  }
}
function readHeader(stream2) {
  var exifHeader = stream2.nextString(6);
  if (exifHeader !== "Exif\0\0") {
    throw new Error("Invalid EXIF header");
  }
  var tiffMarker = stream2.mark();
  var tiffHeader = stream2.nextUInt16();
  if (tiffHeader === 18761) {
    stream2.setBigEndian(false);
  } else if (tiffHeader === 19789) {
    stream2.setBigEndian(true);
  } else {
    throw new Error("Invalid TIFF header");
  }
  if (stream2.nextUInt16() !== 42) {
    throw new Error("Invalid TIFF data");
  }
  return tiffMarker;
}
var exif$2 = {
  IFD0: 1,
  IFD1: 2,
  GPSIFD: 3,
  SubIFD: 4,
  InteropIFD: 5,
  parseTags: function(stream2, iterator) {
    var tiffMarker;
    try {
      tiffMarker = readHeader(stream2);
    } catch (e) {
      return false;
    }
    var subIfdOffset, gpsOffset, interopOffset;
    var ifd0Stream = tiffMarker.openWithOffset(stream2.nextUInt32()), IFD0 = this.IFD0;
    readIFDSection(tiffMarker, ifd0Stream, function(tagType, value, format) {
      switch (tagType) {
        case 34853:
          gpsOffset = value[0];
          break;
        case 34665:
          subIfdOffset = value[0];
          break;
        default:
          iterator(IFD0, tagType, value, format);
          break;
      }
    });
    var ifd1Offset = ifd0Stream.nextUInt32();
    if (ifd1Offset !== 0) {
      var ifd1Stream = tiffMarker.openWithOffset(ifd1Offset);
      readIFDSection(tiffMarker, ifd1Stream, iterator.bind(null, this.IFD1));
    }
    if (gpsOffset) {
      var gpsStream = tiffMarker.openWithOffset(gpsOffset);
      readIFDSection(tiffMarker, gpsStream, iterator.bind(null, this.GPSIFD));
    }
    if (subIfdOffset) {
      var subIfdStream = tiffMarker.openWithOffset(subIfdOffset), InteropIFD = this.InteropIFD;
      readIFDSection(tiffMarker, subIfdStream, function(tagType, value, format) {
        if (tagType === 40965) {
          interopOffset = value[0];
        } else {
          iterator(InteropIFD, tagType, value, format);
        }
      });
    }
    if (interopOffset) {
      var interopStream = tiffMarker.openWithOffset(interopOffset);
      readIFDSection(tiffMarker, interopStream, iterator.bind(null, this.InteropIFD));
    }
    return true;
  }
};
function parseNumber(s) {
  return parseInt(s, 10);
}
var hours = 3600;
var minutes = 60;
function parseDateTimeParts(dateParts, timeParts) {
  dateParts = dateParts.map(parseNumber);
  timeParts = timeParts.map(parseNumber);
  var year = dateParts[0];
  var month = dateParts[1] - 1;
  var day = dateParts[2];
  var hours2 = timeParts[0];
  var minutes2 = timeParts[1];
  var seconds = timeParts[2];
  var date2 = Date.UTC(year, month, day, hours2, minutes2, seconds, 0);
  var timestamp = date2 / 1e3;
  return timestamp;
}
function parseDateWithTimezoneFormat(dateTimeStr) {
  var dateParts = dateTimeStr.substr(0, 10).split("-");
  var timeParts = dateTimeStr.substr(11, 8).split(":");
  var timezoneStr = dateTimeStr.substr(19, 6);
  var timezoneParts = timezoneStr.split(":").map(parseNumber);
  var timezoneOffset = timezoneParts[0] * hours + timezoneParts[1] * minutes;
  var timestamp = parseDateTimeParts(dateParts, timeParts);
  timestamp -= timezoneOffset;
  if (typeof timestamp === "number" && !isNaN(timestamp)) {
    return timestamp;
  }
}
function parseDateWithSpecFormat(dateTimeStr) {
  var parts = dateTimeStr.split(" "), dateParts = parts[0].split(":"), timeParts = parts[1].split(":");
  var timestamp = parseDateTimeParts(dateParts, timeParts);
  if (typeof timestamp === "number" && !isNaN(timestamp)) {
    return timestamp;
  }
}
function parseExifDate(dateTimeStr) {
  var isSpecFormat = dateTimeStr.length === 19 && dateTimeStr.charAt(4) === ":";
  var isTimezoneFormat = dateTimeStr.length === 25 && dateTimeStr.charAt(10) === "T";
  if (isTimezoneFormat) {
    return parseDateWithTimezoneFormat(dateTimeStr);
  } else if (isSpecFormat) {
    return parseDateWithSpecFormat(dateTimeStr);
  }
}
var date$1 = {
  parseDateWithSpecFormat,
  parseDateWithTimezoneFormat,
  parseExifDate
};
var exif$1 = exif$2;
var date = date$1;
var degreeTags = [
  {
    section: exif$1.GPSIFD,
    type: 2,
    name: "GPSLatitude",
    refType: 1,
    refName: "GPSLatitudeRef",
    posVal: "N"
  },
  {
    section: exif$1.GPSIFD,
    type: 4,
    name: "GPSLongitude",
    refType: 3,
    refName: "GPSLongitudeRef",
    posVal: "E"
  }
];
var dateTags = [
  {
    section: exif$1.SubIFD,
    type: 306,
    name: "ModifyDate"
  },
  {
    section: exif$1.SubIFD,
    type: 36867,
    name: "DateTimeOriginal"
  },
  {
    section: exif$1.SubIFD,
    type: 36868,
    name: "CreateDate"
  },
  {
    section: exif$1.SubIFD,
    type: 306,
    name: "ModifyDate"
  }
];
var simplify$1 = {
  castDegreeValues: function(getTagValue, setTagValue) {
    degreeTags.forEach(function(t) {
      var degreeVal = getTagValue(t);
      if (degreeVal) {
        var degreeRef = getTagValue({ section: t.section, type: t.refType, name: t.refName });
        var degreeNumRef = degreeRef === t.posVal ? 1 : -1;
        var degree = (degreeVal[0] + degreeVal[1] / 60 + degreeVal[2] / 3600) * degreeNumRef;
        setTagValue(t, degree);
      }
    });
  },
  castDateValues: function(getTagValue, setTagValue) {
    dateTags.forEach(function(t) {
      var dateStrVal = getTagValue(t);
      if (dateStrVal) {
        var timestamp = date.parseExifDate(dateStrVal);
        if (typeof timestamp !== "undefined") {
          setTagValue(t, timestamp);
        }
      }
    });
  },
  simplifyValue: function(values, format) {
    if (Array.isArray(values)) {
      values = values.map(function(value) {
        if (format === 10 || format === 5) {
          return value[0] / value[1];
        }
        return value;
      });
      if (values.length === 1) {
        values = values[0];
      }
    }
    return values;
  }
};
var exifTags;
var hasRequiredExifTags;
function requireExifTags() {
  if (hasRequiredExifTags) return exifTags;
  hasRequiredExifTags = 1;
  exifTags = {
    exif: {
      1: "InteropIndex",
      2: "InteropVersion",
      11: "ProcessingSoftware",
      254: "SubfileType",
      255: "OldSubfileType",
      256: "ImageWidth",
      257: "ImageHeight",
      258: "BitsPerSample",
      259: "Compression",
      262: "PhotometricInterpretation",
      263: "Thresholding",
      264: "CellWidth",
      265: "CellLength",
      266: "FillOrder",
      269: "DocumentName",
      270: "ImageDescription",
      271: "Make",
      272: "Model",
      273: "StripOffsets",
      274: "Orientation",
      277: "SamplesPerPixel",
      278: "RowsPerStrip",
      279: "StripByteCounts",
      280: "MinSampleValue",
      281: "MaxSampleValue",
      282: "XResolution",
      283: "YResolution",
      284: "PlanarConfiguration",
      285: "PageName",
      286: "XPosition",
      287: "YPosition",
      288: "FreeOffsets",
      289: "FreeByteCounts",
      290: "GrayResponseUnit",
      291: "GrayResponseCurve",
      292: "T4Options",
      293: "T6Options",
      296: "ResolutionUnit",
      297: "PageNumber",
      300: "ColorResponseUnit",
      301: "TransferFunction",
      305: "Software",
      306: "ModifyDate",
      315: "Artist",
      316: "HostComputer",
      317: "Predictor",
      318: "WhitePoint",
      319: "PrimaryChromaticities",
      320: "ColorMap",
      321: "HalftoneHints",
      322: "TileWidth",
      323: "TileLength",
      324: "TileOffsets",
      325: "TileByteCounts",
      326: "BadFaxLines",
      327: "CleanFaxData",
      328: "ConsecutiveBadFaxLines",
      330: "SubIFD",
      332: "InkSet",
      333: "InkNames",
      334: "NumberofInks",
      336: "DotRange",
      337: "TargetPrinter",
      338: "ExtraSamples",
      339: "SampleFormat",
      340: "SMinSampleValue",
      341: "SMaxSampleValue",
      342: "TransferRange",
      343: "ClipPath",
      344: "XClipPathUnits",
      345: "YClipPathUnits",
      346: "Indexed",
      347: "JPEGTables",
      351: "OPIProxy",
      400: "GlobalParametersIFD",
      401: "ProfileType",
      402: "FaxProfile",
      403: "CodingMethods",
      404: "VersionYear",
      405: "ModeNumber",
      433: "Decode",
      434: "DefaultImageColor",
      435: "T82Options",
      437: "JPEGTables",
      512: "JPEGProc",
      513: "ThumbnailOffset",
      514: "ThumbnailLength",
      515: "JPEGRestartInterval",
      517: "JPEGLosslessPredictors",
      518: "JPEGPointTransforms",
      519: "JPEGQTables",
      520: "JPEGDCTables",
      521: "JPEGACTables",
      529: "YCbCrCoefficients",
      530: "YCbCrSubSampling",
      531: "YCbCrPositioning",
      532: "ReferenceBlackWhite",
      559: "StripRowCounts",
      700: "ApplicationNotes",
      999: "USPTOMiscellaneous",
      4096: "RelatedImageFileFormat",
      4097: "RelatedImageWidth",
      4098: "RelatedImageHeight",
      18246: "Rating",
      18247: "XP_DIP_XML",
      18248: "StitchInfo",
      18249: "RatingPercent",
      32781: "ImageID",
      32931: "WangTag1",
      32932: "WangAnnotation",
      32933: "WangTag3",
      32934: "WangTag4",
      32995: "Matteing",
      32996: "DataType",
      32997: "ImageDepth",
      32998: "TileDepth",
      33405: "Model2",
      33421: "CFARepeatPatternDim",
      33422: "CFAPattern2",
      33423: "BatteryLevel",
      33424: "KodakIFD",
      33432: "Copyright",
      33434: "ExposureTime",
      33437: "FNumber",
      33445: "MDFileTag",
      33446: "MDScalePixel",
      33447: "MDColorTable",
      33448: "MDLabName",
      33449: "MDSampleInfo",
      33450: "MDPrepDate",
      33451: "MDPrepTime",
      33452: "MDFileUnits",
      33550: "PixelScale",
      33589: "AdventScale",
      33590: "AdventRevision",
      33628: "UIC1Tag",
      33629: "UIC2Tag",
      33630: "UIC3Tag",
      33631: "UIC4Tag",
      33723: "IPTC-NAA",
      33918: "IntergraphPacketData",
      33919: "IntergraphFlagRegisters",
      33920: "IntergraphMatrix",
      33921: "INGRReserved",
      33922: "ModelTiePoint",
      34016: "Site",
      34017: "ColorSequence",
      34018: "IT8Header",
      34019: "RasterPadding",
      34020: "BitsPerRunLength",
      34021: "BitsPerExtendedRunLength",
      34022: "ColorTable",
      34023: "ImageColorIndicator",
      34024: "BackgroundColorIndicator",
      34025: "ImageColorValue",
      34026: "BackgroundColorValue",
      34027: "PixelIntensityRange",
      34028: "TransparencyIndicator",
      34029: "ColorCharacterization",
      34030: "HCUsage",
      34031: "TrapIndicator",
      34032: "CMYKEquivalent",
      34118: "SEMInfo",
      34152: "AFCP_IPTC",
      34232: "PixelMagicJBIGOptions",
      34264: "ModelTransform",
      34306: "WB_GRGBLevels",
      34310: "LeafData",
      34377: "PhotoshopSettings",
      34665: "ExifOffset",
      34675: "ICC_Profile",
      34687: "TIFF_FXExtensions",
      34688: "MultiProfiles",
      34689: "SharedData",
      34690: "T88Options",
      34732: "ImageLayer",
      34735: "GeoTiffDirectory",
      34736: "GeoTiffDoubleParams",
      34737: "GeoTiffAsciiParams",
      34850: "ExposureProgram",
      34852: "SpectralSensitivity",
      34853: "GPSInfo",
      34855: "ISO",
      34856: "Opto-ElectricConvFactor",
      34857: "Interlace",
      34858: "TimeZoneOffset",
      34859: "SelfTimerMode",
      34864: "SensitivityType",
      34865: "StandardOutputSensitivity",
      34866: "RecommendedExposureIndex",
      34867: "ISOSpeed",
      34868: "ISOSpeedLatitudeyyy",
      34869: "ISOSpeedLatitudezzz",
      34908: "FaxRecvParams",
      34909: "FaxSubAddress",
      34910: "FaxRecvTime",
      34954: "LeafSubIFD",
      36864: "ExifVersion",
      36867: "DateTimeOriginal",
      36868: "CreateDate",
      37121: "ComponentsConfiguration",
      37122: "CompressedBitsPerPixel",
      37377: "ShutterSpeedValue",
      37378: "ApertureValue",
      37379: "BrightnessValue",
      37380: "ExposureCompensation",
      37381: "MaxApertureValue",
      37382: "SubjectDistance",
      37383: "MeteringMode",
      37384: "LightSource",
      37385: "Flash",
      37386: "FocalLength",
      37387: "FlashEnergy",
      37388: "SpatialFrequencyResponse",
      37389: "Noise",
      37390: "FocalPlaneXResolution",
      37391: "FocalPlaneYResolution",
      37392: "FocalPlaneResolutionUnit",
      37393: "ImageNumber",
      37394: "SecurityClassification",
      37395: "ImageHistory",
      37396: "SubjectArea",
      37397: "ExposureIndex",
      37398: "TIFF-EPStandardID",
      37399: "SensingMethod",
      37434: "CIP3DataFile",
      37435: "CIP3Sheet",
      37436: "CIP3Side",
      37439: "StoNits",
      37500: "MakerNote",
      37510: "UserComment",
      37520: "SubSecTime",
      37521: "SubSecTimeOriginal",
      37522: "SubSecTimeDigitized",
      37679: "MSDocumentText",
      37680: "MSPropertySetStorage",
      37681: "MSDocumentTextPosition",
      37724: "ImageSourceData",
      40091: "XPTitle",
      40092: "XPComment",
      40093: "XPAuthor",
      40094: "XPKeywords",
      40095: "XPSubject",
      40960: "FlashpixVersion",
      40961: "ColorSpace",
      40962: "ExifImageWidth",
      40963: "ExifImageHeight",
      40964: "RelatedSoundFile",
      40965: "InteropOffset",
      41483: "FlashEnergy",
      41484: "SpatialFrequencyResponse",
      41485: "Noise",
      41486: "FocalPlaneXResolution",
      41487: "FocalPlaneYResolution",
      41488: "FocalPlaneResolutionUnit",
      41489: "ImageNumber",
      41490: "SecurityClassification",
      41491: "ImageHistory",
      41492: "SubjectLocation",
      41493: "ExposureIndex",
      41494: "TIFF-EPStandardID",
      41495: "SensingMethod",
      41728: "FileSource",
      41729: "SceneType",
      41730: "CFAPattern",
      41985: "CustomRendered",
      41986: "ExposureMode",
      41987: "WhiteBalance",
      41988: "DigitalZoomRatio",
      41989: "FocalLengthIn35mmFormat",
      41990: "SceneCaptureType",
      41991: "GainControl",
      41992: "Contrast",
      41993: "Saturation",
      41994: "Sharpness",
      41995: "DeviceSettingDescription",
      41996: "SubjectDistanceRange",
      42016: "ImageUniqueID",
      42032: "OwnerName",
      42033: "SerialNumber",
      42034: "LensInfo",
      42035: "LensMake",
      42036: "LensModel",
      42037: "LensSerialNumber",
      42112: "GDALMetadata",
      42113: "GDALNoData",
      42240: "Gamma",
      44992: "ExpandSoftware",
      44993: "ExpandLens",
      44994: "ExpandFilm",
      44995: "ExpandFilterLens",
      44996: "ExpandScanner",
      44997: "ExpandFlashLamp",
      48129: "PixelFormat",
      48130: "Transformation",
      48131: "Uncompressed",
      48132: "ImageType",
      48256: "ImageWidth",
      48257: "ImageHeight",
      48258: "WidthResolution",
      48259: "HeightResolution",
      48320: "ImageOffset",
      48321: "ImageByteCount",
      48322: "AlphaOffset",
      48323: "AlphaByteCount",
      48324: "ImageDataDiscard",
      48325: "AlphaDataDiscard",
      50215: "OceScanjobDesc",
      50216: "OceApplicationSelector",
      50217: "OceIDNumber",
      50218: "OceImageLogic",
      50255: "Annotations",
      50341: "PrintIM",
      50560: "USPTOOriginalContentType",
      50706: "DNGVersion",
      50707: "DNGBackwardVersion",
      50708: "UniqueCameraModel",
      50709: "LocalizedCameraModel",
      50710: "CFAPlaneColor",
      50711: "CFALayout",
      50712: "LinearizationTable",
      50713: "BlackLevelRepeatDim",
      50714: "BlackLevel",
      50715: "BlackLevelDeltaH",
      50716: "BlackLevelDeltaV",
      50717: "WhiteLevel",
      50718: "DefaultScale",
      50719: "DefaultCropOrigin",
      50720: "DefaultCropSize",
      50721: "ColorMatrix1",
      50722: "ColorMatrix2",
      50723: "CameraCalibration1",
      50724: "CameraCalibration2",
      50725: "ReductionMatrix1",
      50726: "ReductionMatrix2",
      50727: "AnalogBalance",
      50728: "AsShotNeutral",
      50729: "AsShotWhiteXY",
      50730: "BaselineExposure",
      50731: "BaselineNoise",
      50732: "BaselineSharpness",
      50733: "BayerGreenSplit",
      50734: "LinearResponseLimit",
      50735: "CameraSerialNumber",
      50736: "DNGLensInfo",
      50737: "ChromaBlurRadius",
      50738: "AntiAliasStrength",
      50739: "ShadowScale",
      50740: "DNGPrivateData",
      50741: "MakerNoteSafety",
      50752: "RawImageSegmentation",
      50778: "CalibrationIlluminant1",
      50779: "CalibrationIlluminant2",
      50780: "BestQualityScale",
      50781: "RawDataUniqueID",
      50784: "AliasLayerMetadata",
      50827: "OriginalRawFileName",
      50828: "OriginalRawFileData",
      50829: "ActiveArea",
      50830: "MaskedAreas",
      50831: "AsShotICCProfile",
      50832: "AsShotPreProfileMatrix",
      50833: "CurrentICCProfile",
      50834: "CurrentPreProfileMatrix",
      50879: "ColorimetricReference",
      50898: "PanasonicTitle",
      50899: "PanasonicTitle2",
      50931: "CameraCalibrationSig",
      50932: "ProfileCalibrationSig",
      50933: "ProfileIFD",
      50934: "AsShotProfileName",
      50935: "NoiseReductionApplied",
      50936: "ProfileName",
      50937: "ProfileHueSatMapDims",
      50938: "ProfileHueSatMapData1",
      50939: "ProfileHueSatMapData2",
      50940: "ProfileToneCurve",
      50941: "ProfileEmbedPolicy",
      50942: "ProfileCopyright",
      50964: "ForwardMatrix1",
      50965: "ForwardMatrix2",
      50966: "PreviewApplicationName",
      50967: "PreviewApplicationVersion",
      50968: "PreviewSettingsName",
      50969: "PreviewSettingsDigest",
      50970: "PreviewColorSpace",
      50971: "PreviewDateTime",
      50972: "RawImageDigest",
      50973: "OriginalRawFileDigest",
      50974: "SubTileBlockSize",
      50975: "RowInterleaveFactor",
      50981: "ProfileLookTableDims",
      50982: "ProfileLookTableData",
      51008: "OpcodeList1",
      51009: "OpcodeList2",
      51022: "OpcodeList3",
      51041: "NoiseProfile",
      51043: "TimeCodes",
      51044: "FrameRate",
      51058: "TStop",
      51081: "ReelName",
      51089: "OriginalDefaultFinalSize",
      51090: "OriginalBestQualitySize",
      51091: "OriginalDefaultCropSize",
      51105: "CameraLabel",
      51107: "ProfileHueSatMapEncoding",
      51108: "ProfileLookTableEncoding",
      51109: "BaselineExposureOffset",
      51110: "DefaultBlackRender",
      51111: "NewRawImageDigest",
      51112: "RawToPreviewGain",
      51125: "DefaultUserCrop",
      59932: "Padding",
      59933: "OffsetSchema",
      65e3: "OwnerName",
      65001: "SerialNumber",
      65002: "Lens",
      65024: "KDC_IFD",
      65100: "RawFile",
      65101: "Converter",
      65102: "WhiteBalance",
      65105: "Exposure",
      65106: "Shadows",
      65107: "Brightness",
      65108: "Contrast",
      65109: "Saturation",
      65110: "Sharpness",
      65111: "Smoothness",
      65112: "MoireFilter"
    },
    gps: {
      0: "GPSVersionID",
      1: "GPSLatitudeRef",
      2: "GPSLatitude",
      3: "GPSLongitudeRef",
      4: "GPSLongitude",
      5: "GPSAltitudeRef",
      6: "GPSAltitude",
      7: "GPSTimeStamp",
      8: "GPSSatellites",
      9: "GPSStatus",
      10: "GPSMeasureMode",
      11: "GPSDOP",
      12: "GPSSpeedRef",
      13: "GPSSpeed",
      14: "GPSTrackRef",
      15: "GPSTrack",
      16: "GPSImgDirectionRef",
      17: "GPSImgDirection",
      18: "GPSMapDatum",
      19: "GPSDestLatitudeRef",
      20: "GPSDestLatitude",
      21: "GPSDestLongitudeRef",
      22: "GPSDestLongitude",
      23: "GPSDestBearingRef",
      24: "GPSDestBearing",
      25: "GPSDestDistanceRef",
      26: "GPSDestDistance",
      27: "GPSProcessingMethod",
      28: "GPSAreaInformation",
      29: "GPSDateStamp",
      30: "GPSDifferential",
      31: "GPSHPositioningError"
    }
  };
  return exifTags;
}
var jpeg = jpeg$1, exif = exif$2, simplify = simplify$1;
function ExifResult(startMarker, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset) {
  this.startMarker = startMarker;
  this.tags = tags;
  this.imageSize = imageSize;
  this.thumbnailOffset = thumbnailOffset;
  this.thumbnailLength = thumbnailLength;
  this.thumbnailType = thumbnailType;
  this.app1Offset = app1Offset;
}
ExifResult.prototype = {
  hasThumbnail: function(mime2) {
    if (!this.thumbnailOffset || !this.thumbnailLength) {
      return false;
    }
    if (typeof mime2 !== "string") {
      return true;
    }
    if (mime2.toLowerCase().trim() === "image/jpeg") {
      return this.thumbnailType === 6;
    }
    if (mime2.toLowerCase().trim() === "image/tiff") {
      return this.thumbnailType === 1;
    }
    return false;
  },
  getThumbnailOffset: function() {
    return this.app1Offset + 6 + this.thumbnailOffset;
  },
  getThumbnailLength: function() {
    return this.thumbnailLength;
  },
  getThumbnailBuffer: function() {
    return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
  },
  _getThumbnailStream: function() {
    return this.startMarker.openWithOffset(this.getThumbnailOffset());
  },
  getImageSize: function() {
    return this.imageSize;
  },
  getThumbnailSize: function() {
    var stream2 = this._getThumbnailStream(), size;
    jpeg.parseSections(stream2, function(sectionType, sectionStream) {
      if (jpeg.getSectionName(sectionType).name === "SOF") {
        size = jpeg.getSizeFromSOFSection(sectionStream);
      }
    });
    return size;
  }
};
function Parser$1(stream2) {
  this.stream = stream2;
  this.flags = {
    readBinaryTags: false,
    resolveTagNames: true,
    simplifyValues: true,
    imageSize: true,
    hidePointers: true,
    returnTags: true
  };
}
Parser$1.prototype = {
  enableBinaryFields: function(enable) {
    this.flags.readBinaryTags = !!enable;
    return this;
  },
  enablePointers: function(enable) {
    this.flags.hidePointers = !enable;
    return this;
  },
  enableTagNames: function(enable) {
    this.flags.resolveTagNames = !!enable;
    return this;
  },
  enableImageSize: function(enable) {
    this.flags.imageSize = !!enable;
    return this;
  },
  enableReturnTags: function(enable) {
    this.flags.returnTags = !!enable;
    return this;
  },
  enableSimpleValues: function(enable) {
    this.flags.simplifyValues = !!enable;
    return this;
  },
  parse: function() {
    var start = this.stream.mark(), stream2 = start.openWithOffset(0), flags = this.flags, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset, tagNames, getTagValue, setTagValue;
    if (flags.resolveTagNames) {
      tagNames = requireExifTags();
    }
    if (flags.resolveTagNames) {
      tags = {};
      getTagValue = function(t) {
        return tags[t.name];
      };
      setTagValue = function(t, value) {
        tags[t.name] = value;
      };
    } else {
      tags = [];
      getTagValue = function(t) {
        var i;
        for (i = 0; i < tags.length; ++i) {
          if (tags[i].type === t.type && tags[i].section === t.section) {
            return tags.value;
          }
        }
      };
      setTagValue = function(t, value) {
        var i;
        for (i = 0; i < tags.length; ++i) {
          if (tags[i].type === t.type && tags[i].section === t.section) {
            tags.value = value;
            return;
          }
        }
      };
    }
    jpeg.parseSections(stream2, function(sectionType, sectionStream) {
      var validExifHeaders, sectionOffset = sectionStream.offsetFrom(start);
      if (sectionType === 225) {
        validExifHeaders = exif.parseTags(sectionStream, function(ifdSection, tagType, value, format) {
          if (!flags.readBinaryTags && format === 7) {
            return;
          }
          if (tagType === 513) {
            thumbnailOffset = value[0];
            if (flags.hidePointers) {
              return;
            }
          } else if (tagType === 514) {
            thumbnailLength = value[0];
            if (flags.hidePointers) {
              return;
            }
          } else if (tagType === 259) {
            thumbnailType = value[0];
            if (flags.hidePointers) {
              return;
            }
          }
          if (!flags.returnTags) {
            return;
          }
          if (flags.simplifyValues) {
            value = simplify.simplifyValue(value, format);
          }
          if (flags.resolveTagNames) {
            var sectionTagNames = ifdSection === exif.GPSIFD ? tagNames.gps : tagNames.exif;
            var name = sectionTagNames[tagType];
            if (!name) {
              name = tagNames.exif[tagType];
            }
            if (!tags.hasOwnProperty(name)) {
              tags[name] = value;
            }
          } else {
            tags.push({
              section: ifdSection,
              type: tagType,
              value
            });
          }
        });
        if (validExifHeaders) {
          app1Offset = sectionOffset;
        }
      } else if (flags.imageSize && jpeg.getSectionName(sectionType).name === "SOF") {
        imageSize = jpeg.getSizeFromSOFSection(sectionStream);
      }
    });
    if (flags.simplifyValues) {
      simplify.castDegreeValues(getTagValue, setTagValue);
      simplify.castDateValues(getTagValue, setTagValue);
    }
    return new ExifResult(start, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset);
  }
};
var parser = Parser$1;
var domBufferstream;
var hasRequiredDomBufferstream;
function requireDomBufferstream() {
  if (hasRequiredDomBufferstream) return domBufferstream;
  hasRequiredDomBufferstream = 1;
  function DOMBufferStream(arrayBuffer, offset, length, bigEndian, global, parentOffset) {
    this.global = global;
    offset = offset || 0;
    length = length || arrayBuffer.byteLength - offset;
    this.arrayBuffer = arrayBuffer.slice(offset, offset + length);
    this.view = new global.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength);
    this.setBigEndian(bigEndian);
    this.offset = 0;
    this.parentOffset = (parentOffset || 0) + offset;
  }
  DOMBufferStream.prototype = {
    setBigEndian: function(bigEndian) {
      this.littleEndian = !bigEndian;
    },
    nextUInt8: function() {
      var value = this.view.getUint8(this.offset);
      this.offset += 1;
      return value;
    },
    nextInt8: function() {
      var value = this.view.getInt8(this.offset);
      this.offset += 1;
      return value;
    },
    nextUInt16: function() {
      var value = this.view.getUint16(this.offset, this.littleEndian);
      this.offset += 2;
      return value;
    },
    nextUInt32: function() {
      var value = this.view.getUint32(this.offset, this.littleEndian);
      this.offset += 4;
      return value;
    },
    nextInt16: function() {
      var value = this.view.getInt16(this.offset, this.littleEndian);
      this.offset += 2;
      return value;
    },
    nextInt32: function() {
      var value = this.view.getInt32(this.offset, this.littleEndian);
      this.offset += 4;
      return value;
    },
    nextFloat: function() {
      var value = this.view.getFloat32(this.offset, this.littleEndian);
      this.offset += 4;
      return value;
    },
    nextDouble: function() {
      var value = this.view.getFloat64(this.offset, this.littleEndian);
      this.offset += 8;
      return value;
    },
    nextBuffer: function(length) {
      var value = this.arrayBuffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return value;
    },
    remainingLength: function() {
      return this.arrayBuffer.byteLength - this.offset;
    },
    nextString: function(length) {
      var value = this.arrayBuffer.slice(this.offset, this.offset + length);
      value = String.fromCharCode.apply(null, new this.global.Uint8Array(value));
      this.offset += length;
      return value;
    },
    mark: function() {
      var self2 = this;
      return {
        openWithOffset: function(offset) {
          offset = (offset || 0) + this.offset;
          return new DOMBufferStream(self2.arrayBuffer, offset, self2.arrayBuffer.byteLength - offset, !self2.littleEndian, self2.global, self2.parentOffset);
        },
        offset: this.offset,
        getParentOffset: function() {
          return self2.parentOffset;
        }
      };
    },
    offsetFrom: function(marker) {
      return this.parentOffset + this.offset - (marker.offset + marker.getParentOffset());
    },
    skip: function(amount) {
      this.offset += amount;
    },
    branch: function(offset, length) {
      length = typeof length === "number" ? length : this.arrayBuffer.byteLength - (this.offset + offset);
      return new DOMBufferStream(this.arrayBuffer, this.offset + offset, length, !this.littleEndian, this.global, this.parentOffset);
    }
  };
  domBufferstream = DOMBufferStream;
  return domBufferstream;
}
var bufferstream;
var hasRequiredBufferstream;
function requireBufferstream() {
  if (hasRequiredBufferstream) return bufferstream;
  hasRequiredBufferstream = 1;
  function BufferStream(buffer, offset, length, bigEndian) {
    this.buffer = buffer;
    this.offset = offset || 0;
    length = typeof length === "number" ? length : buffer.length;
    this.endPosition = this.offset + length;
    this.setBigEndian(bigEndian);
  }
  BufferStream.prototype = {
    setBigEndian: function(bigEndian) {
      this.bigEndian = !!bigEndian;
    },
    nextUInt8: function() {
      var value = this.buffer.readUInt8(this.offset);
      this.offset += 1;
      return value;
    },
    nextInt8: function() {
      var value = this.buffer.readInt8(this.offset);
      this.offset += 1;
      return value;
    },
    nextUInt16: function() {
      var value = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
      this.offset += 2;
      return value;
    },
    nextUInt32: function() {
      var value = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
      this.offset += 4;
      return value;
    },
    nextInt16: function() {
      var value = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
      this.offset += 2;
      return value;
    },
    nextInt32: function() {
      var value = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
      this.offset += 4;
      return value;
    },
    nextFloat: function() {
      var value = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
      this.offset += 4;
      return value;
    },
    nextDouble: function() {
      var value = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
      this.offset += 8;
      return value;
    },
    nextBuffer: function(length) {
      var value = this.buffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return value;
    },
    remainingLength: function() {
      return this.endPosition - this.offset;
    },
    nextString: function(length) {
      var value = this.buffer.toString("utf8", this.offset, this.offset + length);
      this.offset += length;
      return value;
    },
    mark: function() {
      var self2 = this;
      return {
        openWithOffset: function(offset) {
          offset = (offset || 0) + this.offset;
          return new BufferStream(self2.buffer, offset, self2.endPosition - offset, self2.bigEndian);
        },
        offset: this.offset
      };
    },
    offsetFrom: function(marker) {
      return this.offset - marker.offset;
    },
    skip: function(amount) {
      this.offset += amount;
    },
    branch: function(offset, length) {
      length = typeof length === "number" ? length : this.endPosition - (this.offset + offset);
      return new BufferStream(this.buffer, this.offset + offset, length, this.bigEndian);
    }
  };
  bufferstream = BufferStream;
  return bufferstream;
}
var Parser = parser;
function getGlobal() {
  return (0, eval)("this");
}
var exifParser = {
  create: function(buffer, global) {
    global = global || getGlobal();
    if (buffer instanceof global.ArrayBuffer) {
      var DOMBufferStream = requireDomBufferstream();
      return new Parser(new DOMBufferStream(buffer, 0, buffer.byteLength, true, global));
    } else {
      var NodeBufferStream = requireBufferstream();
      return new Parser(new NodeBufferStream(buffer, 0, buffer.length, true));
    }
  }
};
const EXIFParser = /* @__PURE__ */ getDefaultExportFromCjs(exifParser);
function getExifOrientation(img) {
  const _exif = img._exif;
  return _exif && _exif.tags && _exif.tags.Orientation || 1;
}
function getExifOrientationTransformation(img) {
  const w = img.bitmap.width;
  const h = img.bitmap.height;
  switch (getExifOrientation(img)) {
    case 1:
      return null;
    case 2:
      return function(x2, y2) {
        return [w - x2 - 1, y2];
      };
    case 3:
      return function(x2, y2) {
        return [w - x2 - 1, h - y2 - 1];
      };
    case 4:
      return function(x2, y2) {
        return [x2, h - y2 - 1];
      };
    case 5:
      return function(x2, y2) {
        return [y2, x2];
      };
    case 6:
      return function(x2, y2) {
        return [y2, h - x2 - 1];
      };
    case 7:
      return function(x2, y2) {
        return [w - y2 - 1, h - x2 - 1];
      };
    case 8:
      return function(x2, y2) {
        return [w - y2 - 1, x2];
      };
    default:
      return null;
  }
}
function transformBitmap(img, width, height, transformation) {
  const _data = img.bitmap.data;
  const _width = img.bitmap.width;
  const data = Buffer.alloc(_data.length);
  for (let x2 = 0; x2 < width; x2++) {
    for (let y2 = 0; y2 < height; y2++) {
      const [_x, _y] = transformation(x2, y2);
      const idx = width * y2 + x2 << 2;
      const _idx = _width * _y + _x << 2;
      const pixel = _data.readUInt32BE(_idx);
      data.writeUInt32BE(pixel, idx);
    }
  }
  img.bitmap.data = data;
  img.bitmap.width = width;
  img.bitmap.height = height;
  img._exif.tags.Orientation = 1;
}
function exifRotate(img) {
  if (getExifOrientation(img) < 2) {
    return;
  }
  const transformation = getExifOrientationTransformation(img);
  const swapDimensions = getExifOrientation(img) > 4;
  const newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;
  const newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;
  if (transformation) {
    transformBitmap(img, newWidth, newHeight, transformation);
  }
}
async function attemptExifRotate(image, buffer) {
  try {
    image._exif = EXIFParser.create(buffer).parse();
    exifRotate(image);
  } catch {
  }
}
const emptyBitmap = {
  data: Buffer.alloc(0),
  width: 0,
  height: 0
};
function bufferFromArrayBuffer(arrayBuffer) {
  const buffer = Buffer.alloc(arrayBuffer.byteLength);
  const view = new Uint8Array(arrayBuffer);
  for (let i = 0; i < buffer.length; ++i) {
    buffer[i] = view[i];
  }
  return buffer;
}
function createJimp({ plugins: pluginsArg, formats: formatsArg } = {}) {
  const plugins = pluginsArg || [];
  const formats = (formatsArg || []).map((format) => format());
  const CustomJimp = class Jimp {
    constructor(options = emptyBitmap) {
      /**
       * The bitmap data of the image
       */
      __publicField2(this, "bitmap", emptyBitmap);
      /**  Default color to use for new pixels */
      __publicField2(this, "background", 0);
      /** Formats that can be used with Jimp */
      __publicField2(this, "formats", []);
      /** The original MIME type of the image */
      __publicField2(this, "mime");
      this.formats = formats;
      if ("data" in options) {
        this.bitmap = options;
      } else {
        this.bitmap = {
          data: Buffer.alloc(options.width * options.height * 4),
          width: options.width,
          height: options.height
        };
        if (options.color) {
          this.background = typeof options.color === "string" ? cssColorToHex(options.color) : options.color;
          for (let i = 0; i < this.bitmap.data.length; i += 4) {
            this.bitmap.data.writeUInt32BE(this.background, i);
          }
        }
      }
      for (const methods2 of plugins) {
        for (const key in methods2) {
          this[key] = (...args) => {
            var _a;
            const result = (_a = methods2[key]) == null ? void 0 : _a.call(methods2, this, ...args);
            if (typeof result === "object" && "bitmap" in result) {
              this.bitmap = result.bitmap;
              return this;
            }
            return result;
          };
        }
      }
    }
    /**
     * Create a Jimp instance from a URL, a file path, or a Buffer
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * // Read from a file path
     * const image = await Jimp.read("test/image.png");
     *
     * // Read from a URL
     * const image = await Jimp.read("https://upload.wikimedia.org/wikipedia/commons/0/01/Bot-Test.jpg");
     * ```
     */
    static async read(url, options) {
      if (Buffer.isBuffer(url) || url instanceof ArrayBuffer) {
        return this.fromBuffer(url);
      }
      if (existsSync(url)) {
        return this.fromBuffer(await readFile(url));
      }
      const [fetchErr, response] = await to(fetch(url));
      if (fetchErr) {
        throw new Error(`Could not load Buffer from URL: ${url}`);
      }
      if (!response.ok) {
        throw new Error(`HTTP Status ${response.status} for url ${url}`);
      }
      const [arrayBufferErr, data] = await to(response.arrayBuffer());
      if (arrayBufferErr) {
        throw new Error(`Could not load Buffer from ${url}`);
      }
      const buffer = bufferFromArrayBuffer(data);
      return this.fromBuffer(buffer, options);
    }
    /**
     * Create a Jimp instance from a bitmap.
     * The difference between this and just using the constructor is that this will
     * convert raw image data into the bitmap format that Jimp uses.
     *
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = Jimp.fromBitmap({
     *   data: Buffer.from([
     *     0xffffffff, 0xffffffff, 0xffffffff,
     *     0xffffffff, 0xffffffff, 0xffffffff,
     *     0xffffffff, 0xffffffff, 0xffffffff,
     *   ]),
     *   width: 3,
     *   height: 3,
     * });
     * ```
     */
    static fromBitmap(bitmap) {
      let data;
      if (bitmap.data instanceof Buffer) {
        data = Buffer.from(bitmap.data);
      }
      if (bitmap.data instanceof Uint8Array || bitmap.data instanceof Uint8ClampedArray) {
        data = Buffer.from(bitmap.data.buffer);
      }
      if (Array.isArray(bitmap.data)) {
        data = Buffer.concat(bitmap.data.map((hex) => Buffer.from(hex.toString(16).padStart(8, "0"), "hex")));
      }
      if (!data) {
        throw new Error("data must be a Buffer");
      }
      if (typeof bitmap.height !== "number" || typeof bitmap.width !== "number") {
        throw new Error("bitmap must have width and height");
      }
      return new CustomJimp({
        height: bitmap.height,
        width: bitmap.width,
        data
      });
    }
    /**
     * Parse a bitmap with the loaded image types.
     *
     * @param buffer Raw image data
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const buffer = await fs.readFile("test/image.png");
     * const image = await Jimp.fromBuffer(buffer);
     * ```
     */
    static async fromBuffer(buffer, options) {
      const actualBuffer = buffer instanceof ArrayBuffer ? bufferFromArrayBuffer(buffer) : buffer;
      const mime2 = await fileType$1.fromBuffer(actualBuffer);
      if (!mime2 || !mime2.mime) {
        throw new Error("Could not find MIME for Buffer");
      }
      const format = formats.find((format2) => format2.mime === mime2.mime);
      if (!format || !format.decode) {
        throw new Error(`Mime type ${mime2.mime} does not support decoding`);
      }
      const image = new CustomJimp(await format.decode(actualBuffer, options == null ? void 0 : options[format.mime]));
      image.mime = mime2.mime;
      attemptExifRotate(image, actualBuffer);
      return image;
    }
    /**
     * Nicely format Jimp object when sent to the console e.g. console.log(image)
     * @returns Pretty printed jimp object
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * console.log(image);
     * ```
     */
    inspect() {
      return "<Jimp " + (this.bitmap === emptyBitmap ? "pending..." : this.bitmap.width + "x" + this.bitmap.height) + ">";
    }
    /**
     * Nicely format Jimp object when converted to a string
     * @returns pretty printed
     */
    toString() {
      return "[object Jimp]";
    }
    /** Get the width of the image */
    get width() {
      return this.bitmap.width;
    }
    /** Get the height of the image */
    get height() {
      return this.bitmap.height;
    }
    /**
     * Converts the Jimp instance to an image buffer
     * @param mime The mime type to export to
     * @param options The options to use when exporting
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     * import { promises as fs } from "fs";
     *
     * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });
     *
     * await image.write("test/output.jpeg", {
     *   quality: 50,
     * });
     * ```
     */
    async getBuffer(mime2, options) {
      const format = this.formats.find((format2) => format2.mime === mime2);
      if (!format || !format.encode) {
        throw new Error(`Unsupported MIME type: ${mime2}`);
      }
      let outputImage;
      if (format.hasAlpha) {
        outputImage = this;
      } else {
        outputImage = new CustomJimp({
          width: this.bitmap.width,
          height: this.bitmap.height,
          color: this.background
        });
        composite(outputImage, this);
      }
      return format.encode(outputImage.bitmap, options);
    }
    /**
     * Converts the image to a base 64 string
     *
     * @param mime The mime type to export to
     * @param options The options to use when exporting
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = Jimp.fromBuffer(Buffer.from([
     *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
     *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
     *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
     * ]));
     *
     * const base64 = image.getBase64("image/jpeg", {
     *   quality: 50,
     * });
     * ```
     */
    async getBase64(mime2, options) {
      const data = await this.getBuffer(mime2, options);
      return "data:" + mime2 + ";base64," + data.toString("base64");
    }
    /**
     * Write the image to a file
     * @param path the path to write the image to
     * @param options the options to use when writing the image
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = Jimp.fromBuffer(Buffer.from([
     *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
     *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
     *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
     * ]));
     *
     * await image.write("test/output.png");
     * ```
     */
    async write(path2, options) {
      const mimeType = mime.getType(path2);
      await writeFile(path2, await this.getBuffer(mimeType, options));
    }
    /**
     * Clone the image into a new Jimp instance.
     * @param this
     * @returns A new Jimp instance
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });
     *
     * const clone = image.clone();
     * ```
     */
    clone() {
      return new CustomJimp({
        ...this.bitmap,
        data: Buffer.from(this.bitmap.data)
      });
    }
    /**
     * Returns the offset of a pixel in the bitmap buffer
     * @param x the x coordinate
     * @param y the y coordinate
     * @param edgeHandling (optional) define how to sum pixels from outside the border
     * @returns the index of the pixel or -1 if not found
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });
     *
     * image.getPixelIndex(1, 1); // 2
     * ```
     */
    getPixelIndex(x2, y2, edgeHandling) {
      let xi;
      let yi;
      if (!edgeHandling) {
        edgeHandling = Edge.EXTEND;
      }
      if (typeof x2 !== "number" || typeof y2 !== "number") {
        throw new Error("x and y must be numbers");
      }
      x2 = Math.round(x2);
      y2 = Math.round(y2);
      xi = x2;
      yi = y2;
      if (edgeHandling === Edge.EXTEND) {
        if (x2 < 0)
          xi = 0;
        if (x2 >= this.bitmap.width)
          xi = this.bitmap.width - 1;
        if (y2 < 0)
          yi = 0;
        if (y2 >= this.bitmap.height)
          yi = this.bitmap.height - 1;
      }
      if (edgeHandling === Edge.WRAP) {
        if (x2 < 0) {
          xi = this.bitmap.width + x2;
        }
        if (x2 >= this.bitmap.width) {
          xi = x2 % this.bitmap.width;
        }
        if (y2 < 0) {
          yi = this.bitmap.height + y2;
        }
        if (y2 >= this.bitmap.height) {
          yi = y2 % this.bitmap.height;
        }
      }
      let i = this.bitmap.width * yi + xi << 2;
      if (xi < 0 || xi >= this.bitmap.width) {
        i = -1;
      }
      if (yi < 0 || yi >= this.bitmap.height) {
        i = -1;
      }
      return i;
    }
    /**
     * Returns the hex color value of a pixel
     * @param x the x coordinate
     * @param y the y coordinate
     * @returns the color of the pixel
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });
     *
     * image.getPixelColor(1, 1); // 0xffffffff
     * ```
     */
    getPixelColor(x2, y2) {
      if (typeof x2 !== "number" || typeof y2 !== "number") {
        throw new Error("x and y must be numbers");
      }
      const idx = this.getPixelIndex(x2, y2);
      return this.bitmap.data.readUInt32BE(idx);
    }
    /**
     * Sets the hex colour value of a pixel
     *
     * @param hex color to set
     * @param x the x coordinate
     * @param y the y coordinate
     *
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });
     *
     * image.setPixelColor(0xff0000ff, 0, 0);
     * ```
     */
    setPixelColor(hex, x2, y2) {
      if (typeof hex !== "number" || typeof x2 !== "number" || typeof y2 !== "number") {
        throw new Error("hex, x and y must be numbers");
      }
      const idx = this.getPixelIndex(x2, y2);
      this.bitmap.data.writeUInt32BE(hex, idx);
      return this;
    }
    /**
     * Determine if the image contains opaque pixels.
     *
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = new Jimp({ width: 3, height: 3, color: 0xffffffaa });
     * const image2 = new Jimp({ width: 3, height: 3, color: 0xff0000ff });
     *
     * image.hasAlpha(); // false
     * image2.hasAlpha(); // true
     * ```
     */
    hasAlpha() {
      const { width, height, data } = this.bitmap;
      const byteLen = width * height << 2;
      for (let idx = 3; idx < byteLen; idx += 4) {
        if (data[idx] !== 255) {
          return true;
        }
      }
      return false;
    }
    /**
     * Composites a source image over to this image respecting alpha channels
     * @param src the source Jimp instance
     * @param x the x position to blit the image
     * @param y the y position to blit the image
     * @param options determine what mode to use
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = new Jimp({ width: 10, height: 10, color: 0xffffffff });
     * const image2 = new Jimp({ width: 3, height: 3, color: 0xff0000ff });
     *
     * image.composite(image2, 3, 3);
     * ```
     */
    composite(src2, x2 = 0, y2 = 0, options = {}) {
      return composite(this, src2, x2, y2, options);
    }
    scan(x2, y2, w, h, f) {
      return scan(this, x2, y2, w, h, f);
    }
    /**
     * Iterate scan through a region of the bitmap
     * @param x the x coordinate to begin the scan at
     * @param y the y coordinate to begin the scan at
     * @param w the width of the scan region
     * @param h the height of the scan region
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });
     *
     * for (const { x, y, idx, image } of j.scanIterator()) {
     *   // do something with the pixel
     * }
     * ```
     */
    scanIterator(x2 = 0, y2 = 0, w = this.bitmap.width, h = this.bitmap.height) {
      if (typeof x2 !== "number" || typeof y2 !== "number") {
        throw new Error("x and y must be numbers");
      }
      if (typeof w !== "number" || typeof h !== "number") {
        throw new Error("w and h must be numbers");
      }
      return scanIterator(this, x2, y2, w, h);
    }
  };
  return CustomJimp;
}
var ResizeStrategy;
(function(ResizeStrategy2) {
  ResizeStrategy2["NEAREST_NEIGHBOR"] = "nearestNeighbor";
  ResizeStrategy2["BILINEAR"] = "bilinearInterpolation";
  ResizeStrategy2["BICUBIC"] = "bicubicInterpolation";
  ResizeStrategy2["HERMITE"] = "hermiteInterpolation";
  ResizeStrategy2["BEZIER"] = "bezierInterpolation";
})(ResizeStrategy || (ResizeStrategy = {}));
var util$b;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$b || (util$b = {}));
var objectUtil$b;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$b || (objectUtil$b = {}));
const ZodParsedType$b = util$b.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$b = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$b.undefined;
    case "string":
      return ZodParsedType$b.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType$b.nan : ZodParsedType$b.number;
    case "boolean":
      return ZodParsedType$b.boolean;
    case "function":
      return ZodParsedType$b.function;
    case "bigint":
      return ZodParsedType$b.bigint;
    case "symbol":
      return ZodParsedType$b.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$b.array;
      }
      if (data === null) {
        return ZodParsedType$b.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$b.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$b.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$b.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$b.date;
      }
      return ZodParsedType$b.object;
    default:
      return ZodParsedType$b.unknown;
  }
};
const ZodIssueCode$b = util$b.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
let ZodError$b = class ZodError6 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue2 of error.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError6)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$b.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$b.create = (issues) => {
  const error = new ZodError$b(issues);
  return error;
};
const errorMap$b = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode$b.invalid_type:
      if (issue2.received === ZodParsedType$b.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode$b.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util$b.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$b.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$b.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode$b.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$b.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$b.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode$b.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$b.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode$b.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$b.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$b.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$b.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util$b.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$b.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$b.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$b.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$b.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$b.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode$b.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$b.assertNever(issue2);
  }
  return { message };
};
let overrideErrorMap$b = errorMap$b;
function getErrorMap$b() {
  return overrideErrorMap$b;
}
const makeIssue$b = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext$b(ctx, issueData) {
  const overrideMap = getErrorMap$b();
  const issue2 = makeIssue$b({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$b ? void 0 : errorMap$b
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue2);
}
let ParseStatus$b = class ParseStatus6 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$b;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus6.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$b;
      if (value.status === "aborted")
        return INVALID$b;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$b = Object.freeze({
  status: "aborted"
});
const DIRTY$b = (value) => ({ status: "dirty", value });
const OK$b = (value) => ({ status: "valid", value });
const isAborted$b = (x2) => x2.status === "aborted";
const isDirty$b = (x2) => x2.status === "dirty";
const isValid$b = (x2) => x2.status === "valid";
const isAsync$b = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil$b;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil$b || (errorUtil$b = {}));
let ParseInputLazyPath$b = class ParseInputLazyPath6 {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$b = (ctx, result) => {
  if (isValid$b(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$b(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$b(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$b = class ZodType6 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$b(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$b(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$b(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$b(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$b(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: (params == null ? void 0 : params.async) ?? false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$b(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$b(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$b(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$b(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$b(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$b(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$b(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$b(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$b.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$b({
      schema: this,
      typeName: ZodFirstPartyTypeKind$b.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$b.create(this, this._def);
  }
  nullable() {
    return ZodNullable$b.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$b.create(this);
  }
  promise() {
    return ZodPromise$b.create(this, this._def);
  }
  or(option) {
    return ZodUnion$b.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$b.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects$b({
      ...processCreateParams$b(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$b.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault$b({
      ...processCreateParams$b(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$b.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$b({
      typeName: ZodFirstPartyTypeKind$b.ZodBranded,
      type: this,
      ...processCreateParams$b(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch$b({
      ...processCreateParams$b(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$b.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$b.create(this, target);
  }
  readonly() {
    return ZodReadonly$b.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$b = /^c[^\s-]{8,}$/i;
const cuid2Regex$b = /^[0-9a-z]+$/;
const ulidRegex$b = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$b = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$b = /^[a-z0-9_-]{21}$/i;
const jwtRegex$b = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$b = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$b = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$b = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$b;
const ipv4Regex$b = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$b = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$b = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$b = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$b = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$b = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$b = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$b = new RegExp(`^${dateRegexSource$b}$`);
function timeRegexSource$b(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex$b(args) {
  return new RegExp(`^${timeRegexSource$b(args)}$`);
}
function datetimeRegex$b(args) {
  let regex = `${dateRegexSource$b}T${timeRegexSource$b(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$b(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex$b.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex$b.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$b(jwt, alg) {
  if (!jwtRegex$b.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr$b(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex$b.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex$b.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$b = class ZodString6 extends ZodType$b {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$b.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$b(ctx2, {
        code: ZodIssueCode$b.invalid_type,
        expected: ZodParsedType$b.string,
        received: ctx2.parsedType
      });
      return INVALID$b;
    }
    const status = new ParseStatus$b();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            code: ZodIssueCode$b.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            code: ZodIssueCode$b.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$b(ctx, {
              code: ZodIssueCode$b.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$b(ctx, {
              code: ZodIssueCode$b.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$b.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            validation: "email",
            code: ZodIssueCode$b.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$b) {
          emojiRegex$b = new RegExp(_emojiRegex$b, "u");
        }
        if (!emojiRegex$b.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            validation: "emoji",
            code: ZodIssueCode$b.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$b.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            validation: "uuid",
            code: ZodIssueCode$b.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$b.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$b.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$b.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            validation: "cuid",
            code: ZodIssueCode$b.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$b.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$b.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$b.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            validation: "ulid",
            code: ZodIssueCode$b.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            validation: "url",
            code: ZodIssueCode$b.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            validation: "regex",
            code: ZodIssueCode$b.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            code: ZodIssueCode$b.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            code: ZodIssueCode$b.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            code: ZodIssueCode$b.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$b(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            code: ZodIssueCode$b.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$b;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            code: ZodIssueCode$b.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$b(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            code: ZodIssueCode$b.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$b.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            validation: "duration",
            code: ZodIssueCode$b.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$b(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            validation: "ip",
            code: ZodIssueCode$b.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$b(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            validation: "jwt",
            code: ZodIssueCode$b.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$b(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            validation: "cidr",
            code: ZodIssueCode$b.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$b.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            validation: "base64",
            code: ZodIssueCode$b.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$b.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            validation: "base64url",
            code: ZodIssueCode$b.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$b.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$b.invalid_string,
      ...errorUtil$b.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString6({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$b.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$b.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$b.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$b.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$b.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$b.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$b.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$b.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$b.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$b.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$b.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$b.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$b.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (options == null ? void 0 : options.offset) ?? false,
      local: (options == null ? void 0 : options.local) ?? false,
      ...errorUtil$b.errToObj(options == null ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      ...errorUtil$b.errToObj(options == null ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$b.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$b.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position,
      ...errorUtil$b.errToObj(options == null ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$b.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$b.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$b.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$b.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$b.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$b.errToObj(message));
  }
  trim() {
    return new ZodString6({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString6({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString6({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$b.create = (params) => {
  return new ZodString$b({
    checks: [],
    typeName: ZodFirstPartyTypeKind$b.ZodString,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$b(params)
  });
};
function floatSafeRemainder$b(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
let ZodNumber$b = class ZodNumber6 extends ZodType$b {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$b.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$b(ctx2, {
        code: ZodIssueCode$b.invalid_type,
        expected: ZodParsedType$b.number,
        received: ctx2.parsedType
      });
      return INVALID$b;
    }
    let ctx = void 0;
    const status = new ParseStatus$b();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$b.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            code: ZodIssueCode$b.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            code: ZodIssueCode$b.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            code: ZodIssueCode$b.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$b(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            code: ZodIssueCode$b.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            code: ZodIssueCode$b.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$b.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$b.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$b.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$b.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$b.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber6({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$b.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber6({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$b.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$b.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$b.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$b.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$b.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$b.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$b.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$b.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$b.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$b.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$b.create = (params) => {
  return new ZodNumber$b({
    checks: [],
    typeName: ZodFirstPartyTypeKind$b.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$b(params)
  });
};
let ZodBigInt$b = class ZodBigInt6 extends ZodType$b {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$b.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$b();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            code: ZodIssueCode$b.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            code: ZodIssueCode$b.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            code: ZodIssueCode$b.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$b.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$b(ctx, {
      code: ZodIssueCode$b.invalid_type,
      expected: ZodParsedType$b.bigint,
      received: ctx.parsedType
    });
    return INVALID$b;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$b.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$b.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$b.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$b.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt6({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$b.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt6({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$b.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$b.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$b.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$b.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$b.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$b.create = (params) => {
  return new ZodBigInt$b({
    checks: [],
    typeName: ZodFirstPartyTypeKind$b.ZodBigInt,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$b(params)
  });
};
let ZodBoolean$b = class ZodBoolean6 extends ZodType$b {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$b.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$b(ctx, {
        code: ZodIssueCode$b.invalid_type,
        expected: ZodParsedType$b.boolean,
        received: ctx.parsedType
      });
      return INVALID$b;
    }
    return OK$b(input.data);
  }
};
ZodBoolean$b.create = (params) => {
  return new ZodBoolean$b({
    typeName: ZodFirstPartyTypeKind$b.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$b(params)
  });
};
let ZodDate$b = class ZodDate6 extends ZodType$b {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$b.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$b(ctx2, {
        code: ZodIssueCode$b.invalid_type,
        expected: ZodParsedType$b.date,
        received: ctx2.parsedType
      });
      return INVALID$b;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$b(ctx2, {
        code: ZodIssueCode$b.invalid_date
      });
      return INVALID$b;
    }
    const status = new ParseStatus$b();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            code: ZodIssueCode$b.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$b(ctx, {
            code: ZodIssueCode$b.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$b.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate6({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$b.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$b.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$b.create = (params) => {
  return new ZodDate$b({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$b.ZodDate,
    ...processCreateParams$b(params)
  });
};
let ZodSymbol$b = class ZodSymbol6 extends ZodType$b {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$b.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$b(ctx, {
        code: ZodIssueCode$b.invalid_type,
        expected: ZodParsedType$b.symbol,
        received: ctx.parsedType
      });
      return INVALID$b;
    }
    return OK$b(input.data);
  }
};
ZodSymbol$b.create = (params) => {
  return new ZodSymbol$b({
    typeName: ZodFirstPartyTypeKind$b.ZodSymbol,
    ...processCreateParams$b(params)
  });
};
let ZodUndefined$b = class ZodUndefined6 extends ZodType$b {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$b.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$b(ctx, {
        code: ZodIssueCode$b.invalid_type,
        expected: ZodParsedType$b.undefined,
        received: ctx.parsedType
      });
      return INVALID$b;
    }
    return OK$b(input.data);
  }
};
ZodUndefined$b.create = (params) => {
  return new ZodUndefined$b({
    typeName: ZodFirstPartyTypeKind$b.ZodUndefined,
    ...processCreateParams$b(params)
  });
};
let ZodNull$b = class ZodNull6 extends ZodType$b {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$b.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$b(ctx, {
        code: ZodIssueCode$b.invalid_type,
        expected: ZodParsedType$b.null,
        received: ctx.parsedType
      });
      return INVALID$b;
    }
    return OK$b(input.data);
  }
};
ZodNull$b.create = (params) => {
  return new ZodNull$b({
    typeName: ZodFirstPartyTypeKind$b.ZodNull,
    ...processCreateParams$b(params)
  });
};
let ZodAny$b = class ZodAny6 extends ZodType$b {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$b(input.data);
  }
};
ZodAny$b.create = (params) => {
  return new ZodAny$b({
    typeName: ZodFirstPartyTypeKind$b.ZodAny,
    ...processCreateParams$b(params)
  });
};
let ZodUnknown$b = class ZodUnknown6 extends ZodType$b {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$b(input.data);
  }
};
ZodUnknown$b.create = (params) => {
  return new ZodUnknown$b({
    typeName: ZodFirstPartyTypeKind$b.ZodUnknown,
    ...processCreateParams$b(params)
  });
};
let ZodNever$b = class ZodNever6 extends ZodType$b {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$b(ctx, {
      code: ZodIssueCode$b.invalid_type,
      expected: ZodParsedType$b.never,
      received: ctx.parsedType
    });
    return INVALID$b;
  }
};
ZodNever$b.create = (params) => {
  return new ZodNever$b({
    typeName: ZodFirstPartyTypeKind$b.ZodNever,
    ...processCreateParams$b(params)
  });
};
let ZodVoid$b = class ZodVoid6 extends ZodType$b {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$b.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$b(ctx, {
        code: ZodIssueCode$b.invalid_type,
        expected: ZodParsedType$b.void,
        received: ctx.parsedType
      });
      return INVALID$b;
    }
    return OK$b(input.data);
  }
};
ZodVoid$b.create = (params) => {
  return new ZodVoid$b({
    typeName: ZodFirstPartyTypeKind$b.ZodVoid,
    ...processCreateParams$b(params)
  });
};
let ZodArray$b = class ZodArray6 extends ZodType$b {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType$b.array) {
      addIssueToContext$b(ctx, {
        code: ZodIssueCode$b.invalid_type,
        expected: ZodParsedType$b.array,
        received: ctx.parsedType
      });
      return INVALID$b;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$b(ctx, {
          code: tooBig ? ZodIssueCode$b.too_big : ZodIssueCode$b.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext$b(ctx, {
          code: ZodIssueCode$b.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext$b(ctx, {
          code: ZodIssueCode$b.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath$b(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$b.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath$b(ctx, item, ctx.path, i));
    });
    return ParseStatus$b.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray6({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$b.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray6({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$b.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray6({
      ...this._def,
      exactLength: { value: len, message: errorUtil$b.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$b.create = (schema, params) => {
  return new ZodArray$b({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$b.ZodArray,
    ...processCreateParams$b(params)
  });
};
function deepPartialify$b(schema) {
  if (schema instanceof ZodObject$b) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$b.create(deepPartialify$b(fieldSchema));
    }
    return new ZodObject$b({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$b) {
    return new ZodArray$b({
      ...schema._def,
      type: deepPartialify$b(schema.element)
    });
  } else if (schema instanceof ZodOptional$b) {
    return ZodOptional$b.create(deepPartialify$b(schema.unwrap()));
  } else if (schema instanceof ZodNullable$b) {
    return ZodNullable$b.create(deepPartialify$b(schema.unwrap()));
  } else if (schema instanceof ZodTuple$b) {
    return ZodTuple$b.create(schema.items.map((item) => deepPartialify$b(item)));
  } else {
    return schema;
  }
}
let ZodObject$b = class ZodObject6 extends ZodType$b {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$b.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$b.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$b(ctx2, {
        code: ZodIssueCode$b.invalid_type,
        expected: ZodParsedType$b.object,
        received: ctx2.parsedType
      });
      return INVALID$b;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$b && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$b(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$b) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$b(ctx, {
            code: ZodIssueCode$b.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$b(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$b.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$b.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$b.errToObj;
    return new ZodObject6({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          var _a, _b;
          const defaultError = ((_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue2, ctx).message) ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil$b.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject6({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject6({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject6({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject6({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$b.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject6({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util$b.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject6({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util$b.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject6({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$b(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util$b.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject6({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util$b.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$b) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject6({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$b(util$b.objectKeys(this.shape));
  }
};
ZodObject$b.create = (shape, params) => {
  return new ZodObject$b({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$b.create(),
    typeName: ZodFirstPartyTypeKind$b.ZodObject,
    ...processCreateParams$b(params)
  });
};
ZodObject$b.strictCreate = (shape, params) => {
  return new ZodObject$b({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$b.create(),
    typeName: ZodFirstPartyTypeKind$b.ZodObject,
    ...processCreateParams$b(params)
  });
};
ZodObject$b.lazycreate = (shape, params) => {
  return new ZodObject$b({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$b.create(),
    typeName: ZodFirstPartyTypeKind$b.ZodObject,
    ...processCreateParams$b(params)
  });
};
let ZodUnion$b = class ZodUnion6 extends ZodType$b {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$b(result.ctx.common.issues));
      addIssueToContext$b(ctx, {
        code: ZodIssueCode$b.invalid_union,
        unionErrors
      });
      return INVALID$b;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$b(issues2));
      addIssueToContext$b(ctx, {
        code: ZodIssueCode$b.invalid_union,
        unionErrors
      });
      return INVALID$b;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$b.create = (types, params) => {
  return new ZodUnion$b({
    options: types,
    typeName: ZodFirstPartyTypeKind$b.ZodUnion,
    ...processCreateParams$b(params)
  });
};
function mergeValues$b(a, b) {
  const aType = getParsedType$b(a);
  const bType = getParsedType$b(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$b.object && bType === ZodParsedType$b.object) {
    const bKeys = util$b.objectKeys(b);
    const sharedKeys = util$b.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$b(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$b.array && bType === ZodParsedType$b.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$b(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$b.date && bType === ZodParsedType$b.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$b = class ZodIntersection6 extends ZodType$b {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$b(parsedLeft) || isAborted$b(parsedRight)) {
        return INVALID$b;
      }
      const merged = mergeValues$b(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$b(ctx, {
          code: ZodIssueCode$b.invalid_intersection_types
        });
        return INVALID$b;
      }
      if (isDirty$b(parsedLeft) || isDirty$b(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$b.create = (left, right, params) => {
  return new ZodIntersection$b({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$b.ZodIntersection,
    ...processCreateParams$b(params)
  });
};
let ZodTuple$b = class ZodTuple6 extends ZodType$b {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$b.array) {
      addIssueToContext$b(ctx, {
        code: ZodIssueCode$b.invalid_type,
        expected: ZodParsedType$b.array,
        received: ctx.parsedType
      });
      return INVALID$b;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$b(ctx, {
        code: ZodIssueCode$b.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$b;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$b(ctx, {
        code: ZodIssueCode$b.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$b(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$b.mergeArray(status, results);
      });
    } else {
      return ParseStatus$b.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple6({
      ...this._def,
      rest
    });
  }
};
ZodTuple$b.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$b({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$b.ZodTuple,
    rest: null,
    ...processCreateParams$b(params)
  });
};
let ZodMap$b = class ZodMap6 extends ZodType$b {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$b.map) {
      addIssueToContext$b(ctx, {
        code: ZodIssueCode$b.invalid_type,
        expected: ZodParsedType$b.map,
        received: ctx.parsedType
      });
      return INVALID$b;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$b(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$b(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$b;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$b;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$b.create = (keyType, valueType, params) => {
  return new ZodMap$b({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$b.ZodMap,
    ...processCreateParams$b(params)
  });
};
let ZodSet$b = class ZodSet6 extends ZodType$b {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$b.set) {
      addIssueToContext$b(ctx, {
        code: ZodIssueCode$b.invalid_type,
        expected: ZodParsedType$b.set,
        received: ctx.parsedType
      });
      return INVALID$b;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext$b(ctx, {
          code: ZodIssueCode$b.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext$b(ctx, {
          code: ZodIssueCode$b.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID$b;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$b(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet6({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$b.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet6({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$b.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$b.create = (valueType, params) => {
  return new ZodSet$b({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$b.ZodSet,
    ...processCreateParams$b(params)
  });
};
let ZodLazy$b = class ZodLazy6 extends ZodType$b {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$b.create = (getter, params) => {
  return new ZodLazy$b({
    getter,
    typeName: ZodFirstPartyTypeKind$b.ZodLazy,
    ...processCreateParams$b(params)
  });
};
let ZodLiteral$b = class ZodLiteral6 extends ZodType$b {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$b(ctx, {
        received: ctx.data,
        code: ZodIssueCode$b.invalid_literal,
        expected: this._def.value
      });
      return INVALID$b;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$b.create = (value, params) => {
  return new ZodLiteral$b({
    value,
    typeName: ZodFirstPartyTypeKind$b.ZodLiteral,
    ...processCreateParams$b(params)
  });
};
function createZodEnum$b(values, params) {
  return new ZodEnum$b({
    values,
    typeName: ZodFirstPartyTypeKind$b.ZodEnum,
    ...processCreateParams$b(params)
  });
}
let ZodEnum$b = class ZodEnum6 extends ZodType$b {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$b(ctx, {
        expected: util$b.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$b.invalid_type
      });
      return INVALID$b;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$b(ctx, {
        received: ctx.data,
        code: ZodIssueCode$b.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$b;
    }
    return OK$b(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum6.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum6.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum$b.create = createZodEnum$b;
let ZodNativeEnum$b = class ZodNativeEnum6 extends ZodType$b {
  _parse(input) {
    const nativeEnumValues = util$b.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$b.string && ctx.parsedType !== ZodParsedType$b.number) {
      const expectedValues = util$b.objectValues(nativeEnumValues);
      addIssueToContext$b(ctx, {
        expected: util$b.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$b.invalid_type
      });
      return INVALID$b;
    }
    if (!this._cache) {
      this._cache = new Set(util$b.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util$b.objectValues(nativeEnumValues);
      addIssueToContext$b(ctx, {
        received: ctx.data,
        code: ZodIssueCode$b.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$b;
    }
    return OK$b(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum$b.create = (values, params) => {
  return new ZodNativeEnum$b({
    values,
    typeName: ZodFirstPartyTypeKind$b.ZodNativeEnum,
    ...processCreateParams$b(params)
  });
};
let ZodPromise$b = class ZodPromise6 extends ZodType$b {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$b.promise && ctx.common.async === false) {
      addIssueToContext$b(ctx, {
        code: ZodIssueCode$b.invalid_type,
        expected: ZodParsedType$b.promise,
        received: ctx.parsedType
      });
      return INVALID$b;
    }
    const promisified = ctx.parsedType === ZodParsedType$b.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$b(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$b.create = (schema, params) => {
  return new ZodPromise$b({
    type: schema,
    typeName: ZodFirstPartyTypeKind$b.ZodPromise,
    ...processCreateParams$b(params)
  });
};
let ZodEffects$b = class ZodEffects6 extends ZodType$b {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$b.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$b(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$b;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$b;
          if (result.status === "dirty")
            return DIRTY$b(result.value);
          if (status.value === "dirty")
            return DIRTY$b(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$b;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$b;
        if (result.status === "dirty")
          return DIRTY$b(result.value);
        if (status.value === "dirty")
          return DIRTY$b(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$b;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$b;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$b(base))
          return INVALID$b;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$b(base))
            return INVALID$b;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util$b.assertNever(effect);
  }
};
ZodEffects$b.create = (schema, effect, params) => {
  return new ZodEffects$b({
    schema,
    typeName: ZodFirstPartyTypeKind$b.ZodEffects,
    effect,
    ...processCreateParams$b(params)
  });
};
ZodEffects$b.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$b({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$b.ZodEffects,
    ...processCreateParams$b(params)
  });
};
let ZodOptional$b = class ZodOptional6 extends ZodType$b {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$b.undefined) {
      return OK$b(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$b.create = (type, params) => {
  return new ZodOptional$b({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$b.ZodOptional,
    ...processCreateParams$b(params)
  });
};
let ZodNullable$b = class ZodNullable6 extends ZodType$b {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$b.null) {
      return OK$b(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$b.create = (type, params) => {
  return new ZodNullable$b({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$b.ZodNullable,
    ...processCreateParams$b(params)
  });
};
let ZodDefault$b = class ZodDefault6 extends ZodType$b {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$b.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$b.create = (type, params) => {
  return new ZodDefault$b({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$b.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$b(params)
  });
};
let ZodCatch$b = class ZodCatch6 extends ZodType$b {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$b(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$b(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$b(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$b.create = (type, params) => {
  return new ZodCatch$b({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$b.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$b(params)
  });
};
let ZodNaN$b = class ZodNaN6 extends ZodType$b {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$b.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$b(ctx, {
        code: ZodIssueCode$b.invalid_type,
        expected: ZodParsedType$b.nan,
        received: ctx.parsedType
      });
      return INVALID$b;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$b.create = (params) => {
  return new ZodNaN$b({
    typeName: ZodFirstPartyTypeKind$b.ZodNaN,
    ...processCreateParams$b(params)
  });
};
let ZodBranded$b = class ZodBranded6 extends ZodType$b {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$b = class ZodPipeline6 extends ZodType$b {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$b;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$b(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$b;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline6({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$b.ZodPipeline
    });
  }
};
let ZodReadonly$b = class ZodReadonly6 extends ZodType$b {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$b(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$b(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$b.create = (type, params) => {
  return new ZodReadonly$b({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$b.ZodReadonly,
    ...processCreateParams$b(params)
  });
};
var ZodFirstPartyTypeKind$b;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$b || (ZodFirstPartyTypeKind$b = {}));
const numberType$a = ZodNumber$b.create;
ZodNever$b.create;
ZodArray$b.create;
const objectType$b = ZodObject$b.create;
const unionType$4 = ZodUnion$b.create;
ZodIntersection$b.create;
ZodTuple$b.create;
ZodEnum$b.create;
const nativeEnumType$5 = ZodNativeEnum$b.create;
ZodPromise$b.create;
ZodOptional$b.create;
ZodNullable$b.create;
function Resize(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback) {
  this.widthOriginal = Math.abs(Math.floor(widthOriginal) || 0);
  this.heightOriginal = Math.abs(Math.floor(heightOriginal) || 0);
  this.targetWidth = Math.abs(Math.floor(targetWidth) || 0);
  this.targetHeight = Math.abs(Math.floor(targetHeight) || 0);
  this.colorChannels = blendAlpha ? 4 : 3;
  this.interpolationPass = Boolean(interpolationPass);
  this.resizeCallback = typeof resizeCallback === "function" ? resizeCallback : function() {
  };
  this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;
  this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels;
  this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels;
  this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal;
  this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight;
  this.initialize();
}
Resize.prototype.initialize = function() {
  if (this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0) {
    this.configurePasses();
  } else {
    console.log(this);
    throw new Error("Invalid settings specified for the resizer.");
  }
};
Resize.prototype.configurePasses = function() {
  if (this.widthOriginal === this.targetWidth) {
    this.resizeWidth = this.bypassResizer;
  } else {
    this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth;
    if (this.ratioWeightWidthPass < 1 && this.interpolationPass) {
      this.initializeFirstPassBuffers(true);
      this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB;
    } else {
      this.initializeFirstPassBuffers(false);
      this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB;
    }
  }
  if (this.heightOriginal === this.targetHeight) {
    this.resizeHeight = this.bypassResizer;
  } else {
    this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight;
    if (this.ratioWeightHeightPass < 1 && this.interpolationPass) {
      this.initializeSecondPassBuffers(true);
      this.resizeHeight = this.resizeHeightInterpolated;
    } else {
      this.initializeSecondPassBuffers(false);
      this.resizeHeight = this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB;
    }
  }
};
Resize.prototype._resizeWidthInterpolatedRGBChannels = function(buffer, fourthChannel) {
  const channelsNum = fourthChannel ? 4 : 3;
  const ratioWeight = this.ratioWeightWidthPass;
  const outputBuffer = this.widthBuffer;
  let weight = 0;
  let finalOffset = 0;
  let pixelOffset = 0;
  let firstWeight = 0;
  let secondWeight = 0;
  let targetPosition;
  for (targetPosition = 0; weight < 1 / 3; targetPosition += channelsNum, weight += ratioWeight) {
    for (finalOffset = targetPosition, pixelOffset = 0; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
      outputBuffer[finalOffset] = buffer[pixelOffset];
      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
      if (fourthChannel)
        outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
    }
  }
  weight -= 1 / 3;
  let interpolationWidthSourceReadStop;
  for (interpolationWidthSourceReadStop = this.widthOriginal - 1; weight < interpolationWidthSourceReadStop; targetPosition += channelsNum, weight += ratioWeight) {
    secondWeight = weight % 1;
    firstWeight = 1 - secondWeight;
    for (finalOffset = targetPosition, pixelOffset = Math.floor(weight) * channelsNum; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
      outputBuffer[finalOffset + 0] = buffer[pixelOffset + 0] * firstWeight + buffer[pixelOffset + channelsNum + 0] * secondWeight;
      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1] * firstWeight + buffer[pixelOffset + channelsNum + 1] * secondWeight;
      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2] * firstWeight + buffer[pixelOffset + channelsNum + 2] * secondWeight;
      if (fourthChannel)
        outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3] * firstWeight + buffer[pixelOffset + channelsNum + 3] * secondWeight;
    }
  }
  for (interpolationWidthSourceReadStop = this.originalWidthMultipliedByChannels - channelsNum; targetPosition < this.targetWidthMultipliedByChannels; targetPosition += channelsNum) {
    for (finalOffset = targetPosition, pixelOffset = interpolationWidthSourceReadStop; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
      outputBuffer[finalOffset] = buffer[pixelOffset];
      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
      if (fourthChannel)
        outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
    }
  }
  return outputBuffer;
};
Resize.prototype._resizeWidthRGBChannels = function(buffer, fourthChannel) {
  const channelsNum = fourthChannel ? 4 : 3;
  const ratioWeight = this.ratioWeightWidthPass;
  const ratioWeightDivisor = 1 / ratioWeight;
  const nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - channelsNum + 1;
  const nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - channelsNum + 1;
  const output = this.outputWidthWorkBench;
  const outputBuffer = this.widthBuffer;
  const trustworthyColorsCount = this.outputWidthWorkBenchOpaquePixelsCount;
  let weight = 0;
  let amountToNext = 0;
  let actualPosition = 0;
  let currentPosition = 0;
  let line = 0;
  let pixelOffset = 0;
  let outputOffset = 0;
  let multiplier = 1;
  let r = 0;
  let g = 0;
  let b = 0;
  let a = 0;
  do {
    for (line = 0; line < this.originalHeightMultipliedByChannels; ) {
      output[line++] = 0;
      output[line++] = 0;
      output[line++] = 0;
      if (fourthChannel) {
        output[line++] = 0;
        trustworthyColorsCount[line / channelsNum - 1] = 0;
      }
    }
    weight = ratioWeight;
    do {
      amountToNext = 1 + actualPosition - currentPosition;
      multiplier = Math.min(weight, amountToNext);
      for (line = 0, pixelOffset = actualPosition; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {
        r = buffer[pixelOffset];
        g = buffer[++pixelOffset];
        b = buffer[++pixelOffset];
        a = fourthChannel ? buffer[++pixelOffset] : 255;
        output[line++] += (a ? r : 0) * multiplier;
        output[line++] += (a ? g : 0) * multiplier;
        output[line++] += (a ? b : 0) * multiplier;
        if (fourthChannel) {
          output[line++] += a * multiplier;
          trustworthyColorsCount[line / channelsNum - 1] += a ? multiplier : 0;
        }
      }
      if (weight >= amountToNext) {
        actualPosition += channelsNum;
        currentPosition = actualPosition;
        weight -= amountToNext;
      } else {
        currentPosition += weight;
        break;
      }
    } while (weight > 0 && actualPosition < this.originalWidthMultipliedByChannels);
    for (line = 0, pixelOffset = outputOffset; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) {
      weight = fourthChannel ? trustworthyColorsCount[line / channelsNum] : 1;
      multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;
      outputBuffer[pixelOffset] = output[line++] * multiplier;
      outputBuffer[++pixelOffset] = output[line++] * multiplier;
      outputBuffer[++pixelOffset] = output[line++] * multiplier;
      if (fourthChannel)
        outputBuffer[++pixelOffset] = output[line++] * ratioWeightDivisor;
    }
    outputOffset += channelsNum;
  } while (outputOffset < this.targetWidthMultipliedByChannels);
  return outputBuffer;
};
Resize.prototype._resizeHeightRGBChannels = function(buffer, fourthChannel) {
  const ratioWeight = this.ratioWeightHeightPass;
  const ratioWeightDivisor = 1 / ratioWeight;
  const output = this.outputHeightWorkBench;
  const outputBuffer = this.heightBuffer;
  const trustworthyColorsCount = this.outputHeightWorkBenchOpaquePixelsCount;
  let weight = 0;
  let amountToNext = 0;
  let actualPosition = 0;
  let currentPosition = 0;
  let pixelOffset = 0;
  let outputOffset = 0;
  let caret = 0;
  let multiplier = 1;
  let r = 0;
  let g = 0;
  let b = 0;
  let a = 0;
  do {
    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
      output[pixelOffset++] = 0;
      output[pixelOffset++] = 0;
      output[pixelOffset++] = 0;
      if (fourthChannel) {
        output[pixelOffset++] = 0;
        trustworthyColorsCount[pixelOffset / 4 - 1] = 0;
      }
    }
    weight = ratioWeight;
    do {
      amountToNext = 1 + actualPosition - currentPosition;
      multiplier = Math.min(weight, amountToNext);
      caret = actualPosition;
      for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
        r = buffer[caret++];
        g = buffer[caret++];
        b = buffer[caret++];
        a = fourthChannel ? buffer[caret++] : 255;
        output[pixelOffset++] += (a ? r : 0) * multiplier;
        output[pixelOffset++] += (a ? g : 0) * multiplier;
        output[pixelOffset++] += (a ? b : 0) * multiplier;
        if (fourthChannel) {
          output[pixelOffset++] += a * multiplier;
          trustworthyColorsCount[pixelOffset / 4 - 1] += a ? multiplier : 0;
        }
      }
      if (weight >= amountToNext) {
        actualPosition = caret;
        currentPosition = actualPosition;
        weight -= amountToNext;
      } else {
        currentPosition += weight;
        break;
      }
    } while (weight > 0 && actualPosition < this.widthPassResultSize);
    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
      weight = fourthChannel ? trustworthyColorsCount[pixelOffset / 4] : 1;
      multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;
      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
      if (fourthChannel) {
        outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);
      }
    }
  } while (outputOffset < this.finalResultSize);
  return outputBuffer;
};
Resize.prototype.resizeWidthInterpolatedRGB = function(buffer) {
  return this._resizeWidthInterpolatedRGBChannels(buffer, false);
};
Resize.prototype.resizeWidthInterpolatedRGBA = function(buffer) {
  return this._resizeWidthInterpolatedRGBChannels(buffer, true);
};
Resize.prototype.resizeWidthRGB = function(buffer) {
  return this._resizeWidthRGBChannels(buffer, false);
};
Resize.prototype.resizeWidthRGBA = function(buffer) {
  return this._resizeWidthRGBChannels(buffer, true);
};
Resize.prototype.resizeHeightInterpolated = function(buffer) {
  const ratioWeight = this.ratioWeightHeightPass;
  const outputBuffer = this.heightBuffer;
  let weight = 0;
  let finalOffset = 0;
  let pixelOffset = 0;
  let pixelOffsetAccumulated = 0;
  let pixelOffsetAccumulated2 = 0;
  let firstWeight = 0;
  let secondWeight = 0;
  let interpolationHeightSourceReadStop;
  for (; weight < 1 / 3; weight += ratioWeight) {
    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);
    }
  }
  weight -= 1 / 3;
  for (interpolationHeightSourceReadStop = this.heightOriginal - 1; weight < interpolationHeightSourceReadStop; weight += ratioWeight) {
    secondWeight = weight % 1;
    firstWeight = 1 - secondWeight;
    pixelOffsetAccumulated = Math.floor(weight) * this.targetWidthMultipliedByChannels;
    pixelOffsetAccumulated2 = pixelOffsetAccumulated + this.targetWidthMultipliedByChannels;
    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++] * firstWeight + buffer[pixelOffsetAccumulated2++] * secondWeight);
    }
  }
  while (finalOffset < this.finalResultSize) {
    for (pixelOffset = 0, pixelOffsetAccumulated = interpolationHeightSourceReadStop * this.targetWidthMultipliedByChannels; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++]);
    }
  }
  return outputBuffer;
};
Resize.prototype.resizeHeightRGB = function(buffer) {
  return this._resizeHeightRGBChannels(buffer, false);
};
Resize.prototype.resizeHeightRGBA = function(buffer) {
  return this._resizeHeightRGBChannels(buffer, true);
};
Resize.prototype.resize = function(buffer) {
  this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));
};
Resize.prototype.bypassResizer = function(buffer) {
  return buffer;
};
Resize.prototype.initializeFirstPassBuffers = function(BILINEARAlgo) {
  this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize);
  if (!BILINEARAlgo) {
    this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels);
    if (this.colorChannels > 3) {
      this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal);
    }
  }
};
Resize.prototype.initializeSecondPassBuffers = function(BILINEARAlgo) {
  this.heightBuffer = this.generateUint8Buffer(this.finalResultSize);
  if (!BILINEARAlgo) {
    this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels);
    if (this.colorChannels > 3) {
      this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth);
    }
  }
};
Resize.prototype.generateFloatBuffer = function(bufferLength) {
  try {
    return new Float32Array(bufferLength);
  } catch (error) {
    console.error(error);
    return [];
  }
};
Resize.prototype.generateFloat64Buffer = function(bufferLength) {
  try {
    return new Float64Array(bufferLength);
  } catch (error) {
    console.error(error);
    return [];
  }
};
Resize.prototype.generateUint8Buffer = function(bufferLength) {
  try {
    return new Uint8Array(bufferLength);
  } catch (error) {
    console.error(error);
    return [];
  }
};
const operations = {
  nearestNeighbor(src2, dst) {
    const wSrc = src2.width;
    const hSrc = src2.height;
    const wDst = dst.width;
    const hDst = dst.height;
    const bufSrc = src2.data;
    const bufDst = dst.data;
    for (let i = 0; i < hDst; i++) {
      for (let j = 0; j < wDst; j++) {
        let posDst = (i * wDst + j) * 4;
        const iSrc = Math.floor(i * hSrc / hDst);
        const jSrc = Math.floor(j * wSrc / wDst);
        let posSrc = (iSrc * wSrc + jSrc) * 4;
        bufDst[posDst++] = bufSrc[posSrc++];
        bufDst[posDst++] = bufSrc[posSrc++];
        bufDst[posDst++] = bufSrc[posSrc++];
        bufDst[posDst++] = bufSrc[posSrc++];
      }
    }
  },
  bilinearInterpolation(src2, dst) {
    const wSrc = src2.width;
    const hSrc = src2.height;
    const wDst = dst.width;
    const hDst = dst.height;
    const bufSrc = src2.data;
    const bufDst = dst.data;
    const interpolate = function(k, kMin, vMin, kMax, vMax) {
      if (kMin === kMax) {
        return vMin;
      }
      return Math.round((k - kMin) * vMax + (kMax - k) * vMin);
    };
    const assign = function(pos, offset, x2, xMin, xMax, y2, yMin, yMax) {
      let posMin = (yMin * wSrc + xMin) * 4 + offset;
      let posMax = (yMin * wSrc + xMax) * 4 + offset;
      const vMin = interpolate(x2, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);
      if (yMax === yMin) {
        bufDst[pos + offset] = vMin;
      } else {
        posMin = (yMax * wSrc + xMin) * 4 + offset;
        posMax = (yMax * wSrc + xMax) * 4 + offset;
        const vMax = interpolate(x2, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);
        bufDst[pos + offset] = interpolate(y2, yMin, vMin, yMax, vMax);
      }
    };
    for (let i = 0; i < hDst; i++) {
      for (let j = 0; j < wDst; j++) {
        const posDst = (i * wDst + j) * 4;
        const x2 = j * wSrc / wDst;
        const xMin = Math.floor(x2);
        const xMax = Math.min(Math.ceil(x2), wSrc - 1);
        const y2 = i * hSrc / hDst;
        const yMin = Math.floor(y2);
        const yMax = Math.min(Math.ceil(y2), hSrc - 1);
        assign(posDst, 0, x2, xMin, xMax, y2, yMin, yMax);
        assign(posDst, 1, x2, xMin, xMax, y2, yMin, yMax);
        assign(posDst, 2, x2, xMin, xMax, y2, yMin, yMax);
        assign(posDst, 3, x2, xMin, xMax, y2, yMin, yMax);
      }
    }
  },
  _interpolate2D(src2, dst, options, interpolate) {
    const bufSrc = src2.data;
    const bufDst = dst.data;
    const wSrc = src2.width;
    const hSrc = src2.height;
    const wDst = dst.width;
    const hDst = dst.height;
    const wM = Math.max(1, Math.floor(wSrc / wDst));
    const wDst2 = wDst * wM;
    const hM = Math.max(1, Math.floor(hSrc / hDst));
    const hDst2 = hDst * hM;
    const buf1 = Buffer.alloc(wDst2 * hSrc * 4);
    for (let i = 0; i < hSrc; i++) {
      for (let j = 0; j < wDst2; j++) {
        const x2 = j * (wSrc - 1) / wDst2;
        const xPos = Math.floor(x2);
        const t = x2 - xPos;
        const srcPos = (i * wSrc + xPos) * 4;
        const buf1Pos = (i * wDst2 + j) * 4;
        for (let k = 0; k < 4; k++) {
          const kPos = srcPos + k;
          const x0 = xPos > 0 ? bufSrc[kPos - 4] : 2 * bufSrc[kPos] - bufSrc[kPos + 4];
          const x1 = bufSrc[kPos];
          const x22 = bufSrc[kPos + 4];
          const x3 = xPos < wSrc - 2 ? bufSrc[kPos + 8] : 2 * bufSrc[kPos + 4] - bufSrc[kPos];
          buf1[buf1Pos + k] = interpolate(x0, x1, x22, x3, t);
        }
      }
    }
    const buf2 = Buffer.alloc(wDst2 * hDst2 * 4);
    for (let i = 0; i < hDst2; i++) {
      for (let j = 0; j < wDst2; j++) {
        const y2 = i * (hSrc - 1) / hDst2;
        const yPos = Math.floor(y2);
        const t = y2 - yPos;
        const buf1Pos = (yPos * wDst2 + j) * 4;
        const buf2Pos = (i * wDst2 + j) * 4;
        for (let k = 0; k < 4; k++) {
          const kPos = buf1Pos + k;
          const y0 = yPos > 0 ? buf1[kPos - wDst2 * 4] : 2 * buf1[kPos] - buf1[kPos + wDst2 * 4];
          const y1 = buf1[kPos];
          const y22 = buf1[kPos + wDst2 * 4];
          const y3 = yPos < hSrc - 2 ? buf1[kPos + wDst2 * 8] : 2 * buf1[kPos + wDst2 * 4] - buf1[kPos];
          buf2[buf2Pos + k] = interpolate(y0, y1, y22, y3, t);
        }
      }
    }
    const m = wM * hM;
    if (m > 1) {
      for (let i = 0; i < hDst; i++) {
        for (let j = 0; j < wDst; j++) {
          let r = 0;
          let g = 0;
          let b = 0;
          let a = 0;
          let realColors = 0;
          for (let y2 = 0; y2 < hM; y2++) {
            const yPos = i * hM + y2;
            for (let x2 = 0; x2 < wM; x2++) {
              const xPos = j * wM + x2;
              const xyPos = (yPos * wDst2 + xPos) * 4;
              const pixelAlpha = buf2[xyPos + 3];
              if (pixelAlpha) {
                r += buf2[xyPos];
                g += buf2[xyPos + 1];
                b += buf2[xyPos + 2];
                realColors++;
              }
              a += pixelAlpha;
            }
          }
          const pos = (i * wDst + j) * 4;
          bufDst[pos] = realColors ? Math.round(r / realColors) : 0;
          bufDst[pos + 1] = realColors ? Math.round(g / realColors) : 0;
          bufDst[pos + 2] = realColors ? Math.round(b / realColors) : 0;
          bufDst[pos + 3] = Math.round(a / m);
        }
      }
    } else {
      dst.data = buf2;
    }
  },
  bicubicInterpolation(src2, dst, options) {
    const interpolateCubic = function(x0, x1, x2, x3, t) {
      const a0 = x3 - x2 - x0 + x1;
      const a1 = x0 - x1 - a0;
      const a2 = x2 - x0;
      const a3 = x1;
      return Math.max(0, Math.min(255, a0 * (t * t * t) + a1 * (t * t) + a2 * t + a3));
    };
    return this._interpolate2D(src2, dst, options, interpolateCubic);
  },
  hermiteInterpolation(src2, dst, options) {
    const interpolateHermite = function(x0, x1, x2, x3, t) {
      const c0 = x1;
      const c1 = 0.5 * (x2 - x0);
      const c2 = x0 - 2.5 * x1 + 2 * x2 - 0.5 * x3;
      const c3 = 0.5 * (x3 - x0) + 1.5 * (x1 - x2);
      return Math.max(0, Math.min(255, Math.round(((c3 * t + c2) * t + c1) * t + c0)));
    };
    return this._interpolate2D(src2, dst, options, interpolateHermite);
  },
  bezierInterpolation(src2, dst, options) {
    const interpolateBezier = function(x0, x1, x2, x3, t) {
      const cp1 = x1 + (x2 - x0) / 4;
      const cp2 = x2 - (x3 - x1) / 4;
      const nt = 1 - t;
      const c0 = x1 * nt * nt * nt;
      const c1 = 3 * cp1 * nt * nt * t;
      const c2 = 3 * cp2 * nt * t * t;
      const c3 = x2 * t * t * t;
      return Math.max(0, Math.min(255, Math.round(c0 + c1 + c2 + c3)));
    };
    return this._interpolate2D(src2, dst, options, interpolateBezier);
  }
};
const ResizeOptionsSchema = unionType$4([
  objectType$b({
    /** the width to resize the image to */
    w: numberType$a().min(0),
    /** the height to resize the image to */
    h: numberType$a().min(0).optional(),
    /** a scaling method (e.g. ResizeStrategy.BEZIER) */
    mode: nativeEnumType$5(ResizeStrategy).optional()
  }),
  objectType$b({
    /** the width to resize the image to */
    w: numberType$a().min(0).optional(),
    /** the height to resize the image to */
    h: numberType$a().min(0),
    /** a scaling method (e.g. ResizeStrategy.BEZIER) */
    mode: nativeEnumType$5(ResizeStrategy).optional()
  })
]);
const ScaleToFitOptionsSchema = objectType$b({
  /** the width to resize the image to */
  w: numberType$a().min(0),
  /** the height to resize the image to */
  h: numberType$a().min(0),
  /** a scaling method (e.g. Jimp.RESIZE_BEZIER) */
  mode: nativeEnumType$5(ResizeStrategy).optional()
});
const ScaleComplexOptionsSchema = objectType$b({
  /** the width to resize the image to */
  f: numberType$a().min(0),
  /** a scaling method (e.g. Jimp.RESIZE_BEZIER) */
  mode: nativeEnumType$5(ResizeStrategy).optional()
});
const methods$d = {
  /**
   * Resizes the image to a set width and height using a 2-pass bilinear algorithm
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.resize({ w: 150 });
   * ```
   */
  resize(image, options) {
    const { mode } = ResizeOptionsSchema.parse(options);
    let w;
    let h;
    if (typeof options.w === "number") {
      w = options.w;
      h = options.h ?? image.bitmap.height * (w / image.bitmap.width);
    } else if (typeof options.h === "number") {
      h = options.h;
      w = options.w ?? image.bitmap.width * (h / image.bitmap.height);
    } else {
      throw new Error("w must be a number");
    }
    w = Math.round(w) || 1;
    h = Math.round(h) || 1;
    if (mode && typeof operations[mode] === "function") {
      const dst = {
        data: Buffer.alloc(w * h * 4),
        width: w,
        height: h
      };
      operations[mode](image.bitmap, dst);
      image.bitmap = dst;
    } else {
      const resize = new Resize(image.bitmap.width, image.bitmap.height, w, h, true, true, (buffer) => {
        image.bitmap.data = Buffer.from(buffer);
        image.bitmap.width = w;
        image.bitmap.height = h;
      });
      resize.resize(image.bitmap.data);
    }
    return image;
  },
  /**
   * Uniformly scales the image by a factor.
   * @param f the factor to scale the image by
   * @param mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.scale(0.5);
   * ```
   */
  scale(image, options) {
    const { f, mode } = typeof options === "number" ? { f: options } : ScaleComplexOptionsSchema.parse(options);
    const w = image.bitmap.width * f;
    const h = image.bitmap.height * f;
    return this.resize(image, { w, h, mode });
  },
  /**
   * Scale the image to the largest size that fits inside the rectangle that has the given width and height.
   * @param w the width to resize the image to
   * @param h the height to resize the image to
   * @param mode a scaling method (e.g. ResizeStrategy.BEZIER)
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.scaleToFit(100, 100);
   * ```
   */
  scaleToFit(image, options) {
    const { h, w, mode } = ScaleToFitOptionsSchema.parse(options);
    const f = w / h > image.bitmap.width / image.bitmap.height ? h / image.bitmap.height : w / image.bitmap.width;
    return this.scale(image, { f, mode });
  }
};
var util$a;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$a || (util$a = {}));
var objectUtil$a;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$a || (objectUtil$a = {}));
const ZodParsedType$a = util$a.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$a = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$a.undefined;
    case "string":
      return ZodParsedType$a.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType$a.nan : ZodParsedType$a.number;
    case "boolean":
      return ZodParsedType$a.boolean;
    case "function":
      return ZodParsedType$a.function;
    case "bigint":
      return ZodParsedType$a.bigint;
    case "symbol":
      return ZodParsedType$a.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$a.array;
      }
      if (data === null) {
        return ZodParsedType$a.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$a.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$a.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$a.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$a.date;
      }
      return ZodParsedType$a.object;
    default:
      return ZodParsedType$a.unknown;
  }
};
const ZodIssueCode$a = util$a.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
let ZodError$a = class ZodError7 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue2 of error.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError7)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$a.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$a.create = (issues) => {
  const error = new ZodError$a(issues);
  return error;
};
const errorMap$a = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode$a.invalid_type:
      if (issue2.received === ZodParsedType$a.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode$a.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util$a.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$a.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$a.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode$a.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$a.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$a.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode$a.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$a.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode$a.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$a.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$a.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$a.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util$a.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$a.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$a.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$a.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$a.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$a.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode$a.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$a.assertNever(issue2);
  }
  return { message };
};
let overrideErrorMap$a = errorMap$a;
function getErrorMap$a() {
  return overrideErrorMap$a;
}
const makeIssue$a = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext$a(ctx, issueData) {
  const overrideMap = getErrorMap$a();
  const issue2 = makeIssue$a({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$a ? void 0 : errorMap$a
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue2);
}
let ParseStatus$a = class ParseStatus7 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$a;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus7.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$a;
      if (value.status === "aborted")
        return INVALID$a;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$a = Object.freeze({
  status: "aborted"
});
const DIRTY$a = (value) => ({ status: "dirty", value });
const OK$a = (value) => ({ status: "valid", value });
const isAborted$a = (x2) => x2.status === "aborted";
const isDirty$a = (x2) => x2.status === "dirty";
const isValid$a = (x2) => x2.status === "valid";
const isAsync$a = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil$a;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil$a || (errorUtil$a = {}));
let ParseInputLazyPath$a = class ParseInputLazyPath7 {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$a = (ctx, result) => {
  if (isValid$a(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$a(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$a(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$a = class ZodType7 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$a(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$a(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$a(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$a(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$a(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: (params == null ? void 0 : params.async) ?? false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$a(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$a(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$a(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$a(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$a(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$a(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$a(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$a(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$a.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$a({
      schema: this,
      typeName: ZodFirstPartyTypeKind$a.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$a.create(this, this._def);
  }
  nullable() {
    return ZodNullable$a.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$a.create(this);
  }
  promise() {
    return ZodPromise$a.create(this, this._def);
  }
  or(option) {
    return ZodUnion$a.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$a.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects$a({
      ...processCreateParams$a(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$a.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault$a({
      ...processCreateParams$a(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$a.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$a({
      typeName: ZodFirstPartyTypeKind$a.ZodBranded,
      type: this,
      ...processCreateParams$a(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch$a({
      ...processCreateParams$a(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$a.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$a.create(this, target);
  }
  readonly() {
    return ZodReadonly$a.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$a = /^c[^\s-]{8,}$/i;
const cuid2Regex$a = /^[0-9a-z]+$/;
const ulidRegex$a = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$a = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$a = /^[a-z0-9_-]{21}$/i;
const jwtRegex$a = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$a = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$a = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$a = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$a;
const ipv4Regex$a = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$a = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$a = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$a = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$a = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$a = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$a = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$a = new RegExp(`^${dateRegexSource$a}$`);
function timeRegexSource$a(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex$a(args) {
  return new RegExp(`^${timeRegexSource$a(args)}$`);
}
function datetimeRegex$a(args) {
  let regex = `${dateRegexSource$a}T${timeRegexSource$a(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$a(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex$a.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex$a.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$a(jwt, alg) {
  if (!jwtRegex$a.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr$a(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex$a.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex$a.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$a = class ZodString7 extends ZodType$a {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx2, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.string,
        received: ctx2.parsedType
      });
      return INVALID$a;
    }
    const status = new ParseStatus$a();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$a(ctx, {
              code: ZodIssueCode$a.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$a(ctx, {
              code: ZodIssueCode$a.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "email",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$a) {
          emojiRegex$a = new RegExp(_emojiRegex$a, "u");
        }
        if (!emojiRegex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "emoji",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "uuid",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "cuid",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "ulid",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "url",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "regex",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$a(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$a;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$a(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "duration",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$a(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "ip",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$a(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "jwt",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$a(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "cidr",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "base64",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "base64url",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$a.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$a.invalid_string,
      ...errorUtil$a.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString7({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$a.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$a.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$a.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$a.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$a.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$a.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$a.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$a.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$a.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$a.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$a.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$a.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$a.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (options == null ? void 0 : options.offset) ?? false,
      local: (options == null ? void 0 : options.local) ?? false,
      ...errorUtil$a.errToObj(options == null ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      ...errorUtil$a.errToObj(options == null ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$a.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$a.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position,
      ...errorUtil$a.errToObj(options == null ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$a.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$a.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$a.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$a.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$a.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$a.errToObj(message));
  }
  trim() {
    return new ZodString7({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString7({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString7({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$a.create = (params) => {
  return new ZodString$a({
    checks: [],
    typeName: ZodFirstPartyTypeKind$a.ZodString,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$a(params)
  });
};
function floatSafeRemainder$a(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
let ZodNumber$a = class ZodNumber7 extends ZodType$a {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx2, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.number,
        received: ctx2.parsedType
      });
      return INVALID$a;
    }
    let ctx = void 0;
    const status = new ParseStatus$a();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$a.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$a(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$a.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$a.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$a.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$a.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$a.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber7({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$a.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber7({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$a.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$a.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$a.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$a.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$a.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$a.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$a.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$a.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$a.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$a.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$a.create = (params) => {
  return new ZodNumber$a({
    checks: [],
    typeName: ZodFirstPartyTypeKind$a.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$a(params)
  });
};
let ZodBigInt$a = class ZodBigInt7 extends ZodType$a {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$a();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$a.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$a(ctx, {
      code: ZodIssueCode$a.invalid_type,
      expected: ZodParsedType$a.bigint,
      received: ctx.parsedType
    });
    return INVALID$a;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$a.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$a.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$a.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$a.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt7({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$a.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt7({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$a.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$a.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$a.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$a.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$a.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$a.create = (params) => {
  return new ZodBigInt$a({
    checks: [],
    typeName: ZodFirstPartyTypeKind$a.ZodBigInt,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$a(params)
  });
};
let ZodBoolean$a = class ZodBoolean7 extends ZodType$a {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.boolean,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    return OK$a(input.data);
  }
};
ZodBoolean$a.create = (params) => {
  return new ZodBoolean$a({
    typeName: ZodFirstPartyTypeKind$a.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$a(params)
  });
};
let ZodDate$a = class ZodDate7 extends ZodType$a {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx2, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.date,
        received: ctx2.parsedType
      });
      return INVALID$a;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx2, {
        code: ZodIssueCode$a.invalid_date
      });
      return INVALID$a;
    }
    const status = new ParseStatus$a();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$a.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate7({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$a.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$a.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$a.create = (params) => {
  return new ZodDate$a({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$a.ZodDate,
    ...processCreateParams$a(params)
  });
};
let ZodSymbol$a = class ZodSymbol7 extends ZodType$a {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.symbol,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    return OK$a(input.data);
  }
};
ZodSymbol$a.create = (params) => {
  return new ZodSymbol$a({
    typeName: ZodFirstPartyTypeKind$a.ZodSymbol,
    ...processCreateParams$a(params)
  });
};
let ZodUndefined$a = class ZodUndefined7 extends ZodType$a {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.undefined,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    return OK$a(input.data);
  }
};
ZodUndefined$a.create = (params) => {
  return new ZodUndefined$a({
    typeName: ZodFirstPartyTypeKind$a.ZodUndefined,
    ...processCreateParams$a(params)
  });
};
let ZodNull$a = class ZodNull7 extends ZodType$a {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.null,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    return OK$a(input.data);
  }
};
ZodNull$a.create = (params) => {
  return new ZodNull$a({
    typeName: ZodFirstPartyTypeKind$a.ZodNull,
    ...processCreateParams$a(params)
  });
};
let ZodAny$a = class ZodAny7 extends ZodType$a {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$a(input.data);
  }
};
ZodAny$a.create = (params) => {
  return new ZodAny$a({
    typeName: ZodFirstPartyTypeKind$a.ZodAny,
    ...processCreateParams$a(params)
  });
};
let ZodUnknown$a = class ZodUnknown7 extends ZodType$a {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$a(input.data);
  }
};
ZodUnknown$a.create = (params) => {
  return new ZodUnknown$a({
    typeName: ZodFirstPartyTypeKind$a.ZodUnknown,
    ...processCreateParams$a(params)
  });
};
let ZodNever$a = class ZodNever7 extends ZodType$a {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$a(ctx, {
      code: ZodIssueCode$a.invalid_type,
      expected: ZodParsedType$a.never,
      received: ctx.parsedType
    });
    return INVALID$a;
  }
};
ZodNever$a.create = (params) => {
  return new ZodNever$a({
    typeName: ZodFirstPartyTypeKind$a.ZodNever,
    ...processCreateParams$a(params)
  });
};
let ZodVoid$a = class ZodVoid7 extends ZodType$a {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.void,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    return OK$a(input.data);
  }
};
ZodVoid$a.create = (params) => {
  return new ZodVoid$a({
    typeName: ZodFirstPartyTypeKind$a.ZodVoid,
    ...processCreateParams$a(params)
  });
};
let ZodArray$a = class ZodArray7 extends ZodType$a {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType$a.array) {
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.array,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$a(ctx, {
          code: tooBig ? ZodIssueCode$a.too_big : ZodIssueCode$a.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext$a(ctx, {
          code: ZodIssueCode$a.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext$a(ctx, {
          code: ZodIssueCode$a.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath$a(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$a.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath$a(ctx, item, ctx.path, i));
    });
    return ParseStatus$a.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray7({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$a.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray7({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$a.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray7({
      ...this._def,
      exactLength: { value: len, message: errorUtil$a.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$a.create = (schema, params) => {
  return new ZodArray$a({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$a.ZodArray,
    ...processCreateParams$a(params)
  });
};
function deepPartialify$a(schema) {
  if (schema instanceof ZodObject$a) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$a.create(deepPartialify$a(fieldSchema));
    }
    return new ZodObject$a({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$a) {
    return new ZodArray$a({
      ...schema._def,
      type: deepPartialify$a(schema.element)
    });
  } else if (schema instanceof ZodOptional$a) {
    return ZodOptional$a.create(deepPartialify$a(schema.unwrap()));
  } else if (schema instanceof ZodNullable$a) {
    return ZodNullable$a.create(deepPartialify$a(schema.unwrap()));
  } else if (schema instanceof ZodTuple$a) {
    return ZodTuple$a.create(schema.items.map((item) => deepPartialify$a(item)));
  } else {
    return schema;
  }
}
let ZodObject$a = class ZodObject7 extends ZodType$a {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$a.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx2, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.object,
        received: ctx2.parsedType
      });
      return INVALID$a;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$a && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$a(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$a) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$a(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$a.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$a.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$a.errToObj;
    return new ZodObject7({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          var _a, _b;
          const defaultError = ((_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue2, ctx).message) ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil$a.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject7({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject7({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject7({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject7({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$a.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject7({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util$a.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject7({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util$a.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject7({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$a(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util$a.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject7({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util$a.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$a) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject7({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$a(util$a.objectKeys(this.shape));
  }
};
ZodObject$a.create = (shape, params) => {
  return new ZodObject$a({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$a.create(),
    typeName: ZodFirstPartyTypeKind$a.ZodObject,
    ...processCreateParams$a(params)
  });
};
ZodObject$a.strictCreate = (shape, params) => {
  return new ZodObject$a({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$a.create(),
    typeName: ZodFirstPartyTypeKind$a.ZodObject,
    ...processCreateParams$a(params)
  });
};
ZodObject$a.lazycreate = (shape, params) => {
  return new ZodObject$a({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$a.create(),
    typeName: ZodFirstPartyTypeKind$a.ZodObject,
    ...processCreateParams$a(params)
  });
};
let ZodUnion$a = class ZodUnion7 extends ZodType$a {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$a(result.ctx.common.issues));
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_union,
        unionErrors
      });
      return INVALID$a;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$a(issues2));
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_union,
        unionErrors
      });
      return INVALID$a;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$a.create = (types, params) => {
  return new ZodUnion$a({
    options: types,
    typeName: ZodFirstPartyTypeKind$a.ZodUnion,
    ...processCreateParams$a(params)
  });
};
function mergeValues$a(a, b) {
  const aType = getParsedType$a(a);
  const bType = getParsedType$a(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$a.object && bType === ZodParsedType$a.object) {
    const bKeys = util$a.objectKeys(b);
    const sharedKeys = util$a.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$a(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$a.array && bType === ZodParsedType$a.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$a(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$a.date && bType === ZodParsedType$a.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$a = class ZodIntersection7 extends ZodType$a {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$a(parsedLeft) || isAborted$a(parsedRight)) {
        return INVALID$a;
      }
      const merged = mergeValues$a(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$a(ctx, {
          code: ZodIssueCode$a.invalid_intersection_types
        });
        return INVALID$a;
      }
      if (isDirty$a(parsedLeft) || isDirty$a(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$a.create = (left, right, params) => {
  return new ZodIntersection$a({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$a.ZodIntersection,
    ...processCreateParams$a(params)
  });
};
let ZodTuple$a = class ZodTuple7 extends ZodType$a {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$a.array) {
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.array,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$a;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$a(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$a.mergeArray(status, results);
      });
    } else {
      return ParseStatus$a.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple7({
      ...this._def,
      rest
    });
  }
};
ZodTuple$a.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$a({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$a.ZodTuple,
    rest: null,
    ...processCreateParams$a(params)
  });
};
let ZodMap$a = class ZodMap7 extends ZodType$a {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$a.map) {
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.map,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$a(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$a(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$a;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$a;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$a.create = (keyType, valueType, params) => {
  return new ZodMap$a({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$a.ZodMap,
    ...processCreateParams$a(params)
  });
};
let ZodSet$a = class ZodSet7 extends ZodType$a {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$a.set) {
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.set,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext$a(ctx, {
          code: ZodIssueCode$a.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext$a(ctx, {
          code: ZodIssueCode$a.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID$a;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$a(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet7({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$a.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet7({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$a.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$a.create = (valueType, params) => {
  return new ZodSet$a({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$a.ZodSet,
    ...processCreateParams$a(params)
  });
};
let ZodLazy$a = class ZodLazy7 extends ZodType$a {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$a.create = (getter, params) => {
  return new ZodLazy$a({
    getter,
    typeName: ZodFirstPartyTypeKind$a.ZodLazy,
    ...processCreateParams$a(params)
  });
};
let ZodLiteral$a = class ZodLiteral7 extends ZodType$a {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx, {
        received: ctx.data,
        code: ZodIssueCode$a.invalid_literal,
        expected: this._def.value
      });
      return INVALID$a;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$a.create = (value, params) => {
  return new ZodLiteral$a({
    value,
    typeName: ZodFirstPartyTypeKind$a.ZodLiteral,
    ...processCreateParams$a(params)
  });
};
function createZodEnum$a(values, params) {
  return new ZodEnum$a({
    values,
    typeName: ZodFirstPartyTypeKind$a.ZodEnum,
    ...processCreateParams$a(params)
  });
}
let ZodEnum$a = class ZodEnum7 extends ZodType$a {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$a(ctx, {
        expected: util$a.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$a.invalid_type
      });
      return INVALID$a;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$a(ctx, {
        received: ctx.data,
        code: ZodIssueCode$a.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$a;
    }
    return OK$a(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum7.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum7.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum$a.create = createZodEnum$a;
let ZodNativeEnum$a = class ZodNativeEnum7 extends ZodType$a {
  _parse(input) {
    const nativeEnumValues = util$a.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$a.string && ctx.parsedType !== ZodParsedType$a.number) {
      const expectedValues = util$a.objectValues(nativeEnumValues);
      addIssueToContext$a(ctx, {
        expected: util$a.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$a.invalid_type
      });
      return INVALID$a;
    }
    if (!this._cache) {
      this._cache = new Set(util$a.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util$a.objectValues(nativeEnumValues);
      addIssueToContext$a(ctx, {
        received: ctx.data,
        code: ZodIssueCode$a.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$a;
    }
    return OK$a(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum$a.create = (values, params) => {
  return new ZodNativeEnum$a({
    values,
    typeName: ZodFirstPartyTypeKind$a.ZodNativeEnum,
    ...processCreateParams$a(params)
  });
};
let ZodPromise$a = class ZodPromise7 extends ZodType$a {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$a.promise && ctx.common.async === false) {
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.promise,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    const promisified = ctx.parsedType === ZodParsedType$a.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$a(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$a.create = (schema, params) => {
  return new ZodPromise$a({
    type: schema,
    typeName: ZodFirstPartyTypeKind$a.ZodPromise,
    ...processCreateParams$a(params)
  });
};
let ZodEffects$a = class ZodEffects7 extends ZodType$a {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$a.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$a(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$a;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$a;
          if (result.status === "dirty")
            return DIRTY$a(result.value);
          if (status.value === "dirty")
            return DIRTY$a(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$a;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$a;
        if (result.status === "dirty")
          return DIRTY$a(result.value);
        if (status.value === "dirty")
          return DIRTY$a(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$a;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$a;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$a(base))
          return INVALID$a;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$a(base))
            return INVALID$a;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util$a.assertNever(effect);
  }
};
ZodEffects$a.create = (schema, effect, params) => {
  return new ZodEffects$a({
    schema,
    typeName: ZodFirstPartyTypeKind$a.ZodEffects,
    effect,
    ...processCreateParams$a(params)
  });
};
ZodEffects$a.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$a({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$a.ZodEffects,
    ...processCreateParams$a(params)
  });
};
let ZodOptional$a = class ZodOptional7 extends ZodType$a {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$a.undefined) {
      return OK$a(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$a.create = (type, params) => {
  return new ZodOptional$a({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$a.ZodOptional,
    ...processCreateParams$a(params)
  });
};
let ZodNullable$a = class ZodNullable7 extends ZodType$a {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$a.null) {
      return OK$a(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$a.create = (type, params) => {
  return new ZodNullable$a({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$a.ZodNullable,
    ...processCreateParams$a(params)
  });
};
let ZodDefault$a = class ZodDefault7 extends ZodType$a {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$a.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$a.create = (type, params) => {
  return new ZodDefault$a({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$a.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$a(params)
  });
};
let ZodCatch$a = class ZodCatch7 extends ZodType$a {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$a(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$a(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$a(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$a.create = (type, params) => {
  return new ZodCatch$a({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$a.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$a(params)
  });
};
let ZodNaN$a = class ZodNaN7 extends ZodType$a {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.nan,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$a.create = (params) => {
  return new ZodNaN$a({
    typeName: ZodFirstPartyTypeKind$a.ZodNaN,
    ...processCreateParams$a(params)
  });
};
let ZodBranded$a = class ZodBranded7 extends ZodType$a {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$a = class ZodPipeline7 extends ZodType$a {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$a;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$a(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$a;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline7({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$a.ZodPipeline
    });
  }
};
let ZodReadonly$a = class ZodReadonly7 extends ZodType$a {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$a(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$a(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$a.create = (type, params) => {
  return new ZodReadonly$a({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$a.ZodReadonly,
    ...processCreateParams$a(params)
  });
};
var ZodFirstPartyTypeKind$a;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$a || (ZodFirstPartyTypeKind$a = {}));
const numberType$9 = ZodNumber$a.create;
ZodNever$a.create;
ZodArray$a.create;
const objectType$a = ZodObject$a.create;
ZodUnion$a.create;
ZodIntersection$a.create;
ZodTuple$a.create;
ZodEnum$a.create;
const nativeEnumType$4 = ZodNativeEnum$a.create;
ZodPromise$a.create;
ZodOptional$a.create;
ZodNullable$a.create;
const ContainOptionsSchema = objectType$a({
  /** the width to resize the image to */
  w: numberType$9(),
  /** the height to resize the image to */
  h: numberType$9(),
  /** A bitmask for horizontal and vertical alignment */
  align: numberType$9().optional(),
  /** a scaling method (e.g. Jimp.RESIZE_BEZIER) */
  mode: nativeEnumType$4(ResizeStrategy).optional()
});
const methods$c = {
  /**
   * Scale the image to the given width and height keeping the aspect ratio. Some parts of the image may be letter boxed.
   * @param w the width to resize the image to
   * @param h the height to resize the image to
   * @param align A bitmask for horizontal and vertical alignment
   * @param mode a scaling method (e.g. Jimp.RESIZE_BEZIER)
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.contain({ w: 150, h: 100 });
   * ```
   */
  contain(image, options) {
    const { w, h, align = HorizontalAlign.CENTER | VerticalAlign.MIDDLE, mode } = ContainOptionsSchema.parse(options);
    const hbits = align & (1 << 3) - 1;
    const vbits = align >> 3;
    if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1))) {
      throw new Error("only use one flag per alignment direction");
    }
    const alignH = hbits >> 1;
    const alignV = vbits >> 1;
    const f = w / h > image.bitmap.width / image.bitmap.height ? h / image.bitmap.height : w / image.bitmap.width;
    const c2 = methods$d.scale(clone(image), { f, mode });
    image = methods$d.resize(image, { w, h, mode });
    image.scan((_, __, idx) => {
      image.bitmap.data.writeUInt32BE(image.background, idx);
    });
    image = methods$h.blit(image, {
      src: c2,
      x: (image.bitmap.width - c2.bitmap.width) / 2 * alignH,
      y: (image.bitmap.height - c2.bitmap.height) / 2 * alignV
    });
    return image;
  }
};
var util$9;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$9 || (util$9 = {}));
var objectUtil$9;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$9 || (objectUtil$9 = {}));
const ZodParsedType$9 = util$9.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$9 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$9.undefined;
    case "string":
      return ZodParsedType$9.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType$9.nan : ZodParsedType$9.number;
    case "boolean":
      return ZodParsedType$9.boolean;
    case "function":
      return ZodParsedType$9.function;
    case "bigint":
      return ZodParsedType$9.bigint;
    case "symbol":
      return ZodParsedType$9.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$9.array;
      }
      if (data === null) {
        return ZodParsedType$9.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$9.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$9.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$9.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$9.date;
      }
      return ZodParsedType$9.object;
    default:
      return ZodParsedType$9.unknown;
  }
};
const ZodIssueCode$9 = util$9.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
let ZodError$9 = class ZodError8 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue2 of error.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError8)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$9.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$9.create = (issues) => {
  const error = new ZodError$9(issues);
  return error;
};
const errorMap$9 = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode$9.invalid_type:
      if (issue2.received === ZodParsedType$9.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode$9.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util$9.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$9.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$9.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode$9.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$9.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$9.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode$9.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$9.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode$9.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$9.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$9.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$9.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util$9.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$9.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$9.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$9.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$9.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$9.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode$9.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$9.assertNever(issue2);
  }
  return { message };
};
let overrideErrorMap$9 = errorMap$9;
function getErrorMap$9() {
  return overrideErrorMap$9;
}
const makeIssue$9 = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext$9(ctx, issueData) {
  const overrideMap = getErrorMap$9();
  const issue2 = makeIssue$9({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$9 ? void 0 : errorMap$9
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue2);
}
let ParseStatus$9 = class ParseStatus8 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$9;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus8.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$9;
      if (value.status === "aborted")
        return INVALID$9;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$9 = Object.freeze({
  status: "aborted"
});
const DIRTY$9 = (value) => ({ status: "dirty", value });
const OK$9 = (value) => ({ status: "valid", value });
const isAborted$9 = (x2) => x2.status === "aborted";
const isDirty$9 = (x2) => x2.status === "dirty";
const isValid$9 = (x2) => x2.status === "valid";
const isAsync$9 = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil$9;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil$9 || (errorUtil$9 = {}));
let ParseInputLazyPath$9 = class ParseInputLazyPath8 {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$9 = (ctx, result) => {
  if (isValid$9(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$9(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$9(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$9 = class ZodType8 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$9(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$9(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$9(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$9(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$9(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: (params == null ? void 0 : params.async) ?? false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$9(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$9(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$9(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$9(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$9(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$9(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$9(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$9(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$9.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$9({
      schema: this,
      typeName: ZodFirstPartyTypeKind$9.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$9.create(this, this._def);
  }
  nullable() {
    return ZodNullable$9.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$9.create(this);
  }
  promise() {
    return ZodPromise$9.create(this, this._def);
  }
  or(option) {
    return ZodUnion$9.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$9.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects$9({
      ...processCreateParams$9(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$9.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault$9({
      ...processCreateParams$9(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$9.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$9({
      typeName: ZodFirstPartyTypeKind$9.ZodBranded,
      type: this,
      ...processCreateParams$9(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch$9({
      ...processCreateParams$9(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$9.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$9.create(this, target);
  }
  readonly() {
    return ZodReadonly$9.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$9 = /^c[^\s-]{8,}$/i;
const cuid2Regex$9 = /^[0-9a-z]+$/;
const ulidRegex$9 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$9 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$9 = /^[a-z0-9_-]{21}$/i;
const jwtRegex$9 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$9 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$9 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$9 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$9;
const ipv4Regex$9 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$9 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$9 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$9 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$9 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$9 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$9 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$9 = new RegExp(`^${dateRegexSource$9}$`);
function timeRegexSource$9(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex$9(args) {
  return new RegExp(`^${timeRegexSource$9(args)}$`);
}
function datetimeRegex$9(args) {
  let regex = `${dateRegexSource$9}T${timeRegexSource$9(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$9(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex$9.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex$9.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$9(jwt, alg) {
  if (!jwtRegex$9.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr$9(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex$9.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex$9.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$9 = class ZodString8 extends ZodType$9 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx2, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.string,
        received: ctx2.parsedType
      });
      return INVALID$9;
    }
    const status = new ParseStatus$9();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$9(ctx, {
              code: ZodIssueCode$9.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$9(ctx, {
              code: ZodIssueCode$9.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "email",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$9) {
          emojiRegex$9 = new RegExp(_emojiRegex$9, "u");
        }
        if (!emojiRegex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "emoji",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "uuid",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "cuid",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "ulid",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "url",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "regex",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$9(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$9;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$9(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "duration",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$9(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "ip",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$9(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "jwt",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$9(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "cidr",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "base64",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "base64url",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$9.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$9.invalid_string,
      ...errorUtil$9.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString8({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$9.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$9.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$9.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$9.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$9.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$9.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$9.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$9.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$9.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$9.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$9.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$9.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$9.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (options == null ? void 0 : options.offset) ?? false,
      local: (options == null ? void 0 : options.local) ?? false,
      ...errorUtil$9.errToObj(options == null ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      ...errorUtil$9.errToObj(options == null ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$9.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$9.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position,
      ...errorUtil$9.errToObj(options == null ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$9.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$9.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$9.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$9.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$9.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$9.errToObj(message));
  }
  trim() {
    return new ZodString8({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString8({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString8({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$9.create = (params) => {
  return new ZodString$9({
    checks: [],
    typeName: ZodFirstPartyTypeKind$9.ZodString,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$9(params)
  });
};
function floatSafeRemainder$9(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
let ZodNumber$9 = class ZodNumber8 extends ZodType$9 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx2, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.number,
        received: ctx2.parsedType
      });
      return INVALID$9;
    }
    let ctx = void 0;
    const status = new ParseStatus$9();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$9.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$9(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$9.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$9.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$9.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$9.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$9.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber8({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$9.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber8({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$9.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$9.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$9.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$9.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$9.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$9.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$9.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$9.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$9.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$9.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$9.create = (params) => {
  return new ZodNumber$9({
    checks: [],
    typeName: ZodFirstPartyTypeKind$9.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$9(params)
  });
};
let ZodBigInt$9 = class ZodBigInt8 extends ZodType$9 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$9();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$9.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$9(ctx, {
      code: ZodIssueCode$9.invalid_type,
      expected: ZodParsedType$9.bigint,
      received: ctx.parsedType
    });
    return INVALID$9;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$9.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$9.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$9.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$9.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt8({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$9.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt8({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$9.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$9.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$9.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$9.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$9.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$9.create = (params) => {
  return new ZodBigInt$9({
    checks: [],
    typeName: ZodFirstPartyTypeKind$9.ZodBigInt,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$9(params)
  });
};
let ZodBoolean$9 = class ZodBoolean8 extends ZodType$9 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.boolean,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    return OK$9(input.data);
  }
};
ZodBoolean$9.create = (params) => {
  return new ZodBoolean$9({
    typeName: ZodFirstPartyTypeKind$9.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$9(params)
  });
};
let ZodDate$9 = class ZodDate8 extends ZodType$9 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx2, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.date,
        received: ctx2.parsedType
      });
      return INVALID$9;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx2, {
        code: ZodIssueCode$9.invalid_date
      });
      return INVALID$9;
    }
    const status = new ParseStatus$9();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$9.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate8({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$9.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$9.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$9.create = (params) => {
  return new ZodDate$9({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$9.ZodDate,
    ...processCreateParams$9(params)
  });
};
let ZodSymbol$9 = class ZodSymbol8 extends ZodType$9 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.symbol,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    return OK$9(input.data);
  }
};
ZodSymbol$9.create = (params) => {
  return new ZodSymbol$9({
    typeName: ZodFirstPartyTypeKind$9.ZodSymbol,
    ...processCreateParams$9(params)
  });
};
let ZodUndefined$9 = class ZodUndefined8 extends ZodType$9 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.undefined,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    return OK$9(input.data);
  }
};
ZodUndefined$9.create = (params) => {
  return new ZodUndefined$9({
    typeName: ZodFirstPartyTypeKind$9.ZodUndefined,
    ...processCreateParams$9(params)
  });
};
let ZodNull$9 = class ZodNull8 extends ZodType$9 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.null,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    return OK$9(input.data);
  }
};
ZodNull$9.create = (params) => {
  return new ZodNull$9({
    typeName: ZodFirstPartyTypeKind$9.ZodNull,
    ...processCreateParams$9(params)
  });
};
let ZodAny$9 = class ZodAny8 extends ZodType$9 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$9(input.data);
  }
};
ZodAny$9.create = (params) => {
  return new ZodAny$9({
    typeName: ZodFirstPartyTypeKind$9.ZodAny,
    ...processCreateParams$9(params)
  });
};
let ZodUnknown$9 = class ZodUnknown8 extends ZodType$9 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$9(input.data);
  }
};
ZodUnknown$9.create = (params) => {
  return new ZodUnknown$9({
    typeName: ZodFirstPartyTypeKind$9.ZodUnknown,
    ...processCreateParams$9(params)
  });
};
let ZodNever$9 = class ZodNever8 extends ZodType$9 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$9(ctx, {
      code: ZodIssueCode$9.invalid_type,
      expected: ZodParsedType$9.never,
      received: ctx.parsedType
    });
    return INVALID$9;
  }
};
ZodNever$9.create = (params) => {
  return new ZodNever$9({
    typeName: ZodFirstPartyTypeKind$9.ZodNever,
    ...processCreateParams$9(params)
  });
};
let ZodVoid$9 = class ZodVoid8 extends ZodType$9 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.void,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    return OK$9(input.data);
  }
};
ZodVoid$9.create = (params) => {
  return new ZodVoid$9({
    typeName: ZodFirstPartyTypeKind$9.ZodVoid,
    ...processCreateParams$9(params)
  });
};
let ZodArray$9 = class ZodArray8 extends ZodType$9 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType$9.array) {
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.array,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$9(ctx, {
          code: tooBig ? ZodIssueCode$9.too_big : ZodIssueCode$9.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext$9(ctx, {
          code: ZodIssueCode$9.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext$9(ctx, {
          code: ZodIssueCode$9.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath$9(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$9.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath$9(ctx, item, ctx.path, i));
    });
    return ParseStatus$9.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray8({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$9.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray8({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$9.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray8({
      ...this._def,
      exactLength: { value: len, message: errorUtil$9.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$9.create = (schema, params) => {
  return new ZodArray$9({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$9.ZodArray,
    ...processCreateParams$9(params)
  });
};
function deepPartialify$9(schema) {
  if (schema instanceof ZodObject$9) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$9.create(deepPartialify$9(fieldSchema));
    }
    return new ZodObject$9({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$9) {
    return new ZodArray$9({
      ...schema._def,
      type: deepPartialify$9(schema.element)
    });
  } else if (schema instanceof ZodOptional$9) {
    return ZodOptional$9.create(deepPartialify$9(schema.unwrap()));
  } else if (schema instanceof ZodNullable$9) {
    return ZodNullable$9.create(deepPartialify$9(schema.unwrap()));
  } else if (schema instanceof ZodTuple$9) {
    return ZodTuple$9.create(schema.items.map((item) => deepPartialify$9(item)));
  } else {
    return schema;
  }
}
let ZodObject$9 = class ZodObject8 extends ZodType$9 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$9.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx2, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.object,
        received: ctx2.parsedType
      });
      return INVALID$9;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$9 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$9(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$9) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$9(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$9.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$9.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$9.errToObj;
    return new ZodObject8({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          var _a, _b;
          const defaultError = ((_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue2, ctx).message) ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil$9.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject8({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject8({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject8({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject8({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$9.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject8({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util$9.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject8({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util$9.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject8({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$9(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util$9.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject8({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util$9.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$9) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject8({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$9(util$9.objectKeys(this.shape));
  }
};
ZodObject$9.create = (shape, params) => {
  return new ZodObject$9({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$9.create(),
    typeName: ZodFirstPartyTypeKind$9.ZodObject,
    ...processCreateParams$9(params)
  });
};
ZodObject$9.strictCreate = (shape, params) => {
  return new ZodObject$9({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$9.create(),
    typeName: ZodFirstPartyTypeKind$9.ZodObject,
    ...processCreateParams$9(params)
  });
};
ZodObject$9.lazycreate = (shape, params) => {
  return new ZodObject$9({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$9.create(),
    typeName: ZodFirstPartyTypeKind$9.ZodObject,
    ...processCreateParams$9(params)
  });
};
let ZodUnion$9 = class ZodUnion8 extends ZodType$9 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$9(result.ctx.common.issues));
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_union,
        unionErrors
      });
      return INVALID$9;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$9(issues2));
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_union,
        unionErrors
      });
      return INVALID$9;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$9.create = (types, params) => {
  return new ZodUnion$9({
    options: types,
    typeName: ZodFirstPartyTypeKind$9.ZodUnion,
    ...processCreateParams$9(params)
  });
};
function mergeValues$9(a, b) {
  const aType = getParsedType$9(a);
  const bType = getParsedType$9(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$9.object && bType === ZodParsedType$9.object) {
    const bKeys = util$9.objectKeys(b);
    const sharedKeys = util$9.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$9(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$9.array && bType === ZodParsedType$9.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$9(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$9.date && bType === ZodParsedType$9.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$9 = class ZodIntersection8 extends ZodType$9 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$9(parsedLeft) || isAborted$9(parsedRight)) {
        return INVALID$9;
      }
      const merged = mergeValues$9(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$9(ctx, {
          code: ZodIssueCode$9.invalid_intersection_types
        });
        return INVALID$9;
      }
      if (isDirty$9(parsedLeft) || isDirty$9(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$9.create = (left, right, params) => {
  return new ZodIntersection$9({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$9.ZodIntersection,
    ...processCreateParams$9(params)
  });
};
let ZodTuple$9 = class ZodTuple8 extends ZodType$9 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$9.array) {
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.array,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$9;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$9(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$9.mergeArray(status, results);
      });
    } else {
      return ParseStatus$9.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple8({
      ...this._def,
      rest
    });
  }
};
ZodTuple$9.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$9({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$9.ZodTuple,
    rest: null,
    ...processCreateParams$9(params)
  });
};
let ZodMap$9 = class ZodMap8 extends ZodType$9 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$9.map) {
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.map,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$9(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$9(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$9;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$9;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$9.create = (keyType, valueType, params) => {
  return new ZodMap$9({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$9.ZodMap,
    ...processCreateParams$9(params)
  });
};
let ZodSet$9 = class ZodSet8 extends ZodType$9 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$9.set) {
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.set,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext$9(ctx, {
          code: ZodIssueCode$9.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext$9(ctx, {
          code: ZodIssueCode$9.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID$9;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$9(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet8({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$9.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet8({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$9.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$9.create = (valueType, params) => {
  return new ZodSet$9({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$9.ZodSet,
    ...processCreateParams$9(params)
  });
};
let ZodLazy$9 = class ZodLazy8 extends ZodType$9 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$9.create = (getter, params) => {
  return new ZodLazy$9({
    getter,
    typeName: ZodFirstPartyTypeKind$9.ZodLazy,
    ...processCreateParams$9(params)
  });
};
let ZodLiteral$9 = class ZodLiteral8 extends ZodType$9 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx, {
        received: ctx.data,
        code: ZodIssueCode$9.invalid_literal,
        expected: this._def.value
      });
      return INVALID$9;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$9.create = (value, params) => {
  return new ZodLiteral$9({
    value,
    typeName: ZodFirstPartyTypeKind$9.ZodLiteral,
    ...processCreateParams$9(params)
  });
};
function createZodEnum$9(values, params) {
  return new ZodEnum$9({
    values,
    typeName: ZodFirstPartyTypeKind$9.ZodEnum,
    ...processCreateParams$9(params)
  });
}
let ZodEnum$9 = class ZodEnum8 extends ZodType$9 {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$9(ctx, {
        expected: util$9.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$9.invalid_type
      });
      return INVALID$9;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$9(ctx, {
        received: ctx.data,
        code: ZodIssueCode$9.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$9;
    }
    return OK$9(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum8.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum8.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum$9.create = createZodEnum$9;
let ZodNativeEnum$9 = class ZodNativeEnum8 extends ZodType$9 {
  _parse(input) {
    const nativeEnumValues = util$9.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$9.string && ctx.parsedType !== ZodParsedType$9.number) {
      const expectedValues = util$9.objectValues(nativeEnumValues);
      addIssueToContext$9(ctx, {
        expected: util$9.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$9.invalid_type
      });
      return INVALID$9;
    }
    if (!this._cache) {
      this._cache = new Set(util$9.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util$9.objectValues(nativeEnumValues);
      addIssueToContext$9(ctx, {
        received: ctx.data,
        code: ZodIssueCode$9.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$9;
    }
    return OK$9(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum$9.create = (values, params) => {
  return new ZodNativeEnum$9({
    values,
    typeName: ZodFirstPartyTypeKind$9.ZodNativeEnum,
    ...processCreateParams$9(params)
  });
};
let ZodPromise$9 = class ZodPromise8 extends ZodType$9 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$9.promise && ctx.common.async === false) {
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.promise,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    const promisified = ctx.parsedType === ZodParsedType$9.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$9(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$9.create = (schema, params) => {
  return new ZodPromise$9({
    type: schema,
    typeName: ZodFirstPartyTypeKind$9.ZodPromise,
    ...processCreateParams$9(params)
  });
};
let ZodEffects$9 = class ZodEffects8 extends ZodType$9 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$9.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$9(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$9;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$9;
          if (result.status === "dirty")
            return DIRTY$9(result.value);
          if (status.value === "dirty")
            return DIRTY$9(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$9;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$9;
        if (result.status === "dirty")
          return DIRTY$9(result.value);
        if (status.value === "dirty")
          return DIRTY$9(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$9;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$9;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$9(base))
          return INVALID$9;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$9(base))
            return INVALID$9;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util$9.assertNever(effect);
  }
};
ZodEffects$9.create = (schema, effect, params) => {
  return new ZodEffects$9({
    schema,
    typeName: ZodFirstPartyTypeKind$9.ZodEffects,
    effect,
    ...processCreateParams$9(params)
  });
};
ZodEffects$9.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$9({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$9.ZodEffects,
    ...processCreateParams$9(params)
  });
};
let ZodOptional$9 = class ZodOptional8 extends ZodType$9 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$9.undefined) {
      return OK$9(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$9.create = (type, params) => {
  return new ZodOptional$9({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$9.ZodOptional,
    ...processCreateParams$9(params)
  });
};
let ZodNullable$9 = class ZodNullable8 extends ZodType$9 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$9.null) {
      return OK$9(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$9.create = (type, params) => {
  return new ZodNullable$9({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$9.ZodNullable,
    ...processCreateParams$9(params)
  });
};
let ZodDefault$9 = class ZodDefault8 extends ZodType$9 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$9.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$9.create = (type, params) => {
  return new ZodDefault$9({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$9.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$9(params)
  });
};
let ZodCatch$9 = class ZodCatch8 extends ZodType$9 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$9(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$9(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$9(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$9.create = (type, params) => {
  return new ZodCatch$9({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$9.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$9(params)
  });
};
let ZodNaN$9 = class ZodNaN8 extends ZodType$9 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.nan,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$9.create = (params) => {
  return new ZodNaN$9({
    typeName: ZodFirstPartyTypeKind$9.ZodNaN,
    ...processCreateParams$9(params)
  });
};
let ZodBranded$9 = class ZodBranded8 extends ZodType$9 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$9 = class ZodPipeline8 extends ZodType$9 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$9;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$9(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$9;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline8({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$9.ZodPipeline
    });
  }
};
let ZodReadonly$9 = class ZodReadonly8 extends ZodType$9 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$9(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$9(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$9.create = (type, params) => {
  return new ZodReadonly$9({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$9.ZodReadonly,
    ...processCreateParams$9(params)
  });
};
var ZodFirstPartyTypeKind$9;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$9 || (ZodFirstPartyTypeKind$9 = {}));
const numberType$8 = ZodNumber$9.create;
const booleanType$4 = ZodBoolean$9.create;
ZodNever$9.create;
ZodArray$9.create;
const objectType$9 = ZodObject$9.create;
ZodUnion$9.create;
ZodIntersection$9.create;
ZodTuple$9.create;
ZodEnum$9.create;
ZodPromise$9.create;
ZodOptional$9.create;
ZodNullable$9.create;
const CropOptionsSchema = objectType$9({
  /** the x position to crop form */
  x: numberType$8(),
  /** the y position to crop form */
  y: numberType$8(),
  /** the width to crop form */
  w: numberType$8(),
  /** the height to crop form */
  h: numberType$8()
});
const AutocropComplexOptionsSchema = objectType$9({
  /** percent of color difference tolerance (default value) */
  tolerance: numberType$8().min(0).max(1).optional(),
  /** flag to force cropping only if the image has a real "frame" i.e. all 4 sides have some border (default value) */
  cropOnlyFrames: booleanType$4().optional(),
  /** force cropping top be symmetric */
  cropSymmetric: booleanType$4().optional(),
  /** Amount of pixels in border to leave */
  leaveBorder: numberType$8().optional(),
  ignoreSides: objectType$9({
    north: booleanType$4().optional(),
    south: booleanType$4().optional(),
    east: booleanType$4().optional(),
    west: booleanType$4().optional()
  }).optional()
});
const methods$b = {
  /**
   * Crops the image at a given point to a give size.
   *
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   * const cropped = image.crop(150, 100);
   * ```
   */
  crop(image, options) {
    let { x: x2, y: y2, w, h } = CropOptionsSchema.parse(options);
    x2 = Math.round(x2);
    y2 = Math.round(y2);
    w = Math.round(w);
    h = Math.round(h);
    if (x2 === 0 && w === image.bitmap.width) {
      const start = w * y2 + x2 << 2;
      const end = start + (h * w << 2);
      image.bitmap.data = image.bitmap.data.slice(start, end);
    } else {
      const bitmap = Buffer.allocUnsafe(w * h * 4);
      let offset = 0;
      scan(image, x2, y2, w, h, function(_, __, idx) {
        const data = image.bitmap.data.readUInt32BE(idx);
        bitmap.writeUInt32BE(data, offset);
        offset += 4;
      });
      image.bitmap.data = bitmap;
    }
    image.bitmap.width = w;
    image.bitmap.height = h;
    return image;
  },
  /**
   * Autocrop same color borders from this image.
   * This function will attempt to crop out transparent pixels from the image.
   *
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   * const cropped = image.autocrop();
   * ```
   */
  autocrop(image, options = {}) {
    const { tolerance = 2e-4, cropOnlyFrames = true, cropSymmetric = false, leaveBorder = 0, ignoreSides: ignoreSidesArg } = typeof options === "number" ? { tolerance: options } : AutocropComplexOptionsSchema.parse(options);
    const w = image.bitmap.width;
    const h = image.bitmap.height;
    const minPixelsPerSide = 1;
    const ignoreSides = {
      north: false,
      south: false,
      east: false,
      west: false,
      ...ignoreSidesArg
    };
    let colorTarget = image.getPixelColor(0, 0);
    const rgba1 = intToRGBA$1(colorTarget);
    let northPixelsToCrop = 0;
    let eastPixelsToCrop = 0;
    let southPixelsToCrop = 0;
    let westPixelsToCrop = 0;
    colorTarget = image.getPixelColor(0, 0);
    if (!ignoreSides.north) {
      north: for (let y2 = 0; y2 < h - minPixelsPerSide; y2++) {
        for (let x2 = 0; x2 < w; x2++) {
          const colorXY = image.getPixelColor(x2, y2);
          const rgba2 = intToRGBA$1(colorXY);
          if (colorDiff(rgba1, rgba2) > tolerance) {
            break north;
          }
        }
        northPixelsToCrop++;
      }
    }
    colorTarget = image.getPixelColor(w, 0);
    if (!ignoreSides.west) {
      west: for (let x2 = 0; x2 < w - minPixelsPerSide; x2++) {
        for (let y2 = 0 + northPixelsToCrop; y2 < h; y2++) {
          const colorXY = image.getPixelColor(x2, y2);
          const rgba2 = intToRGBA$1(colorXY);
          if (colorDiff(rgba1, rgba2) > tolerance) {
            break west;
          }
        }
        westPixelsToCrop++;
      }
    }
    colorTarget = image.getPixelColor(0, h);
    if (!ignoreSides.south) {
      south: for (let y2 = h - 1; y2 >= northPixelsToCrop + minPixelsPerSide; y2--) {
        for (let x2 = w - eastPixelsToCrop - 1; x2 >= 0; x2--) {
          const colorXY = image.getPixelColor(x2, y2);
          const rgba2 = intToRGBA$1(colorXY);
          if (colorDiff(rgba1, rgba2) > tolerance) {
            break south;
          }
        }
        southPixelsToCrop++;
      }
    }
    colorTarget = image.getPixelColor(w, h);
    if (!ignoreSides.east) {
      east: for (let x2 = w - 1; x2 >= 0 + westPixelsToCrop + minPixelsPerSide; x2--) {
        for (let y2 = h - 1; y2 >= 0 + northPixelsToCrop; y2--) {
          const colorXY = image.getPixelColor(x2, y2);
          const rgba2 = intToRGBA$1(colorXY);
          if (colorDiff(rgba1, rgba2) > tolerance) {
            break east;
          }
        }
        eastPixelsToCrop++;
      }
    }
    let doCrop = false;
    westPixelsToCrop -= leaveBorder;
    eastPixelsToCrop -= leaveBorder;
    northPixelsToCrop -= leaveBorder;
    southPixelsToCrop -= leaveBorder;
    if (cropSymmetric) {
      const horizontal = Math.min(eastPixelsToCrop, westPixelsToCrop);
      const vertical = Math.min(northPixelsToCrop, southPixelsToCrop);
      westPixelsToCrop = horizontal;
      eastPixelsToCrop = horizontal;
      northPixelsToCrop = vertical;
      southPixelsToCrop = vertical;
    }
    westPixelsToCrop = westPixelsToCrop >= 0 ? westPixelsToCrop : 0;
    eastPixelsToCrop = eastPixelsToCrop >= 0 ? eastPixelsToCrop : 0;
    northPixelsToCrop = northPixelsToCrop >= 0 ? northPixelsToCrop : 0;
    southPixelsToCrop = southPixelsToCrop >= 0 ? southPixelsToCrop : 0;
    const widthOfRemainingPixels = w - (westPixelsToCrop + eastPixelsToCrop);
    const heightOfRemainingPixels = h - (southPixelsToCrop + northPixelsToCrop);
    if (cropOnlyFrames) {
      doCrop = eastPixelsToCrop !== 0 && northPixelsToCrop !== 0 && westPixelsToCrop !== 0 && southPixelsToCrop !== 0;
    } else {
      doCrop = eastPixelsToCrop !== 0 || northPixelsToCrop !== 0 || westPixelsToCrop !== 0 || southPixelsToCrop !== 0;
    }
    if (doCrop) {
      this.crop(image, {
        x: westPixelsToCrop,
        y: northPixelsToCrop,
        w: widthOfRemainingPixels,
        h: heightOfRemainingPixels
      });
    }
    return image;
  }
};
var util$8;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$8 || (util$8 = {}));
var objectUtil$8;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$8 || (objectUtil$8 = {}));
const ZodParsedType$8 = util$8.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$8 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$8.undefined;
    case "string":
      return ZodParsedType$8.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType$8.nan : ZodParsedType$8.number;
    case "boolean":
      return ZodParsedType$8.boolean;
    case "function":
      return ZodParsedType$8.function;
    case "bigint":
      return ZodParsedType$8.bigint;
    case "symbol":
      return ZodParsedType$8.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$8.array;
      }
      if (data === null) {
        return ZodParsedType$8.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$8.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$8.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$8.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$8.date;
      }
      return ZodParsedType$8.object;
    default:
      return ZodParsedType$8.unknown;
  }
};
const ZodIssueCode$8 = util$8.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
let ZodError$8 = class ZodError9 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue2 of error.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError9)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$8.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$8.create = (issues) => {
  const error = new ZodError$8(issues);
  return error;
};
const errorMap$8 = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode$8.invalid_type:
      if (issue2.received === ZodParsedType$8.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode$8.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util$8.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$8.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$8.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode$8.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$8.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$8.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode$8.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$8.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode$8.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$8.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$8.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$8.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util$8.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$8.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$8.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$8.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$8.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$8.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode$8.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$8.assertNever(issue2);
  }
  return { message };
};
let overrideErrorMap$8 = errorMap$8;
function getErrorMap$8() {
  return overrideErrorMap$8;
}
const makeIssue$8 = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext$8(ctx, issueData) {
  const overrideMap = getErrorMap$8();
  const issue2 = makeIssue$8({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$8 ? void 0 : errorMap$8
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue2);
}
let ParseStatus$8 = class ParseStatus9 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$8;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus9.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$8;
      if (value.status === "aborted")
        return INVALID$8;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$8 = Object.freeze({
  status: "aborted"
});
const DIRTY$8 = (value) => ({ status: "dirty", value });
const OK$8 = (value) => ({ status: "valid", value });
const isAborted$8 = (x2) => x2.status === "aborted";
const isDirty$8 = (x2) => x2.status === "dirty";
const isValid$8 = (x2) => x2.status === "valid";
const isAsync$8 = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil$8;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil$8 || (errorUtil$8 = {}));
let ParseInputLazyPath$8 = class ParseInputLazyPath9 {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$8 = (ctx, result) => {
  if (isValid$8(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$8(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$8(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$8 = class ZodType9 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$8(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$8(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$8(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$8(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$8(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: (params == null ? void 0 : params.async) ?? false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$8(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$8(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$8(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$8(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$8(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$8(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$8(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$8(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$8.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$8({
      schema: this,
      typeName: ZodFirstPartyTypeKind$8.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$8.create(this, this._def);
  }
  nullable() {
    return ZodNullable$8.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$8.create(this);
  }
  promise() {
    return ZodPromise$8.create(this, this._def);
  }
  or(option) {
    return ZodUnion$8.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$8.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects$8({
      ...processCreateParams$8(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$8.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault$8({
      ...processCreateParams$8(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$8.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$8({
      typeName: ZodFirstPartyTypeKind$8.ZodBranded,
      type: this,
      ...processCreateParams$8(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch$8({
      ...processCreateParams$8(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$8.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$8.create(this, target);
  }
  readonly() {
    return ZodReadonly$8.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$8 = /^c[^\s-]{8,}$/i;
const cuid2Regex$8 = /^[0-9a-z]+$/;
const ulidRegex$8 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$8 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$8 = /^[a-z0-9_-]{21}$/i;
const jwtRegex$8 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$8 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$8 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$8 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$8;
const ipv4Regex$8 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$8 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$8 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$8 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$8 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$8 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$8 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$8 = new RegExp(`^${dateRegexSource$8}$`);
function timeRegexSource$8(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex$8(args) {
  return new RegExp(`^${timeRegexSource$8(args)}$`);
}
function datetimeRegex$8(args) {
  let regex = `${dateRegexSource$8}T${timeRegexSource$8(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$8(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex$8.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex$8.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$8(jwt, alg) {
  if (!jwtRegex$8.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr$8(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex$8.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex$8.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$8 = class ZodString9 extends ZodType$8 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx2, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.string,
        received: ctx2.parsedType
      });
      return INVALID$8;
    }
    const status = new ParseStatus$8();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$8(ctx, {
              code: ZodIssueCode$8.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$8(ctx, {
              code: ZodIssueCode$8.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "email",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$8) {
          emojiRegex$8 = new RegExp(_emojiRegex$8, "u");
        }
        if (!emojiRegex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "emoji",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "uuid",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "cuid",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "ulid",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "url",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "regex",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$8(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$8;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$8(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "duration",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$8(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "ip",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$8(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "jwt",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$8(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "cidr",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "base64",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "base64url",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$8.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$8.invalid_string,
      ...errorUtil$8.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString9({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$8.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$8.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$8.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$8.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$8.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$8.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$8.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$8.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$8.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$8.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$8.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$8.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$8.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (options == null ? void 0 : options.offset) ?? false,
      local: (options == null ? void 0 : options.local) ?? false,
      ...errorUtil$8.errToObj(options == null ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      ...errorUtil$8.errToObj(options == null ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$8.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$8.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position,
      ...errorUtil$8.errToObj(options == null ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$8.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$8.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$8.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$8.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$8.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$8.errToObj(message));
  }
  trim() {
    return new ZodString9({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString9({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString9({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$8.create = (params) => {
  return new ZodString$8({
    checks: [],
    typeName: ZodFirstPartyTypeKind$8.ZodString,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$8(params)
  });
};
function floatSafeRemainder$8(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
let ZodNumber$8 = class ZodNumber9 extends ZodType$8 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx2, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.number,
        received: ctx2.parsedType
      });
      return INVALID$8;
    }
    let ctx = void 0;
    const status = new ParseStatus$8();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$8.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$8(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$8.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$8.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$8.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$8.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$8.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber9({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$8.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber9({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$8.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$8.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$8.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$8.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$8.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$8.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$8.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$8.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$8.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$8.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$8.create = (params) => {
  return new ZodNumber$8({
    checks: [],
    typeName: ZodFirstPartyTypeKind$8.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$8(params)
  });
};
let ZodBigInt$8 = class ZodBigInt9 extends ZodType$8 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$8();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$8.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$8(ctx, {
      code: ZodIssueCode$8.invalid_type,
      expected: ZodParsedType$8.bigint,
      received: ctx.parsedType
    });
    return INVALID$8;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$8.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$8.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$8.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$8.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt9({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$8.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt9({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$8.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$8.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$8.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$8.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$8.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$8.create = (params) => {
  return new ZodBigInt$8({
    checks: [],
    typeName: ZodFirstPartyTypeKind$8.ZodBigInt,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$8(params)
  });
};
let ZodBoolean$8 = class ZodBoolean9 extends ZodType$8 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.boolean,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    return OK$8(input.data);
  }
};
ZodBoolean$8.create = (params) => {
  return new ZodBoolean$8({
    typeName: ZodFirstPartyTypeKind$8.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$8(params)
  });
};
let ZodDate$8 = class ZodDate9 extends ZodType$8 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx2, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.date,
        received: ctx2.parsedType
      });
      return INVALID$8;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx2, {
        code: ZodIssueCode$8.invalid_date
      });
      return INVALID$8;
    }
    const status = new ParseStatus$8();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$8.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate9({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$8.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$8.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$8.create = (params) => {
  return new ZodDate$8({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$8.ZodDate,
    ...processCreateParams$8(params)
  });
};
let ZodSymbol$8 = class ZodSymbol9 extends ZodType$8 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.symbol,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    return OK$8(input.data);
  }
};
ZodSymbol$8.create = (params) => {
  return new ZodSymbol$8({
    typeName: ZodFirstPartyTypeKind$8.ZodSymbol,
    ...processCreateParams$8(params)
  });
};
let ZodUndefined$8 = class ZodUndefined9 extends ZodType$8 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.undefined,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    return OK$8(input.data);
  }
};
ZodUndefined$8.create = (params) => {
  return new ZodUndefined$8({
    typeName: ZodFirstPartyTypeKind$8.ZodUndefined,
    ...processCreateParams$8(params)
  });
};
let ZodNull$8 = class ZodNull9 extends ZodType$8 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.null,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    return OK$8(input.data);
  }
};
ZodNull$8.create = (params) => {
  return new ZodNull$8({
    typeName: ZodFirstPartyTypeKind$8.ZodNull,
    ...processCreateParams$8(params)
  });
};
let ZodAny$8 = class ZodAny9 extends ZodType$8 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$8(input.data);
  }
};
ZodAny$8.create = (params) => {
  return new ZodAny$8({
    typeName: ZodFirstPartyTypeKind$8.ZodAny,
    ...processCreateParams$8(params)
  });
};
let ZodUnknown$8 = class ZodUnknown9 extends ZodType$8 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$8(input.data);
  }
};
ZodUnknown$8.create = (params) => {
  return new ZodUnknown$8({
    typeName: ZodFirstPartyTypeKind$8.ZodUnknown,
    ...processCreateParams$8(params)
  });
};
let ZodNever$8 = class ZodNever9 extends ZodType$8 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$8(ctx, {
      code: ZodIssueCode$8.invalid_type,
      expected: ZodParsedType$8.never,
      received: ctx.parsedType
    });
    return INVALID$8;
  }
};
ZodNever$8.create = (params) => {
  return new ZodNever$8({
    typeName: ZodFirstPartyTypeKind$8.ZodNever,
    ...processCreateParams$8(params)
  });
};
let ZodVoid$8 = class ZodVoid9 extends ZodType$8 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.void,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    return OK$8(input.data);
  }
};
ZodVoid$8.create = (params) => {
  return new ZodVoid$8({
    typeName: ZodFirstPartyTypeKind$8.ZodVoid,
    ...processCreateParams$8(params)
  });
};
let ZodArray$8 = class ZodArray9 extends ZodType$8 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType$8.array) {
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.array,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$8(ctx, {
          code: tooBig ? ZodIssueCode$8.too_big : ZodIssueCode$8.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext$8(ctx, {
          code: ZodIssueCode$8.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext$8(ctx, {
          code: ZodIssueCode$8.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath$8(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$8.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath$8(ctx, item, ctx.path, i));
    });
    return ParseStatus$8.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray9({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$8.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray9({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$8.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray9({
      ...this._def,
      exactLength: { value: len, message: errorUtil$8.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$8.create = (schema, params) => {
  return new ZodArray$8({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$8.ZodArray,
    ...processCreateParams$8(params)
  });
};
function deepPartialify$8(schema) {
  if (schema instanceof ZodObject$8) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$8.create(deepPartialify$8(fieldSchema));
    }
    return new ZodObject$8({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$8) {
    return new ZodArray$8({
      ...schema._def,
      type: deepPartialify$8(schema.element)
    });
  } else if (schema instanceof ZodOptional$8) {
    return ZodOptional$8.create(deepPartialify$8(schema.unwrap()));
  } else if (schema instanceof ZodNullable$8) {
    return ZodNullable$8.create(deepPartialify$8(schema.unwrap()));
  } else if (schema instanceof ZodTuple$8) {
    return ZodTuple$8.create(schema.items.map((item) => deepPartialify$8(item)));
  } else {
    return schema;
  }
}
let ZodObject$8 = class ZodObject9 extends ZodType$8 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$8.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx2, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.object,
        received: ctx2.parsedType
      });
      return INVALID$8;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$8 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$8(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$8) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$8(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$8.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$8.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$8.errToObj;
    return new ZodObject9({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          var _a, _b;
          const defaultError = ((_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue2, ctx).message) ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil$8.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject9({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject9({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject9({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject9({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$8.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject9({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util$8.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject9({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util$8.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject9({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$8(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util$8.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject9({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util$8.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$8) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject9({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$8(util$8.objectKeys(this.shape));
  }
};
ZodObject$8.create = (shape, params) => {
  return new ZodObject$8({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$8.create(),
    typeName: ZodFirstPartyTypeKind$8.ZodObject,
    ...processCreateParams$8(params)
  });
};
ZodObject$8.strictCreate = (shape, params) => {
  return new ZodObject$8({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$8.create(),
    typeName: ZodFirstPartyTypeKind$8.ZodObject,
    ...processCreateParams$8(params)
  });
};
ZodObject$8.lazycreate = (shape, params) => {
  return new ZodObject$8({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$8.create(),
    typeName: ZodFirstPartyTypeKind$8.ZodObject,
    ...processCreateParams$8(params)
  });
};
let ZodUnion$8 = class ZodUnion9 extends ZodType$8 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$8(result.ctx.common.issues));
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_union,
        unionErrors
      });
      return INVALID$8;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$8(issues2));
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_union,
        unionErrors
      });
      return INVALID$8;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$8.create = (types, params) => {
  return new ZodUnion$8({
    options: types,
    typeName: ZodFirstPartyTypeKind$8.ZodUnion,
    ...processCreateParams$8(params)
  });
};
function mergeValues$8(a, b) {
  const aType = getParsedType$8(a);
  const bType = getParsedType$8(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$8.object && bType === ZodParsedType$8.object) {
    const bKeys = util$8.objectKeys(b);
    const sharedKeys = util$8.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$8(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$8.array && bType === ZodParsedType$8.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$8(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$8.date && bType === ZodParsedType$8.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$8 = class ZodIntersection9 extends ZodType$8 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$8(parsedLeft) || isAborted$8(parsedRight)) {
        return INVALID$8;
      }
      const merged = mergeValues$8(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$8(ctx, {
          code: ZodIssueCode$8.invalid_intersection_types
        });
        return INVALID$8;
      }
      if (isDirty$8(parsedLeft) || isDirty$8(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$8.create = (left, right, params) => {
  return new ZodIntersection$8({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$8.ZodIntersection,
    ...processCreateParams$8(params)
  });
};
let ZodTuple$8 = class ZodTuple9 extends ZodType$8 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$8.array) {
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.array,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$8;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$8(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$8.mergeArray(status, results);
      });
    } else {
      return ParseStatus$8.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple9({
      ...this._def,
      rest
    });
  }
};
ZodTuple$8.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$8({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$8.ZodTuple,
    rest: null,
    ...processCreateParams$8(params)
  });
};
let ZodMap$8 = class ZodMap9 extends ZodType$8 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$8.map) {
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.map,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$8(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$8(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$8;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$8;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$8.create = (keyType, valueType, params) => {
  return new ZodMap$8({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$8.ZodMap,
    ...processCreateParams$8(params)
  });
};
let ZodSet$8 = class ZodSet9 extends ZodType$8 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$8.set) {
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.set,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext$8(ctx, {
          code: ZodIssueCode$8.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext$8(ctx, {
          code: ZodIssueCode$8.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID$8;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$8(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet9({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$8.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet9({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$8.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$8.create = (valueType, params) => {
  return new ZodSet$8({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$8.ZodSet,
    ...processCreateParams$8(params)
  });
};
let ZodLazy$8 = class ZodLazy9 extends ZodType$8 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$8.create = (getter, params) => {
  return new ZodLazy$8({
    getter,
    typeName: ZodFirstPartyTypeKind$8.ZodLazy,
    ...processCreateParams$8(params)
  });
};
let ZodLiteral$8 = class ZodLiteral9 extends ZodType$8 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx, {
        received: ctx.data,
        code: ZodIssueCode$8.invalid_literal,
        expected: this._def.value
      });
      return INVALID$8;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$8.create = (value, params) => {
  return new ZodLiteral$8({
    value,
    typeName: ZodFirstPartyTypeKind$8.ZodLiteral,
    ...processCreateParams$8(params)
  });
};
function createZodEnum$8(values, params) {
  return new ZodEnum$8({
    values,
    typeName: ZodFirstPartyTypeKind$8.ZodEnum,
    ...processCreateParams$8(params)
  });
}
let ZodEnum$8 = class ZodEnum9 extends ZodType$8 {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$8(ctx, {
        expected: util$8.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$8.invalid_type
      });
      return INVALID$8;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$8(ctx, {
        received: ctx.data,
        code: ZodIssueCode$8.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$8;
    }
    return OK$8(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum9.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum9.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum$8.create = createZodEnum$8;
let ZodNativeEnum$8 = class ZodNativeEnum9 extends ZodType$8 {
  _parse(input) {
    const nativeEnumValues = util$8.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$8.string && ctx.parsedType !== ZodParsedType$8.number) {
      const expectedValues = util$8.objectValues(nativeEnumValues);
      addIssueToContext$8(ctx, {
        expected: util$8.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$8.invalid_type
      });
      return INVALID$8;
    }
    if (!this._cache) {
      this._cache = new Set(util$8.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util$8.objectValues(nativeEnumValues);
      addIssueToContext$8(ctx, {
        received: ctx.data,
        code: ZodIssueCode$8.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$8;
    }
    return OK$8(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum$8.create = (values, params) => {
  return new ZodNativeEnum$8({
    values,
    typeName: ZodFirstPartyTypeKind$8.ZodNativeEnum,
    ...processCreateParams$8(params)
  });
};
let ZodPromise$8 = class ZodPromise9 extends ZodType$8 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$8.promise && ctx.common.async === false) {
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.promise,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    const promisified = ctx.parsedType === ZodParsedType$8.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$8(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$8.create = (schema, params) => {
  return new ZodPromise$8({
    type: schema,
    typeName: ZodFirstPartyTypeKind$8.ZodPromise,
    ...processCreateParams$8(params)
  });
};
let ZodEffects$8 = class ZodEffects9 extends ZodType$8 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$8.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$8(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$8;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$8;
          if (result.status === "dirty")
            return DIRTY$8(result.value);
          if (status.value === "dirty")
            return DIRTY$8(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$8;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$8;
        if (result.status === "dirty")
          return DIRTY$8(result.value);
        if (status.value === "dirty")
          return DIRTY$8(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$8;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$8;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$8(base))
          return INVALID$8;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$8(base))
            return INVALID$8;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util$8.assertNever(effect);
  }
};
ZodEffects$8.create = (schema, effect, params) => {
  return new ZodEffects$8({
    schema,
    typeName: ZodFirstPartyTypeKind$8.ZodEffects,
    effect,
    ...processCreateParams$8(params)
  });
};
ZodEffects$8.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$8({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$8.ZodEffects,
    ...processCreateParams$8(params)
  });
};
let ZodOptional$8 = class ZodOptional9 extends ZodType$8 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$8.undefined) {
      return OK$8(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$8.create = (type, params) => {
  return new ZodOptional$8({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$8.ZodOptional,
    ...processCreateParams$8(params)
  });
};
let ZodNullable$8 = class ZodNullable9 extends ZodType$8 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$8.null) {
      return OK$8(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$8.create = (type, params) => {
  return new ZodNullable$8({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$8.ZodNullable,
    ...processCreateParams$8(params)
  });
};
let ZodDefault$8 = class ZodDefault9 extends ZodType$8 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$8.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$8.create = (type, params) => {
  return new ZodDefault$8({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$8.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$8(params)
  });
};
let ZodCatch$8 = class ZodCatch9 extends ZodType$8 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$8(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$8(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$8(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$8.create = (type, params) => {
  return new ZodCatch$8({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$8.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$8(params)
  });
};
let ZodNaN$8 = class ZodNaN9 extends ZodType$8 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.nan,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$8.create = (params) => {
  return new ZodNaN$8({
    typeName: ZodFirstPartyTypeKind$8.ZodNaN,
    ...processCreateParams$8(params)
  });
};
let ZodBranded$8 = class ZodBranded9 extends ZodType$8 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$8 = class ZodPipeline9 extends ZodType$8 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$8;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$8(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$8;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline9({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$8.ZodPipeline
    });
  }
};
let ZodReadonly$8 = class ZodReadonly9 extends ZodType$8 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$8(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$8(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$8.create = (type, params) => {
  return new ZodReadonly$8({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$8.ZodReadonly,
    ...processCreateParams$8(params)
  });
};
var ZodFirstPartyTypeKind$8;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$8 || (ZodFirstPartyTypeKind$8 = {}));
const numberType$7 = ZodNumber$8.create;
ZodNever$8.create;
ZodArray$8.create;
const objectType$8 = ZodObject$8.create;
ZodUnion$8.create;
ZodIntersection$8.create;
ZodTuple$8.create;
ZodEnum$8.create;
const nativeEnumType$3 = ZodNativeEnum$8.create;
ZodPromise$8.create;
ZodOptional$8.create;
ZodNullable$8.create;
const CoverOptionsSchema = objectType$8({
  /** the width to resize the image to */
  w: numberType$7(),
  /** the height to resize the image to */
  h: numberType$7(),
  /** A bitmask for horizontal and vertical alignment */
  align: numberType$7().optional(),
  /** a scaling method (e.g. ResizeStrategy.BEZIER) */
  mode: nativeEnumType$3(ResizeStrategy).optional()
});
const methods$a = {
  /**
   * Scale the image so the given width and height keeping the aspect ratio. Some parts of the image may be clipped.
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.cover(150, 100);
   * ```
   */
  cover(image, options) {
    const { w, h, align = HorizontalAlign.CENTER | VerticalAlign.MIDDLE, mode } = CoverOptionsSchema.parse(options);
    const hbits = align & (1 << 3) - 1;
    const vbits = align >> 3;
    if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1))) {
      throw new Error("only use one flag per alignment direction");
    }
    const alignH = hbits >> 1;
    const alignV = vbits >> 1;
    const f = w / h > image.bitmap.width / image.bitmap.height ? w / image.bitmap.width : h / image.bitmap.height;
    image = methods$d.scale(image, {
      f,
      mode
    });
    image = methods$b.crop(image, {
      x: (image.bitmap.width - w) / 2 * alignH,
      y: (image.bitmap.height - h) / 2 * alignV,
      w,
      h
    });
    return image;
  }
};
var util$7;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$7 || (util$7 = {}));
var objectUtil$7;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$7 || (objectUtil$7 = {}));
const ZodParsedType$7 = util$7.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$7 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$7.undefined;
    case "string":
      return ZodParsedType$7.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType$7.nan : ZodParsedType$7.number;
    case "boolean":
      return ZodParsedType$7.boolean;
    case "function":
      return ZodParsedType$7.function;
    case "bigint":
      return ZodParsedType$7.bigint;
    case "symbol":
      return ZodParsedType$7.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$7.array;
      }
      if (data === null) {
        return ZodParsedType$7.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$7.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$7.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$7.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$7.date;
      }
      return ZodParsedType$7.object;
    default:
      return ZodParsedType$7.unknown;
  }
};
const ZodIssueCode$7 = util$7.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
let ZodError$7 = class ZodError10 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue2 of error.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError10)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$7.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$7.create = (issues) => {
  const error = new ZodError$7(issues);
  return error;
};
const errorMap$7 = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode$7.invalid_type:
      if (issue2.received === ZodParsedType$7.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode$7.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util$7.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$7.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$7.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode$7.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$7.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$7.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode$7.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$7.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode$7.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$7.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$7.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$7.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util$7.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$7.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$7.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$7.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$7.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$7.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode$7.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$7.assertNever(issue2);
  }
  return { message };
};
let overrideErrorMap$7 = errorMap$7;
function getErrorMap$7() {
  return overrideErrorMap$7;
}
const makeIssue$7 = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext$7(ctx, issueData) {
  const overrideMap = getErrorMap$7();
  const issue2 = makeIssue$7({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$7 ? void 0 : errorMap$7
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue2);
}
let ParseStatus$7 = class ParseStatus10 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$7;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus10.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$7;
      if (value.status === "aborted")
        return INVALID$7;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$7 = Object.freeze({
  status: "aborted"
});
const DIRTY$7 = (value) => ({ status: "dirty", value });
const OK$7 = (value) => ({ status: "valid", value });
const isAborted$7 = (x2) => x2.status === "aborted";
const isDirty$7 = (x2) => x2.status === "dirty";
const isValid$7 = (x2) => x2.status === "valid";
const isAsync$7 = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil$7;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil$7 || (errorUtil$7 = {}));
let ParseInputLazyPath$7 = class ParseInputLazyPath10 {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$7 = (ctx, result) => {
  if (isValid$7(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$7(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$7(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$7 = class ZodType10 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$7(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$7(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$7(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$7(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$7(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: (params == null ? void 0 : params.async) ?? false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$7(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$7(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$7(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$7(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$7(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$7(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$7(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$7(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$7.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$7({
      schema: this,
      typeName: ZodFirstPartyTypeKind$7.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$7.create(this, this._def);
  }
  nullable() {
    return ZodNullable$7.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$7.create(this);
  }
  promise() {
    return ZodPromise$7.create(this, this._def);
  }
  or(option) {
    return ZodUnion$7.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$7.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects$7({
      ...processCreateParams$7(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$7.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault$7({
      ...processCreateParams$7(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$7.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$7({
      typeName: ZodFirstPartyTypeKind$7.ZodBranded,
      type: this,
      ...processCreateParams$7(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch$7({
      ...processCreateParams$7(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$7.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$7.create(this, target);
  }
  readonly() {
    return ZodReadonly$7.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$7 = /^c[^\s-]{8,}$/i;
const cuid2Regex$7 = /^[0-9a-z]+$/;
const ulidRegex$7 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$7 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$7 = /^[a-z0-9_-]{21}$/i;
const jwtRegex$7 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$7 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$7 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$7 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$7;
const ipv4Regex$7 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$7 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$7 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$7 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$7 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$7 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$7 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$7 = new RegExp(`^${dateRegexSource$7}$`);
function timeRegexSource$7(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex$7(args) {
  return new RegExp(`^${timeRegexSource$7(args)}$`);
}
function datetimeRegex$7(args) {
  let regex = `${dateRegexSource$7}T${timeRegexSource$7(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$7(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex$7.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex$7.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$7(jwt, alg) {
  if (!jwtRegex$7.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr$7(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex$7.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex$7.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$7 = class ZodString10 extends ZodType$7 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx2, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.string,
        received: ctx2.parsedType
      });
      return INVALID$7;
    }
    const status = new ParseStatus$7();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$7(ctx, {
              code: ZodIssueCode$7.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$7(ctx, {
              code: ZodIssueCode$7.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "email",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$7) {
          emojiRegex$7 = new RegExp(_emojiRegex$7, "u");
        }
        if (!emojiRegex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "emoji",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "uuid",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "cuid",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "ulid",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "url",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "regex",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$7(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$7;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$7(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "duration",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$7(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "ip",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$7(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "jwt",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$7(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "cidr",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "base64",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "base64url",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$7.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$7.invalid_string,
      ...errorUtil$7.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString10({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$7.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$7.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$7.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$7.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$7.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$7.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$7.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$7.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$7.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$7.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$7.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$7.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$7.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (options == null ? void 0 : options.offset) ?? false,
      local: (options == null ? void 0 : options.local) ?? false,
      ...errorUtil$7.errToObj(options == null ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      ...errorUtil$7.errToObj(options == null ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$7.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$7.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position,
      ...errorUtil$7.errToObj(options == null ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$7.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$7.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$7.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$7.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$7.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$7.errToObj(message));
  }
  trim() {
    return new ZodString10({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString10({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString10({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$7.create = (params) => {
  return new ZodString$7({
    checks: [],
    typeName: ZodFirstPartyTypeKind$7.ZodString,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$7(params)
  });
};
function floatSafeRemainder$7(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
let ZodNumber$7 = class ZodNumber10 extends ZodType$7 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx2, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.number,
        received: ctx2.parsedType
      });
      return INVALID$7;
    }
    let ctx = void 0;
    const status = new ParseStatus$7();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$7.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$7(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$7.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$7.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$7.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$7.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$7.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber10({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$7.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber10({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$7.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$7.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$7.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$7.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$7.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$7.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$7.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$7.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$7.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$7.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$7.create = (params) => {
  return new ZodNumber$7({
    checks: [],
    typeName: ZodFirstPartyTypeKind$7.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$7(params)
  });
};
let ZodBigInt$7 = class ZodBigInt10 extends ZodType$7 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$7();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$7.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$7(ctx, {
      code: ZodIssueCode$7.invalid_type,
      expected: ZodParsedType$7.bigint,
      received: ctx.parsedType
    });
    return INVALID$7;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$7.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$7.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$7.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$7.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt10({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$7.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt10({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$7.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$7.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$7.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$7.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$7.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$7.create = (params) => {
  return new ZodBigInt$7({
    checks: [],
    typeName: ZodFirstPartyTypeKind$7.ZodBigInt,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$7(params)
  });
};
let ZodBoolean$7 = class ZodBoolean10 extends ZodType$7 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.boolean,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    return OK$7(input.data);
  }
};
ZodBoolean$7.create = (params) => {
  return new ZodBoolean$7({
    typeName: ZodFirstPartyTypeKind$7.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$7(params)
  });
};
let ZodDate$7 = class ZodDate10 extends ZodType$7 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx2, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.date,
        received: ctx2.parsedType
      });
      return INVALID$7;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx2, {
        code: ZodIssueCode$7.invalid_date
      });
      return INVALID$7;
    }
    const status = new ParseStatus$7();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$7.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate10({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$7.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$7.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$7.create = (params) => {
  return new ZodDate$7({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$7.ZodDate,
    ...processCreateParams$7(params)
  });
};
let ZodSymbol$7 = class ZodSymbol10 extends ZodType$7 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.symbol,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    return OK$7(input.data);
  }
};
ZodSymbol$7.create = (params) => {
  return new ZodSymbol$7({
    typeName: ZodFirstPartyTypeKind$7.ZodSymbol,
    ...processCreateParams$7(params)
  });
};
let ZodUndefined$7 = class ZodUndefined10 extends ZodType$7 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.undefined,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    return OK$7(input.data);
  }
};
ZodUndefined$7.create = (params) => {
  return new ZodUndefined$7({
    typeName: ZodFirstPartyTypeKind$7.ZodUndefined,
    ...processCreateParams$7(params)
  });
};
let ZodNull$7 = class ZodNull10 extends ZodType$7 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.null,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    return OK$7(input.data);
  }
};
ZodNull$7.create = (params) => {
  return new ZodNull$7({
    typeName: ZodFirstPartyTypeKind$7.ZodNull,
    ...processCreateParams$7(params)
  });
};
let ZodAny$7 = class ZodAny10 extends ZodType$7 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$7(input.data);
  }
};
ZodAny$7.create = (params) => {
  return new ZodAny$7({
    typeName: ZodFirstPartyTypeKind$7.ZodAny,
    ...processCreateParams$7(params)
  });
};
let ZodUnknown$7 = class ZodUnknown10 extends ZodType$7 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$7(input.data);
  }
};
ZodUnknown$7.create = (params) => {
  return new ZodUnknown$7({
    typeName: ZodFirstPartyTypeKind$7.ZodUnknown,
    ...processCreateParams$7(params)
  });
};
let ZodNever$7 = class ZodNever10 extends ZodType$7 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$7(ctx, {
      code: ZodIssueCode$7.invalid_type,
      expected: ZodParsedType$7.never,
      received: ctx.parsedType
    });
    return INVALID$7;
  }
};
ZodNever$7.create = (params) => {
  return new ZodNever$7({
    typeName: ZodFirstPartyTypeKind$7.ZodNever,
    ...processCreateParams$7(params)
  });
};
let ZodVoid$7 = class ZodVoid10 extends ZodType$7 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.void,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    return OK$7(input.data);
  }
};
ZodVoid$7.create = (params) => {
  return new ZodVoid$7({
    typeName: ZodFirstPartyTypeKind$7.ZodVoid,
    ...processCreateParams$7(params)
  });
};
let ZodArray$7 = class ZodArray10 extends ZodType$7 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType$7.array) {
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.array,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$7(ctx, {
          code: tooBig ? ZodIssueCode$7.too_big : ZodIssueCode$7.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext$7(ctx, {
          code: ZodIssueCode$7.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext$7(ctx, {
          code: ZodIssueCode$7.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath$7(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$7.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath$7(ctx, item, ctx.path, i));
    });
    return ParseStatus$7.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray10({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$7.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray10({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$7.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray10({
      ...this._def,
      exactLength: { value: len, message: errorUtil$7.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$7.create = (schema, params) => {
  return new ZodArray$7({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$7.ZodArray,
    ...processCreateParams$7(params)
  });
};
function deepPartialify$7(schema) {
  if (schema instanceof ZodObject$7) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$7.create(deepPartialify$7(fieldSchema));
    }
    return new ZodObject$7({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$7) {
    return new ZodArray$7({
      ...schema._def,
      type: deepPartialify$7(schema.element)
    });
  } else if (schema instanceof ZodOptional$7) {
    return ZodOptional$7.create(deepPartialify$7(schema.unwrap()));
  } else if (schema instanceof ZodNullable$7) {
    return ZodNullable$7.create(deepPartialify$7(schema.unwrap()));
  } else if (schema instanceof ZodTuple$7) {
    return ZodTuple$7.create(schema.items.map((item) => deepPartialify$7(item)));
  } else {
    return schema;
  }
}
let ZodObject$7 = class ZodObject10 extends ZodType$7 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$7.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx2, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.object,
        received: ctx2.parsedType
      });
      return INVALID$7;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$7 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$7(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$7) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$7(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$7.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$7.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$7.errToObj;
    return new ZodObject10({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          var _a, _b;
          const defaultError = ((_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue2, ctx).message) ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil$7.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject10({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject10({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject10({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject10({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$7.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject10({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util$7.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject10({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util$7.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject10({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$7(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util$7.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject10({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util$7.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$7) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject10({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$7(util$7.objectKeys(this.shape));
  }
};
ZodObject$7.create = (shape, params) => {
  return new ZodObject$7({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$7.create(),
    typeName: ZodFirstPartyTypeKind$7.ZodObject,
    ...processCreateParams$7(params)
  });
};
ZodObject$7.strictCreate = (shape, params) => {
  return new ZodObject$7({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$7.create(),
    typeName: ZodFirstPartyTypeKind$7.ZodObject,
    ...processCreateParams$7(params)
  });
};
ZodObject$7.lazycreate = (shape, params) => {
  return new ZodObject$7({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$7.create(),
    typeName: ZodFirstPartyTypeKind$7.ZodObject,
    ...processCreateParams$7(params)
  });
};
let ZodUnion$7 = class ZodUnion10 extends ZodType$7 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$7(result.ctx.common.issues));
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_union,
        unionErrors
      });
      return INVALID$7;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$7(issues2));
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_union,
        unionErrors
      });
      return INVALID$7;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$7.create = (types, params) => {
  return new ZodUnion$7({
    options: types,
    typeName: ZodFirstPartyTypeKind$7.ZodUnion,
    ...processCreateParams$7(params)
  });
};
function mergeValues$7(a, b) {
  const aType = getParsedType$7(a);
  const bType = getParsedType$7(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$7.object && bType === ZodParsedType$7.object) {
    const bKeys = util$7.objectKeys(b);
    const sharedKeys = util$7.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$7(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$7.array && bType === ZodParsedType$7.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$7(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$7.date && bType === ZodParsedType$7.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$7 = class ZodIntersection10 extends ZodType$7 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$7(parsedLeft) || isAborted$7(parsedRight)) {
        return INVALID$7;
      }
      const merged = mergeValues$7(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$7(ctx, {
          code: ZodIssueCode$7.invalid_intersection_types
        });
        return INVALID$7;
      }
      if (isDirty$7(parsedLeft) || isDirty$7(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$7.create = (left, right, params) => {
  return new ZodIntersection$7({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$7.ZodIntersection,
    ...processCreateParams$7(params)
  });
};
let ZodTuple$7 = class ZodTuple10 extends ZodType$7 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$7.array) {
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.array,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$7;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$7(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$7.mergeArray(status, results);
      });
    } else {
      return ParseStatus$7.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple10({
      ...this._def,
      rest
    });
  }
};
ZodTuple$7.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$7({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$7.ZodTuple,
    rest: null,
    ...processCreateParams$7(params)
  });
};
let ZodMap$7 = class ZodMap10 extends ZodType$7 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$7.map) {
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.map,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$7(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$7(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$7;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$7;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$7.create = (keyType, valueType, params) => {
  return new ZodMap$7({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$7.ZodMap,
    ...processCreateParams$7(params)
  });
};
let ZodSet$7 = class ZodSet10 extends ZodType$7 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$7.set) {
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.set,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext$7(ctx, {
          code: ZodIssueCode$7.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext$7(ctx, {
          code: ZodIssueCode$7.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID$7;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$7(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet10({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$7.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet10({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$7.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$7.create = (valueType, params) => {
  return new ZodSet$7({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$7.ZodSet,
    ...processCreateParams$7(params)
  });
};
let ZodLazy$7 = class ZodLazy10 extends ZodType$7 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$7.create = (getter, params) => {
  return new ZodLazy$7({
    getter,
    typeName: ZodFirstPartyTypeKind$7.ZodLazy,
    ...processCreateParams$7(params)
  });
};
let ZodLiteral$7 = class ZodLiteral10 extends ZodType$7 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx, {
        received: ctx.data,
        code: ZodIssueCode$7.invalid_literal,
        expected: this._def.value
      });
      return INVALID$7;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$7.create = (value, params) => {
  return new ZodLiteral$7({
    value,
    typeName: ZodFirstPartyTypeKind$7.ZodLiteral,
    ...processCreateParams$7(params)
  });
};
function createZodEnum$7(values, params) {
  return new ZodEnum$7({
    values,
    typeName: ZodFirstPartyTypeKind$7.ZodEnum,
    ...processCreateParams$7(params)
  });
}
let ZodEnum$7 = class ZodEnum10 extends ZodType$7 {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$7(ctx, {
        expected: util$7.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$7.invalid_type
      });
      return INVALID$7;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$7(ctx, {
        received: ctx.data,
        code: ZodIssueCode$7.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$7;
    }
    return OK$7(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum10.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum10.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum$7.create = createZodEnum$7;
let ZodNativeEnum$7 = class ZodNativeEnum10 extends ZodType$7 {
  _parse(input) {
    const nativeEnumValues = util$7.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$7.string && ctx.parsedType !== ZodParsedType$7.number) {
      const expectedValues = util$7.objectValues(nativeEnumValues);
      addIssueToContext$7(ctx, {
        expected: util$7.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$7.invalid_type
      });
      return INVALID$7;
    }
    if (!this._cache) {
      this._cache = new Set(util$7.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util$7.objectValues(nativeEnumValues);
      addIssueToContext$7(ctx, {
        received: ctx.data,
        code: ZodIssueCode$7.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$7;
    }
    return OK$7(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum$7.create = (values, params) => {
  return new ZodNativeEnum$7({
    values,
    typeName: ZodFirstPartyTypeKind$7.ZodNativeEnum,
    ...processCreateParams$7(params)
  });
};
let ZodPromise$7 = class ZodPromise10 extends ZodType$7 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$7.promise && ctx.common.async === false) {
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.promise,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    const promisified = ctx.parsedType === ZodParsedType$7.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$7(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$7.create = (schema, params) => {
  return new ZodPromise$7({
    type: schema,
    typeName: ZodFirstPartyTypeKind$7.ZodPromise,
    ...processCreateParams$7(params)
  });
};
let ZodEffects$7 = class ZodEffects10 extends ZodType$7 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$7.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$7(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$7;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$7;
          if (result.status === "dirty")
            return DIRTY$7(result.value);
          if (status.value === "dirty")
            return DIRTY$7(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$7;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$7;
        if (result.status === "dirty")
          return DIRTY$7(result.value);
        if (status.value === "dirty")
          return DIRTY$7(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$7;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$7;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$7(base))
          return INVALID$7;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$7(base))
            return INVALID$7;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util$7.assertNever(effect);
  }
};
ZodEffects$7.create = (schema, effect, params) => {
  return new ZodEffects$7({
    schema,
    typeName: ZodFirstPartyTypeKind$7.ZodEffects,
    effect,
    ...processCreateParams$7(params)
  });
};
ZodEffects$7.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$7({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$7.ZodEffects,
    ...processCreateParams$7(params)
  });
};
let ZodOptional$7 = class ZodOptional10 extends ZodType$7 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$7.undefined) {
      return OK$7(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$7.create = (type, params) => {
  return new ZodOptional$7({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$7.ZodOptional,
    ...processCreateParams$7(params)
  });
};
let ZodNullable$7 = class ZodNullable10 extends ZodType$7 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$7.null) {
      return OK$7(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$7.create = (type, params) => {
  return new ZodNullable$7({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$7.ZodNullable,
    ...processCreateParams$7(params)
  });
};
let ZodDefault$7 = class ZodDefault10 extends ZodType$7 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$7.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$7.create = (type, params) => {
  return new ZodDefault$7({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$7.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$7(params)
  });
};
let ZodCatch$7 = class ZodCatch10 extends ZodType$7 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$7(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$7(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$7(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$7.create = (type, params) => {
  return new ZodCatch$7({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$7.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$7(params)
  });
};
let ZodNaN$7 = class ZodNaN10 extends ZodType$7 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.nan,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$7.create = (params) => {
  return new ZodNaN$7({
    typeName: ZodFirstPartyTypeKind$7.ZodNaN,
    ...processCreateParams$7(params)
  });
};
let ZodBranded$7 = class ZodBranded10 extends ZodType$7 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$7 = class ZodPipeline10 extends ZodType$7 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$7;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$7(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$7;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline10({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$7.ZodPipeline
    });
  }
};
let ZodReadonly$7 = class ZodReadonly10 extends ZodType$7 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$7(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$7(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$7.create = (type, params) => {
  return new ZodReadonly$7({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$7.ZodReadonly,
    ...processCreateParams$7(params)
  });
};
var ZodFirstPartyTypeKind$7;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$7 || (ZodFirstPartyTypeKind$7 = {}));
const numberType$6 = ZodNumber$7.create;
ZodNever$7.create;
ZodArray$7.create;
const objectType$7 = ZodObject$7.create;
ZodUnion$7.create;
ZodIntersection$7.create;
ZodTuple$7.create;
ZodEnum$7.create;
ZodPromise$7.create;
ZodOptional$7.create;
ZodNullable$7.create;
const DisplaceOptionsSchema = objectType$7({
  /** the source Jimp instance */
  map: JimpClassSchema,
  /** the maximum displacement value */
  offset: numberType$6()
});
const methods$9 = {
  /**
   * Displaces the image based on the provided displacement map
   * @param map the source Jimp instance
   * @param offset
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   * const map = await Jimp.read("test/map.png");
   *
   * image.displace(map, 10);
   * ```
   */
  displace(image, options) {
    const { map, offset } = DisplaceOptionsSchema.parse(options);
    const source = clone(image);
    image.scan((x2, y2, idx) => {
      let displacement = map.bitmap.data[idx] / 256 * offset;
      displacement = Math.round(displacement);
      const ids = image.getPixelIndex(x2 + displacement, y2);
      image.bitmap.data[ids] = source.bitmap.data[idx];
      image.bitmap.data[ids + 1] = source.bitmap.data[idx + 1];
      image.bitmap.data[ids + 2] = source.bitmap.data[idx + 2];
    });
    return image;
  }
};
const methods$8 = {
  /**
   * Apply a ordered dithering effect.
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.dither();
   * ```
   */
  dither(image) {
    const rgb565Matrix = [
      1,
      9,
      3,
      11,
      13,
      5,
      15,
      7,
      4,
      12,
      2,
      10,
      16,
      8,
      14,
      6
    ];
    image.scan((x2, y2, idx) => {
      const thresholdId = ((y2 & 3) << 2) + x2 % 4;
      const dither = rgb565Matrix[thresholdId];
      image.bitmap.data[idx] = Math.min(image.bitmap.data[idx] + dither, 255);
      image.bitmap.data[idx + 1] = Math.min(image.bitmap.data[idx + 1] + dither, 255);
      image.bitmap.data[idx + 2] = Math.min(image.bitmap.data[idx + 2] + dither, 255);
    });
    return image;
  }
};
var util$6;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$6 || (util$6 = {}));
var objectUtil$6;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$6 || (objectUtil$6 = {}));
const ZodParsedType$6 = util$6.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$6 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$6.undefined;
    case "string":
      return ZodParsedType$6.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType$6.nan : ZodParsedType$6.number;
    case "boolean":
      return ZodParsedType$6.boolean;
    case "function":
      return ZodParsedType$6.function;
    case "bigint":
      return ZodParsedType$6.bigint;
    case "symbol":
      return ZodParsedType$6.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$6.array;
      }
      if (data === null) {
        return ZodParsedType$6.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$6.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$6.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$6.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$6.date;
      }
      return ZodParsedType$6.object;
    default:
      return ZodParsedType$6.unknown;
  }
};
const ZodIssueCode$6 = util$6.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
let ZodError$6 = class ZodError11 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue2 of error.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError11)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$6.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$6.create = (issues) => {
  const error = new ZodError$6(issues);
  return error;
};
const errorMap$6 = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode$6.invalid_type:
      if (issue2.received === ZodParsedType$6.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode$6.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util$6.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$6.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$6.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode$6.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$6.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$6.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode$6.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$6.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode$6.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$6.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$6.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$6.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util$6.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$6.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$6.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$6.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$6.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$6.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode$6.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$6.assertNever(issue2);
  }
  return { message };
};
let overrideErrorMap$6 = errorMap$6;
function getErrorMap$6() {
  return overrideErrorMap$6;
}
const makeIssue$6 = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext$6(ctx, issueData) {
  const overrideMap = getErrorMap$6();
  const issue2 = makeIssue$6({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$6 ? void 0 : errorMap$6
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue2);
}
let ParseStatus$6 = class ParseStatus11 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$6;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus11.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$6;
      if (value.status === "aborted")
        return INVALID$6;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$6 = Object.freeze({
  status: "aborted"
});
const DIRTY$6 = (value) => ({ status: "dirty", value });
const OK$6 = (value) => ({ status: "valid", value });
const isAborted$6 = (x2) => x2.status === "aborted";
const isDirty$6 = (x2) => x2.status === "dirty";
const isValid$6 = (x2) => x2.status === "valid";
const isAsync$6 = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil$6;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil$6 || (errorUtil$6 = {}));
let ParseInputLazyPath$6 = class ParseInputLazyPath11 {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$6 = (ctx, result) => {
  if (isValid$6(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$6(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$6(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$6 = class ZodType11 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$6(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$6(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$6(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$6(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$6(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: (params == null ? void 0 : params.async) ?? false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$6(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$6(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$6(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$6(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$6(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$6(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$6(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$6(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$6.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$6({
      schema: this,
      typeName: ZodFirstPartyTypeKind$6.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$6.create(this, this._def);
  }
  nullable() {
    return ZodNullable$6.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$6.create(this);
  }
  promise() {
    return ZodPromise$6.create(this, this._def);
  }
  or(option) {
    return ZodUnion$6.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$6.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects$6({
      ...processCreateParams$6(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$6.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault$6({
      ...processCreateParams$6(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$6.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$6({
      typeName: ZodFirstPartyTypeKind$6.ZodBranded,
      type: this,
      ...processCreateParams$6(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch$6({
      ...processCreateParams$6(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$6.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$6.create(this, target);
  }
  readonly() {
    return ZodReadonly$6.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$6 = /^c[^\s-]{8,}$/i;
const cuid2Regex$6 = /^[0-9a-z]+$/;
const ulidRegex$6 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$6 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$6 = /^[a-z0-9_-]{21}$/i;
const jwtRegex$6 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$6 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$6 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$6 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$6;
const ipv4Regex$6 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$6 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$6 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$6 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$6 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$6 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$6 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$6 = new RegExp(`^${dateRegexSource$6}$`);
function timeRegexSource$6(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex$6(args) {
  return new RegExp(`^${timeRegexSource$6(args)}$`);
}
function datetimeRegex$6(args) {
  let regex = `${dateRegexSource$6}T${timeRegexSource$6(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$6(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex$6.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex$6.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$6(jwt, alg) {
  if (!jwtRegex$6.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr$6(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex$6.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex$6.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$6 = class ZodString11 extends ZodType$6 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx2, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.string,
        received: ctx2.parsedType
      });
      return INVALID$6;
    }
    const status = new ParseStatus$6();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$6(ctx, {
              code: ZodIssueCode$6.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$6(ctx, {
              code: ZodIssueCode$6.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "email",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$6) {
          emojiRegex$6 = new RegExp(_emojiRegex$6, "u");
        }
        if (!emojiRegex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "emoji",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "uuid",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "cuid",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "ulid",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "url",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "regex",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$6(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$6;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$6(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "duration",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$6(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "ip",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$6(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "jwt",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$6(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "cidr",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "base64",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "base64url",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$6.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$6.invalid_string,
      ...errorUtil$6.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString11({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$6.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$6.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$6.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$6.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$6.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$6.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$6.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$6.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$6.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$6.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$6.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$6.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$6.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (options == null ? void 0 : options.offset) ?? false,
      local: (options == null ? void 0 : options.local) ?? false,
      ...errorUtil$6.errToObj(options == null ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      ...errorUtil$6.errToObj(options == null ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$6.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$6.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position,
      ...errorUtil$6.errToObj(options == null ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$6.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$6.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$6.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$6.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$6.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$6.errToObj(message));
  }
  trim() {
    return new ZodString11({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString11({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString11({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$6.create = (params) => {
  return new ZodString$6({
    checks: [],
    typeName: ZodFirstPartyTypeKind$6.ZodString,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$6(params)
  });
};
function floatSafeRemainder$6(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
let ZodNumber$6 = class ZodNumber11 extends ZodType$6 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx2, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.number,
        received: ctx2.parsedType
      });
      return INVALID$6;
    }
    let ctx = void 0;
    const status = new ParseStatus$6();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$6.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$6(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$6.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$6.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$6.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$6.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$6.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber11({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$6.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber11({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$6.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$6.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$6.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$6.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$6.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$6.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$6.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$6.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$6.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$6.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$6.create = (params) => {
  return new ZodNumber$6({
    checks: [],
    typeName: ZodFirstPartyTypeKind$6.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$6(params)
  });
};
let ZodBigInt$6 = class ZodBigInt11 extends ZodType$6 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$6();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$6.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$6(ctx, {
      code: ZodIssueCode$6.invalid_type,
      expected: ZodParsedType$6.bigint,
      received: ctx.parsedType
    });
    return INVALID$6;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$6.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$6.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$6.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$6.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt11({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$6.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt11({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$6.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$6.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$6.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$6.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$6.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$6.create = (params) => {
  return new ZodBigInt$6({
    checks: [],
    typeName: ZodFirstPartyTypeKind$6.ZodBigInt,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$6(params)
  });
};
let ZodBoolean$6 = class ZodBoolean11 extends ZodType$6 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.boolean,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    return OK$6(input.data);
  }
};
ZodBoolean$6.create = (params) => {
  return new ZodBoolean$6({
    typeName: ZodFirstPartyTypeKind$6.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$6(params)
  });
};
let ZodDate$6 = class ZodDate11 extends ZodType$6 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx2, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.date,
        received: ctx2.parsedType
      });
      return INVALID$6;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx2, {
        code: ZodIssueCode$6.invalid_date
      });
      return INVALID$6;
    }
    const status = new ParseStatus$6();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$6.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate11({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$6.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$6.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$6.create = (params) => {
  return new ZodDate$6({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$6.ZodDate,
    ...processCreateParams$6(params)
  });
};
let ZodSymbol$6 = class ZodSymbol11 extends ZodType$6 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.symbol,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    return OK$6(input.data);
  }
};
ZodSymbol$6.create = (params) => {
  return new ZodSymbol$6({
    typeName: ZodFirstPartyTypeKind$6.ZodSymbol,
    ...processCreateParams$6(params)
  });
};
let ZodUndefined$6 = class ZodUndefined11 extends ZodType$6 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.undefined,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    return OK$6(input.data);
  }
};
ZodUndefined$6.create = (params) => {
  return new ZodUndefined$6({
    typeName: ZodFirstPartyTypeKind$6.ZodUndefined,
    ...processCreateParams$6(params)
  });
};
let ZodNull$6 = class ZodNull11 extends ZodType$6 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.null,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    return OK$6(input.data);
  }
};
ZodNull$6.create = (params) => {
  return new ZodNull$6({
    typeName: ZodFirstPartyTypeKind$6.ZodNull,
    ...processCreateParams$6(params)
  });
};
let ZodAny$6 = class ZodAny11 extends ZodType$6 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$6(input.data);
  }
};
ZodAny$6.create = (params) => {
  return new ZodAny$6({
    typeName: ZodFirstPartyTypeKind$6.ZodAny,
    ...processCreateParams$6(params)
  });
};
let ZodUnknown$6 = class ZodUnknown11 extends ZodType$6 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$6(input.data);
  }
};
ZodUnknown$6.create = (params) => {
  return new ZodUnknown$6({
    typeName: ZodFirstPartyTypeKind$6.ZodUnknown,
    ...processCreateParams$6(params)
  });
};
let ZodNever$6 = class ZodNever11 extends ZodType$6 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$6(ctx, {
      code: ZodIssueCode$6.invalid_type,
      expected: ZodParsedType$6.never,
      received: ctx.parsedType
    });
    return INVALID$6;
  }
};
ZodNever$6.create = (params) => {
  return new ZodNever$6({
    typeName: ZodFirstPartyTypeKind$6.ZodNever,
    ...processCreateParams$6(params)
  });
};
let ZodVoid$6 = class ZodVoid11 extends ZodType$6 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.void,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    return OK$6(input.data);
  }
};
ZodVoid$6.create = (params) => {
  return new ZodVoid$6({
    typeName: ZodFirstPartyTypeKind$6.ZodVoid,
    ...processCreateParams$6(params)
  });
};
let ZodArray$6 = class ZodArray11 extends ZodType$6 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType$6.array) {
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.array,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$6(ctx, {
          code: tooBig ? ZodIssueCode$6.too_big : ZodIssueCode$6.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext$6(ctx, {
          code: ZodIssueCode$6.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext$6(ctx, {
          code: ZodIssueCode$6.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath$6(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$6.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath$6(ctx, item, ctx.path, i));
    });
    return ParseStatus$6.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray11({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$6.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray11({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$6.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray11({
      ...this._def,
      exactLength: { value: len, message: errorUtil$6.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$6.create = (schema, params) => {
  return new ZodArray$6({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$6.ZodArray,
    ...processCreateParams$6(params)
  });
};
function deepPartialify$6(schema) {
  if (schema instanceof ZodObject$6) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$6.create(deepPartialify$6(fieldSchema));
    }
    return new ZodObject$6({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$6) {
    return new ZodArray$6({
      ...schema._def,
      type: deepPartialify$6(schema.element)
    });
  } else if (schema instanceof ZodOptional$6) {
    return ZodOptional$6.create(deepPartialify$6(schema.unwrap()));
  } else if (schema instanceof ZodNullable$6) {
    return ZodNullable$6.create(deepPartialify$6(schema.unwrap()));
  } else if (schema instanceof ZodTuple$6) {
    return ZodTuple$6.create(schema.items.map((item) => deepPartialify$6(item)));
  } else {
    return schema;
  }
}
let ZodObject$6 = class ZodObject11 extends ZodType$6 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$6.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx2, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.object,
        received: ctx2.parsedType
      });
      return INVALID$6;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$6 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$6(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$6) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$6(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$6.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$6.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$6.errToObj;
    return new ZodObject11({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          var _a, _b;
          const defaultError = ((_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue2, ctx).message) ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil$6.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject11({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject11({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject11({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject11({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$6.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject11({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util$6.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject11({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util$6.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject11({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$6(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util$6.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject11({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util$6.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$6) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject11({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$6(util$6.objectKeys(this.shape));
  }
};
ZodObject$6.create = (shape, params) => {
  return new ZodObject$6({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$6.create(),
    typeName: ZodFirstPartyTypeKind$6.ZodObject,
    ...processCreateParams$6(params)
  });
};
ZodObject$6.strictCreate = (shape, params) => {
  return new ZodObject$6({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$6.create(),
    typeName: ZodFirstPartyTypeKind$6.ZodObject,
    ...processCreateParams$6(params)
  });
};
ZodObject$6.lazycreate = (shape, params) => {
  return new ZodObject$6({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$6.create(),
    typeName: ZodFirstPartyTypeKind$6.ZodObject,
    ...processCreateParams$6(params)
  });
};
let ZodUnion$6 = class ZodUnion11 extends ZodType$6 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$6(result.ctx.common.issues));
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_union,
        unionErrors
      });
      return INVALID$6;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$6(issues2));
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_union,
        unionErrors
      });
      return INVALID$6;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$6.create = (types, params) => {
  return new ZodUnion$6({
    options: types,
    typeName: ZodFirstPartyTypeKind$6.ZodUnion,
    ...processCreateParams$6(params)
  });
};
function mergeValues$6(a, b) {
  const aType = getParsedType$6(a);
  const bType = getParsedType$6(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$6.object && bType === ZodParsedType$6.object) {
    const bKeys = util$6.objectKeys(b);
    const sharedKeys = util$6.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$6(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$6.array && bType === ZodParsedType$6.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$6(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$6.date && bType === ZodParsedType$6.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$6 = class ZodIntersection11 extends ZodType$6 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$6(parsedLeft) || isAborted$6(parsedRight)) {
        return INVALID$6;
      }
      const merged = mergeValues$6(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$6(ctx, {
          code: ZodIssueCode$6.invalid_intersection_types
        });
        return INVALID$6;
      }
      if (isDirty$6(parsedLeft) || isDirty$6(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$6.create = (left, right, params) => {
  return new ZodIntersection$6({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$6.ZodIntersection,
    ...processCreateParams$6(params)
  });
};
let ZodTuple$6 = class ZodTuple11 extends ZodType$6 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$6.array) {
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.array,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$6;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$6(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$6.mergeArray(status, results);
      });
    } else {
      return ParseStatus$6.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple11({
      ...this._def,
      rest
    });
  }
};
ZodTuple$6.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$6({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$6.ZodTuple,
    rest: null,
    ...processCreateParams$6(params)
  });
};
let ZodMap$6 = class ZodMap11 extends ZodType$6 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$6.map) {
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.map,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$6(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$6(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$6;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$6;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$6.create = (keyType, valueType, params) => {
  return new ZodMap$6({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$6.ZodMap,
    ...processCreateParams$6(params)
  });
};
let ZodSet$6 = class ZodSet11 extends ZodType$6 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$6.set) {
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.set,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext$6(ctx, {
          code: ZodIssueCode$6.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext$6(ctx, {
          code: ZodIssueCode$6.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID$6;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$6(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet11({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$6.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet11({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$6.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$6.create = (valueType, params) => {
  return new ZodSet$6({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$6.ZodSet,
    ...processCreateParams$6(params)
  });
};
let ZodLazy$6 = class ZodLazy11 extends ZodType$6 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$6.create = (getter, params) => {
  return new ZodLazy$6({
    getter,
    typeName: ZodFirstPartyTypeKind$6.ZodLazy,
    ...processCreateParams$6(params)
  });
};
let ZodLiteral$6 = class ZodLiteral11 extends ZodType$6 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx, {
        received: ctx.data,
        code: ZodIssueCode$6.invalid_literal,
        expected: this._def.value
      });
      return INVALID$6;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$6.create = (value, params) => {
  return new ZodLiteral$6({
    value,
    typeName: ZodFirstPartyTypeKind$6.ZodLiteral,
    ...processCreateParams$6(params)
  });
};
function createZodEnum$6(values, params) {
  return new ZodEnum$6({
    values,
    typeName: ZodFirstPartyTypeKind$6.ZodEnum,
    ...processCreateParams$6(params)
  });
}
let ZodEnum$6 = class ZodEnum11 extends ZodType$6 {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$6(ctx, {
        expected: util$6.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$6.invalid_type
      });
      return INVALID$6;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$6(ctx, {
        received: ctx.data,
        code: ZodIssueCode$6.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$6;
    }
    return OK$6(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum11.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum11.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum$6.create = createZodEnum$6;
let ZodNativeEnum$6 = class ZodNativeEnum11 extends ZodType$6 {
  _parse(input) {
    const nativeEnumValues = util$6.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$6.string && ctx.parsedType !== ZodParsedType$6.number) {
      const expectedValues = util$6.objectValues(nativeEnumValues);
      addIssueToContext$6(ctx, {
        expected: util$6.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$6.invalid_type
      });
      return INVALID$6;
    }
    if (!this._cache) {
      this._cache = new Set(util$6.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util$6.objectValues(nativeEnumValues);
      addIssueToContext$6(ctx, {
        received: ctx.data,
        code: ZodIssueCode$6.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$6;
    }
    return OK$6(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum$6.create = (values, params) => {
  return new ZodNativeEnum$6({
    values,
    typeName: ZodFirstPartyTypeKind$6.ZodNativeEnum,
    ...processCreateParams$6(params)
  });
};
let ZodPromise$6 = class ZodPromise11 extends ZodType$6 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$6.promise && ctx.common.async === false) {
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.promise,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    const promisified = ctx.parsedType === ZodParsedType$6.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$6(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$6.create = (schema, params) => {
  return new ZodPromise$6({
    type: schema,
    typeName: ZodFirstPartyTypeKind$6.ZodPromise,
    ...processCreateParams$6(params)
  });
};
let ZodEffects$6 = class ZodEffects11 extends ZodType$6 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$6.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$6(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$6;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$6;
          if (result.status === "dirty")
            return DIRTY$6(result.value);
          if (status.value === "dirty")
            return DIRTY$6(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$6;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$6;
        if (result.status === "dirty")
          return DIRTY$6(result.value);
        if (status.value === "dirty")
          return DIRTY$6(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$6;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$6;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$6(base))
          return INVALID$6;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$6(base))
            return INVALID$6;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util$6.assertNever(effect);
  }
};
ZodEffects$6.create = (schema, effect, params) => {
  return new ZodEffects$6({
    schema,
    typeName: ZodFirstPartyTypeKind$6.ZodEffects,
    effect,
    ...processCreateParams$6(params)
  });
};
ZodEffects$6.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$6({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$6.ZodEffects,
    ...processCreateParams$6(params)
  });
};
let ZodOptional$6 = class ZodOptional11 extends ZodType$6 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$6.undefined) {
      return OK$6(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$6.create = (type, params) => {
  return new ZodOptional$6({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$6.ZodOptional,
    ...processCreateParams$6(params)
  });
};
let ZodNullable$6 = class ZodNullable11 extends ZodType$6 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$6.null) {
      return OK$6(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$6.create = (type, params) => {
  return new ZodNullable$6({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$6.ZodNullable,
    ...processCreateParams$6(params)
  });
};
let ZodDefault$6 = class ZodDefault11 extends ZodType$6 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$6.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$6.create = (type, params) => {
  return new ZodDefault$6({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$6.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$6(params)
  });
};
let ZodCatch$6 = class ZodCatch11 extends ZodType$6 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$6(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$6(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$6(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$6.create = (type, params) => {
  return new ZodCatch$6({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$6.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$6(params)
  });
};
let ZodNaN$6 = class ZodNaN11 extends ZodType$6 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.nan,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$6.create = (params) => {
  return new ZodNaN$6({
    typeName: ZodFirstPartyTypeKind$6.ZodNaN,
    ...processCreateParams$6(params)
  });
};
let ZodBranded$6 = class ZodBranded11 extends ZodType$6 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$6 = class ZodPipeline11 extends ZodType$6 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$6;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$6(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$6;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline11({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$6.ZodPipeline
    });
  }
};
let ZodReadonly$6 = class ZodReadonly11 extends ZodType$6 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$6(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$6(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$6.create = (type, params) => {
  return new ZodReadonly$6({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$6.ZodReadonly,
    ...processCreateParams$6(params)
  });
};
var ZodFirstPartyTypeKind$6;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$6 || (ZodFirstPartyTypeKind$6 = {}));
const numberType$5 = ZodNumber$6.create;
ZodNever$6.create;
ZodArray$6.create;
const objectType$6 = ZodObject$6.create;
ZodUnion$6.create;
ZodIntersection$6.create;
ZodTuple$6.create;
ZodEnum$6.create;
ZodPromise$6.create;
ZodOptional$6.create;
ZodNullable$6.create;
const FisheyeOptionsSchema = objectType$6({
  /** the radius of the circle */
  radius: numberType$5().min(0).optional()
});
const methods$7 = {
  /**
   * Adds a fisheye effect to the image.
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.fisheye();
   * ```
   */
  fisheye(image, options = {}) {
    const { radius = 2.5 } = FisheyeOptionsSchema.parse(options);
    const source = clone(image);
    const { width, height } = source.bitmap;
    source.scan((x2, y2) => {
      const hx = x2 / width;
      const hy = y2 / height;
      const rActual = Math.sqrt(Math.pow(hx - 0.5, 2) + Math.pow(hy - 0.5, 2));
      const rn = 2 * Math.pow(rActual, radius);
      const cosA = (hx - 0.5) / rActual;
      const sinA = (hy - 0.5) / rActual;
      const newX = Math.round((rn * cosA + 0.5) * width);
      const newY = Math.round((rn * sinA + 0.5) * height);
      const color = source.getPixelColor(newX, newY);
      image.setPixelColor(color, x2, y2);
    });
    image.setPixelColor(source.getPixelColor(width / 2, height / 2), width / 2, height / 2);
    return image;
  }
};
var util$5;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$5 || (util$5 = {}));
var objectUtil$5;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$5 || (objectUtil$5 = {}));
const ZodParsedType$5 = util$5.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$5 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$5.undefined;
    case "string":
      return ZodParsedType$5.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType$5.nan : ZodParsedType$5.number;
    case "boolean":
      return ZodParsedType$5.boolean;
    case "function":
      return ZodParsedType$5.function;
    case "bigint":
      return ZodParsedType$5.bigint;
    case "symbol":
      return ZodParsedType$5.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$5.array;
      }
      if (data === null) {
        return ZodParsedType$5.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$5.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$5.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$5.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$5.date;
      }
      return ZodParsedType$5.object;
    default:
      return ZodParsedType$5.unknown;
  }
};
const ZodIssueCode$5 = util$5.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
let ZodError$5 = class ZodError12 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue2 of error.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError12)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$5.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$5.create = (issues) => {
  const error = new ZodError$5(issues);
  return error;
};
const errorMap$5 = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode$5.invalid_type:
      if (issue2.received === ZodParsedType$5.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode$5.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util$5.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$5.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$5.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode$5.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$5.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$5.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode$5.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$5.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode$5.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$5.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$5.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$5.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util$5.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$5.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$5.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$5.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$5.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$5.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode$5.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$5.assertNever(issue2);
  }
  return { message };
};
let overrideErrorMap$5 = errorMap$5;
function getErrorMap$5() {
  return overrideErrorMap$5;
}
const makeIssue$5 = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext$5(ctx, issueData) {
  const overrideMap = getErrorMap$5();
  const issue2 = makeIssue$5({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$5 ? void 0 : errorMap$5
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue2);
}
let ParseStatus$5 = class ParseStatus12 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$5;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus12.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$5;
      if (value.status === "aborted")
        return INVALID$5;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$5 = Object.freeze({
  status: "aborted"
});
const DIRTY$5 = (value) => ({ status: "dirty", value });
const OK$5 = (value) => ({ status: "valid", value });
const isAborted$5 = (x2) => x2.status === "aborted";
const isDirty$5 = (x2) => x2.status === "dirty";
const isValid$5 = (x2) => x2.status === "valid";
const isAsync$5 = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil$5;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil$5 || (errorUtil$5 = {}));
let ParseInputLazyPath$5 = class ParseInputLazyPath12 {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$5 = (ctx, result) => {
  if (isValid$5(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$5(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$5(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$5 = class ZodType12 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$5(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$5(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$5(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$5(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$5(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: (params == null ? void 0 : params.async) ?? false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$5(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$5(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$5(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$5(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$5(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$5(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$5(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$5(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$5.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$5({
      schema: this,
      typeName: ZodFirstPartyTypeKind$5.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$5.create(this, this._def);
  }
  nullable() {
    return ZodNullable$5.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$5.create(this);
  }
  promise() {
    return ZodPromise$5.create(this, this._def);
  }
  or(option) {
    return ZodUnion$5.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$5.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects$5({
      ...processCreateParams$5(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$5.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault$5({
      ...processCreateParams$5(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$5.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$5({
      typeName: ZodFirstPartyTypeKind$5.ZodBranded,
      type: this,
      ...processCreateParams$5(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch$5({
      ...processCreateParams$5(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$5.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$5.create(this, target);
  }
  readonly() {
    return ZodReadonly$5.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$5 = /^c[^\s-]{8,}$/i;
const cuid2Regex$5 = /^[0-9a-z]+$/;
const ulidRegex$5 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$5 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$5 = /^[a-z0-9_-]{21}$/i;
const jwtRegex$5 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$5 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$5 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$5 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$5;
const ipv4Regex$5 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$5 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$5 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$5 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$5 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$5 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$5 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$5 = new RegExp(`^${dateRegexSource$5}$`);
function timeRegexSource$5(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex$5(args) {
  return new RegExp(`^${timeRegexSource$5(args)}$`);
}
function datetimeRegex$5(args) {
  let regex = `${dateRegexSource$5}T${timeRegexSource$5(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$5(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex$5.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex$5.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$5(jwt, alg) {
  if (!jwtRegex$5.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr$5(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex$5.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex$5.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$5 = class ZodString12 extends ZodType$5 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx2, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.string,
        received: ctx2.parsedType
      });
      return INVALID$5;
    }
    const status = new ParseStatus$5();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$5(ctx, {
              code: ZodIssueCode$5.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$5(ctx, {
              code: ZodIssueCode$5.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "email",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$5) {
          emojiRegex$5 = new RegExp(_emojiRegex$5, "u");
        }
        if (!emojiRegex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "emoji",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "uuid",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "cuid",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "ulid",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "url",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "regex",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$5(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$5;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$5(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "duration",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$5(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "ip",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$5(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "jwt",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$5(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "cidr",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "base64",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "base64url",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$5.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$5.invalid_string,
      ...errorUtil$5.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString12({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$5.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$5.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$5.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$5.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$5.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$5.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$5.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$5.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$5.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$5.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$5.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$5.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$5.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (options == null ? void 0 : options.offset) ?? false,
      local: (options == null ? void 0 : options.local) ?? false,
      ...errorUtil$5.errToObj(options == null ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      ...errorUtil$5.errToObj(options == null ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$5.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$5.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position,
      ...errorUtil$5.errToObj(options == null ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$5.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$5.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$5.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$5.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$5.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$5.errToObj(message));
  }
  trim() {
    return new ZodString12({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString12({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString12({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$5.create = (params) => {
  return new ZodString$5({
    checks: [],
    typeName: ZodFirstPartyTypeKind$5.ZodString,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$5(params)
  });
};
function floatSafeRemainder$5(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
let ZodNumber$5 = class ZodNumber12 extends ZodType$5 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx2, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.number,
        received: ctx2.parsedType
      });
      return INVALID$5;
    }
    let ctx = void 0;
    const status = new ParseStatus$5();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$5.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$5(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$5.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$5.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$5.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$5.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$5.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber12({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$5.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber12({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$5.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$5.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$5.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$5.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$5.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$5.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$5.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$5.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$5.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$5.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$5.create = (params) => {
  return new ZodNumber$5({
    checks: [],
    typeName: ZodFirstPartyTypeKind$5.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$5(params)
  });
};
let ZodBigInt$5 = class ZodBigInt12 extends ZodType$5 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$5();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$5.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$5(ctx, {
      code: ZodIssueCode$5.invalid_type,
      expected: ZodParsedType$5.bigint,
      received: ctx.parsedType
    });
    return INVALID$5;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$5.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$5.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$5.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$5.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt12({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$5.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt12({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$5.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$5.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$5.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$5.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$5.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$5.create = (params) => {
  return new ZodBigInt$5({
    checks: [],
    typeName: ZodFirstPartyTypeKind$5.ZodBigInt,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$5(params)
  });
};
let ZodBoolean$5 = class ZodBoolean12 extends ZodType$5 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.boolean,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    return OK$5(input.data);
  }
};
ZodBoolean$5.create = (params) => {
  return new ZodBoolean$5({
    typeName: ZodFirstPartyTypeKind$5.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$5(params)
  });
};
let ZodDate$5 = class ZodDate12 extends ZodType$5 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx2, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.date,
        received: ctx2.parsedType
      });
      return INVALID$5;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx2, {
        code: ZodIssueCode$5.invalid_date
      });
      return INVALID$5;
    }
    const status = new ParseStatus$5();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$5.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate12({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$5.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$5.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$5.create = (params) => {
  return new ZodDate$5({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$5.ZodDate,
    ...processCreateParams$5(params)
  });
};
let ZodSymbol$5 = class ZodSymbol12 extends ZodType$5 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.symbol,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    return OK$5(input.data);
  }
};
ZodSymbol$5.create = (params) => {
  return new ZodSymbol$5({
    typeName: ZodFirstPartyTypeKind$5.ZodSymbol,
    ...processCreateParams$5(params)
  });
};
let ZodUndefined$5 = class ZodUndefined12 extends ZodType$5 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.undefined,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    return OK$5(input.data);
  }
};
ZodUndefined$5.create = (params) => {
  return new ZodUndefined$5({
    typeName: ZodFirstPartyTypeKind$5.ZodUndefined,
    ...processCreateParams$5(params)
  });
};
let ZodNull$5 = class ZodNull12 extends ZodType$5 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.null,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    return OK$5(input.data);
  }
};
ZodNull$5.create = (params) => {
  return new ZodNull$5({
    typeName: ZodFirstPartyTypeKind$5.ZodNull,
    ...processCreateParams$5(params)
  });
};
let ZodAny$5 = class ZodAny12 extends ZodType$5 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$5(input.data);
  }
};
ZodAny$5.create = (params) => {
  return new ZodAny$5({
    typeName: ZodFirstPartyTypeKind$5.ZodAny,
    ...processCreateParams$5(params)
  });
};
let ZodUnknown$5 = class ZodUnknown12 extends ZodType$5 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$5(input.data);
  }
};
ZodUnknown$5.create = (params) => {
  return new ZodUnknown$5({
    typeName: ZodFirstPartyTypeKind$5.ZodUnknown,
    ...processCreateParams$5(params)
  });
};
let ZodNever$5 = class ZodNever12 extends ZodType$5 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$5(ctx, {
      code: ZodIssueCode$5.invalid_type,
      expected: ZodParsedType$5.never,
      received: ctx.parsedType
    });
    return INVALID$5;
  }
};
ZodNever$5.create = (params) => {
  return new ZodNever$5({
    typeName: ZodFirstPartyTypeKind$5.ZodNever,
    ...processCreateParams$5(params)
  });
};
let ZodVoid$5 = class ZodVoid12 extends ZodType$5 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.void,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    return OK$5(input.data);
  }
};
ZodVoid$5.create = (params) => {
  return new ZodVoid$5({
    typeName: ZodFirstPartyTypeKind$5.ZodVoid,
    ...processCreateParams$5(params)
  });
};
let ZodArray$5 = class ZodArray12 extends ZodType$5 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType$5.array) {
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.array,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$5(ctx, {
          code: tooBig ? ZodIssueCode$5.too_big : ZodIssueCode$5.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext$5(ctx, {
          code: ZodIssueCode$5.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext$5(ctx, {
          code: ZodIssueCode$5.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath$5(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$5.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath$5(ctx, item, ctx.path, i));
    });
    return ParseStatus$5.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray12({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$5.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray12({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$5.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray12({
      ...this._def,
      exactLength: { value: len, message: errorUtil$5.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$5.create = (schema, params) => {
  return new ZodArray$5({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$5.ZodArray,
    ...processCreateParams$5(params)
  });
};
function deepPartialify$5(schema) {
  if (schema instanceof ZodObject$5) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$5.create(deepPartialify$5(fieldSchema));
    }
    return new ZodObject$5({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$5) {
    return new ZodArray$5({
      ...schema._def,
      type: deepPartialify$5(schema.element)
    });
  } else if (schema instanceof ZodOptional$5) {
    return ZodOptional$5.create(deepPartialify$5(schema.unwrap()));
  } else if (schema instanceof ZodNullable$5) {
    return ZodNullable$5.create(deepPartialify$5(schema.unwrap()));
  } else if (schema instanceof ZodTuple$5) {
    return ZodTuple$5.create(schema.items.map((item) => deepPartialify$5(item)));
  } else {
    return schema;
  }
}
let ZodObject$5 = class ZodObject12 extends ZodType$5 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$5.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx2, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.object,
        received: ctx2.parsedType
      });
      return INVALID$5;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$5 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$5(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$5) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$5(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$5.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$5.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$5.errToObj;
    return new ZodObject12({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          var _a, _b;
          const defaultError = ((_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue2, ctx).message) ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil$5.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject12({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject12({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject12({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject12({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$5.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject12({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util$5.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject12({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util$5.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject12({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$5(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util$5.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject12({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util$5.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$5) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject12({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$5(util$5.objectKeys(this.shape));
  }
};
ZodObject$5.create = (shape, params) => {
  return new ZodObject$5({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$5.create(),
    typeName: ZodFirstPartyTypeKind$5.ZodObject,
    ...processCreateParams$5(params)
  });
};
ZodObject$5.strictCreate = (shape, params) => {
  return new ZodObject$5({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$5.create(),
    typeName: ZodFirstPartyTypeKind$5.ZodObject,
    ...processCreateParams$5(params)
  });
};
ZodObject$5.lazycreate = (shape, params) => {
  return new ZodObject$5({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$5.create(),
    typeName: ZodFirstPartyTypeKind$5.ZodObject,
    ...processCreateParams$5(params)
  });
};
let ZodUnion$5 = class ZodUnion12 extends ZodType$5 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$5(result.ctx.common.issues));
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_union,
        unionErrors
      });
      return INVALID$5;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$5(issues2));
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_union,
        unionErrors
      });
      return INVALID$5;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$5.create = (types, params) => {
  return new ZodUnion$5({
    options: types,
    typeName: ZodFirstPartyTypeKind$5.ZodUnion,
    ...processCreateParams$5(params)
  });
};
function mergeValues$5(a, b) {
  const aType = getParsedType$5(a);
  const bType = getParsedType$5(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$5.object && bType === ZodParsedType$5.object) {
    const bKeys = util$5.objectKeys(b);
    const sharedKeys = util$5.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$5(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$5.array && bType === ZodParsedType$5.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$5(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$5.date && bType === ZodParsedType$5.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$5 = class ZodIntersection12 extends ZodType$5 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$5(parsedLeft) || isAborted$5(parsedRight)) {
        return INVALID$5;
      }
      const merged = mergeValues$5(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$5(ctx, {
          code: ZodIssueCode$5.invalid_intersection_types
        });
        return INVALID$5;
      }
      if (isDirty$5(parsedLeft) || isDirty$5(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$5.create = (left, right, params) => {
  return new ZodIntersection$5({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$5.ZodIntersection,
    ...processCreateParams$5(params)
  });
};
let ZodTuple$5 = class ZodTuple12 extends ZodType$5 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$5.array) {
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.array,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$5;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$5(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$5.mergeArray(status, results);
      });
    } else {
      return ParseStatus$5.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple12({
      ...this._def,
      rest
    });
  }
};
ZodTuple$5.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$5({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$5.ZodTuple,
    rest: null,
    ...processCreateParams$5(params)
  });
};
let ZodMap$5 = class ZodMap12 extends ZodType$5 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$5.map) {
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.map,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$5(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$5(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$5;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$5;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$5.create = (keyType, valueType, params) => {
  return new ZodMap$5({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$5.ZodMap,
    ...processCreateParams$5(params)
  });
};
let ZodSet$5 = class ZodSet12 extends ZodType$5 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$5.set) {
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.set,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext$5(ctx, {
          code: ZodIssueCode$5.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext$5(ctx, {
          code: ZodIssueCode$5.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID$5;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$5(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet12({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$5.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet12({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$5.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$5.create = (valueType, params) => {
  return new ZodSet$5({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$5.ZodSet,
    ...processCreateParams$5(params)
  });
};
let ZodLazy$5 = class ZodLazy12 extends ZodType$5 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$5.create = (getter, params) => {
  return new ZodLazy$5({
    getter,
    typeName: ZodFirstPartyTypeKind$5.ZodLazy,
    ...processCreateParams$5(params)
  });
};
let ZodLiteral$5 = class ZodLiteral12 extends ZodType$5 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx, {
        received: ctx.data,
        code: ZodIssueCode$5.invalid_literal,
        expected: this._def.value
      });
      return INVALID$5;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$5.create = (value, params) => {
  return new ZodLiteral$5({
    value,
    typeName: ZodFirstPartyTypeKind$5.ZodLiteral,
    ...processCreateParams$5(params)
  });
};
function createZodEnum$5(values, params) {
  return new ZodEnum$5({
    values,
    typeName: ZodFirstPartyTypeKind$5.ZodEnum,
    ...processCreateParams$5(params)
  });
}
let ZodEnum$5 = class ZodEnum12 extends ZodType$5 {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$5(ctx, {
        expected: util$5.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$5.invalid_type
      });
      return INVALID$5;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$5(ctx, {
        received: ctx.data,
        code: ZodIssueCode$5.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$5;
    }
    return OK$5(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum12.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum12.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum$5.create = createZodEnum$5;
let ZodNativeEnum$5 = class ZodNativeEnum12 extends ZodType$5 {
  _parse(input) {
    const nativeEnumValues = util$5.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$5.string && ctx.parsedType !== ZodParsedType$5.number) {
      const expectedValues = util$5.objectValues(nativeEnumValues);
      addIssueToContext$5(ctx, {
        expected: util$5.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$5.invalid_type
      });
      return INVALID$5;
    }
    if (!this._cache) {
      this._cache = new Set(util$5.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util$5.objectValues(nativeEnumValues);
      addIssueToContext$5(ctx, {
        received: ctx.data,
        code: ZodIssueCode$5.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$5;
    }
    return OK$5(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum$5.create = (values, params) => {
  return new ZodNativeEnum$5({
    values,
    typeName: ZodFirstPartyTypeKind$5.ZodNativeEnum,
    ...processCreateParams$5(params)
  });
};
let ZodPromise$5 = class ZodPromise12 extends ZodType$5 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$5.promise && ctx.common.async === false) {
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.promise,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    const promisified = ctx.parsedType === ZodParsedType$5.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$5(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$5.create = (schema, params) => {
  return new ZodPromise$5({
    type: schema,
    typeName: ZodFirstPartyTypeKind$5.ZodPromise,
    ...processCreateParams$5(params)
  });
};
let ZodEffects$5 = class ZodEffects12 extends ZodType$5 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$5.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$5(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$5;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$5;
          if (result.status === "dirty")
            return DIRTY$5(result.value);
          if (status.value === "dirty")
            return DIRTY$5(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$5;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$5;
        if (result.status === "dirty")
          return DIRTY$5(result.value);
        if (status.value === "dirty")
          return DIRTY$5(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$5;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$5;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$5(base))
          return INVALID$5;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$5(base))
            return INVALID$5;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util$5.assertNever(effect);
  }
};
ZodEffects$5.create = (schema, effect, params) => {
  return new ZodEffects$5({
    schema,
    typeName: ZodFirstPartyTypeKind$5.ZodEffects,
    effect,
    ...processCreateParams$5(params)
  });
};
ZodEffects$5.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$5({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$5.ZodEffects,
    ...processCreateParams$5(params)
  });
};
let ZodOptional$5 = class ZodOptional12 extends ZodType$5 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$5.undefined) {
      return OK$5(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$5.create = (type, params) => {
  return new ZodOptional$5({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$5.ZodOptional,
    ...processCreateParams$5(params)
  });
};
let ZodNullable$5 = class ZodNullable12 extends ZodType$5 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$5.null) {
      return OK$5(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$5.create = (type, params) => {
  return new ZodNullable$5({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$5.ZodNullable,
    ...processCreateParams$5(params)
  });
};
let ZodDefault$5 = class ZodDefault12 extends ZodType$5 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$5.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$5.create = (type, params) => {
  return new ZodDefault$5({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$5.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$5(params)
  });
};
let ZodCatch$5 = class ZodCatch12 extends ZodType$5 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$5(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$5(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$5(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$5.create = (type, params) => {
  return new ZodCatch$5({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$5.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$5(params)
  });
};
let ZodNaN$5 = class ZodNaN12 extends ZodType$5 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.nan,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$5.create = (params) => {
  return new ZodNaN$5({
    typeName: ZodFirstPartyTypeKind$5.ZodNaN,
    ...processCreateParams$5(params)
  });
};
let ZodBranded$5 = class ZodBranded12 extends ZodType$5 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$5 = class ZodPipeline12 extends ZodType$5 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$5;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$5(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$5;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline12({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$5.ZodPipeline
    });
  }
};
let ZodReadonly$5 = class ZodReadonly12 extends ZodType$5 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$5(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$5(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$5.create = (type, params) => {
  return new ZodReadonly$5({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$5.ZodReadonly,
    ...processCreateParams$5(params)
  });
};
var ZodFirstPartyTypeKind$5;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$5 || (ZodFirstPartyTypeKind$5 = {}));
const booleanType$3 = ZodBoolean$5.create;
ZodNever$5.create;
ZodArray$5.create;
const objectType$5 = ZodObject$5.create;
ZodUnion$5.create;
ZodIntersection$5.create;
ZodTuple$5.create;
ZodEnum$5.create;
ZodPromise$5.create;
ZodOptional$5.create;
ZodNullable$5.create;
const FlipOptionsSchema = objectType$5({
  /** if true the image will be flipped horizontally */
  horizontal: booleanType$3().optional(),
  /** if true the image will be flipped vertically */
  vertical: booleanType$3().optional()
});
const methods$6 = {
  /**
   * Flip the image.
   * @param horizontal a Boolean, if true the image will be flipped horizontally
   * @param vertical a Boolean, if true the image will be flipped vertically
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.flip(true, false);
   * ```
   */
  flip(image, options) {
    const { horizontal, vertical } = FlipOptionsSchema.parse(options);
    const bitmap = Buffer.alloc(image.bitmap.data.length);
    image.scan((x2, y2, idx) => {
      const _x = horizontal ? image.bitmap.width - 1 - x2 : x2;
      const _y = vertical ? image.bitmap.height - 1 - y2 : y2;
      const _idx = image.bitmap.width * _y + _x << 2;
      const data = image.bitmap.data.readUInt32BE(idx);
      bitmap.writeUInt32BE(data, _idx);
    });
    image.bitmap.data = Buffer.from(bitmap);
    return image;
  }
};
function Converter$1(srcAlphabet, dstAlphabet) {
  if (!srcAlphabet || !dstAlphabet || !srcAlphabet.length || !dstAlphabet.length) {
    throw new Error("Bad alphabet");
  }
  this.srcAlphabet = srcAlphabet;
  this.dstAlphabet = dstAlphabet;
}
Converter$1.prototype.convert = function(number2) {
  var i, divide, newlen, numberMap = {}, fromBase = this.srcAlphabet.length, toBase = this.dstAlphabet.length, length = number2.length, result = typeof number2 === "string" ? "" : [];
  if (!this.isValid(number2)) {
    throw new Error('Number "' + number2 + '" contains of non-alphabetic digits (' + this.srcAlphabet + ")");
  }
  if (this.srcAlphabet === this.dstAlphabet) {
    return number2;
  }
  for (i = 0; i < length; i++) {
    numberMap[i] = this.srcAlphabet.indexOf(number2[i]);
  }
  do {
    divide = 0;
    newlen = 0;
    for (i = 0; i < length; i++) {
      divide = divide * fromBase + numberMap[i];
      if (divide >= toBase) {
        numberMap[newlen++] = parseInt(divide / toBase, 10);
        divide = divide % toBase;
      } else if (newlen > 0) {
        numberMap[newlen++] = 0;
      }
    }
    length = newlen;
    result = this.dstAlphabet.slice(divide, divide + 1).concat(result);
  } while (newlen !== 0);
  return result;
};
Converter$1.prototype.isValid = function(number2) {
  var i = 0;
  for (; i < number2.length; ++i) {
    if (this.srcAlphabet.indexOf(number2[i]) === -1) {
      return false;
    }
  }
  return true;
};
var converter = Converter$1;
var Converter = converter;
function anyBase(srcAlphabet, dstAlphabet) {
  var converter2 = new Converter(srcAlphabet, dstAlphabet);
  return function(number2) {
    return converter2.convert(number2);
  };
}
anyBase.BIN = "01";
anyBase.OCT = "01234567";
anyBase.DEC = "0123456789";
anyBase.HEX = "0123456789abcdef";
var anyBase_1 = anyBase;
const anyBase$1 = /* @__PURE__ */ getDefaultExportFromCjs(anyBase_1);
class ImagePHash {
  constructor(size, smallerSize) {
    __publicField2(this, "size");
    __publicField2(this, "smallerSize");
    this.size = size || 32;
    this.smallerSize = smallerSize || 8;
    initCoefficients(this.size);
  }
  distance(s1, s2) {
    let counter = 0;
    for (let k = 0; k < s1.length; k++) {
      if (s1[k] !== s2[k]) {
        counter++;
      }
    }
    return counter / s1.length;
  }
  /**
   * Returns a 'binary string' (like. 001010111011100010) which is easy to do a hamming distance on.
   */
  getHash(img) {
    img = methods$d.resize(clone(img), { w: this.size, h: this.size });
    img = methods$e.greyscale(img);
    const vals = [];
    for (let x2 = 0; x2 < img.bitmap.width; x2++) {
      const row = [];
      for (let y2 = 0; y2 < img.bitmap.height; y2++) {
        row[y2] = intToRGBA(img.getPixelColor(x2, y2)).b;
      }
      vals[x2] = row;
    }
    const dctVals = applyDCT(vals, this.size);
    let total = 0;
    for (let x2 = 0; x2 < this.smallerSize; x2++) {
      for (let y2 = 0; y2 < this.smallerSize; y2++) {
        total += dctVals[x2][y2];
      }
    }
    const avg = total / (this.smallerSize * this.smallerSize);
    let hash = "";
    for (let x2 = 0; x2 < this.smallerSize; x2++) {
      for (let y2 = 0; y2 < this.smallerSize; y2++) {
        hash += dctVals[x2][y2] > avg ? "1" : "0";
      }
    }
    return hash;
  }
}
function intToRGBA(i) {
  const a = i & 255;
  i >>>= 8;
  const b = i & 255;
  i >>>= 8;
  const g = i & 255;
  i >>>= 8;
  const r = i & 255;
  return { r, g, b, a };
}
const c = [];
function initCoefficients(size) {
  for (let i = 1; i < size; i++) {
    c[i] = 1;
  }
  c[0] = 1 / Math.sqrt(2);
}
function applyDCT(f, size) {
  const N = size;
  const F = [];
  for (let u = 0; u < N; u++) {
    const row = [];
    for (let v = 0; v < N; v++) {
      let sum = 0;
      for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
          sum += Math.cos((2 * i + 1) / (2 * N) * u * Math.PI) * Math.cos((2 * j + 1) / (2 * N) * v * Math.PI) * f[i][j];
        }
      }
      sum *= c[u] * c[v] / 4;
      row[v] = sum;
      F[u] = row;
    }
  }
  return F;
}
const alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_";
const maxHashLength = [NaN, NaN];
for (let i = 2; i < 65; i++) {
  const maxHash = anyBase$1(anyBase$1.BIN, alphabet.slice(0, i))(new Array(64 + 1).join("1"));
  maxHashLength.push(maxHash.length);
}
const methods$5 = {
  /**
   * Calculates the perceptual hash
   * @returns the perceptual hash
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.hash();
   * ```
   */
  pHash(image) {
    const pHash = new ImagePHash();
    return pHash.getHash(image);
  },
  /**
   * Generates a perceptual hash of the image <https://en.wikipedia.org/wiki/Perceptual_hashing>. And pads the string. Can configure base.
   * @param base A number between 2 and 64 representing the base for the hash (e.g. 2 is binary, 10 is decimal, 16 is hex, 64 is base 64). Defaults to 64.
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.hash(2); // binary
   * image.hash(64); // base 64
   * ```
   */
  hash(image, base = 64) {
    if (base < 2 || base > 64) {
      throw new Error("base must be a number between 2 and 64");
    }
    const subAlphabet = alphabet.slice(0, base);
    const pHash = this.pHash(image);
    const maxLength = maxHashLength[base];
    return anyBase$1(anyBase$1.BIN, subAlphabet)(pHash).padStart(maxLength, "0");
  },
  /**
   * Calculates the hamming distance of the current image and a hash based on their perceptual hash
   * @param compareHash hash to compare to
   * @returns  a number ranging from 0 to 1, 0 means they are believed to be identical
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.distanceFromHash(image.pHash());
   * ```
   */
  distanceFromHash(image, compareHash) {
    const pHash = new ImagePHash();
    const currentHash = pHash.getHash(image);
    return pHash.distance(currentHash, compareHash);
  }
};
var util$4;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$4 || (util$4 = {}));
var objectUtil$4;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$4 || (objectUtil$4 = {}));
const ZodParsedType$4 = util$4.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$4 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$4.undefined;
    case "string":
      return ZodParsedType$4.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType$4.nan : ZodParsedType$4.number;
    case "boolean":
      return ZodParsedType$4.boolean;
    case "function":
      return ZodParsedType$4.function;
    case "bigint":
      return ZodParsedType$4.bigint;
    case "symbol":
      return ZodParsedType$4.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$4.array;
      }
      if (data === null) {
        return ZodParsedType$4.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$4.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$4.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$4.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$4.date;
      }
      return ZodParsedType$4.object;
    default:
      return ZodParsedType$4.unknown;
  }
};
const ZodIssueCode$4 = util$4.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
let ZodError$4 = class ZodError13 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue2 of error.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError13)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$4.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$4.create = (issues) => {
  const error = new ZodError$4(issues);
  return error;
};
const errorMap$4 = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode$4.invalid_type:
      if (issue2.received === ZodParsedType$4.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode$4.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util$4.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$4.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$4.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode$4.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$4.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$4.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode$4.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$4.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode$4.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$4.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$4.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$4.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util$4.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$4.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$4.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$4.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$4.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$4.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode$4.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$4.assertNever(issue2);
  }
  return { message };
};
let overrideErrorMap$4 = errorMap$4;
function getErrorMap$4() {
  return overrideErrorMap$4;
}
const makeIssue$4 = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext$4(ctx, issueData) {
  const overrideMap = getErrorMap$4();
  const issue2 = makeIssue$4({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$4 ? void 0 : errorMap$4
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue2);
}
let ParseStatus$4 = class ParseStatus13 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$4;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus13.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$4;
      if (value.status === "aborted")
        return INVALID$4;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$4 = Object.freeze({
  status: "aborted"
});
const DIRTY$4 = (value) => ({ status: "dirty", value });
const OK$4 = (value) => ({ status: "valid", value });
const isAborted$4 = (x2) => x2.status === "aborted";
const isDirty$4 = (x2) => x2.status === "dirty";
const isValid$4 = (x2) => x2.status === "valid";
const isAsync$4 = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil$4;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil$4 || (errorUtil$4 = {}));
let ParseInputLazyPath$4 = class ParseInputLazyPath13 {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$4 = (ctx, result) => {
  if (isValid$4(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$4(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$4(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$4 = class ZodType13 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$4(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$4(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$4(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$4(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$4(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: (params == null ? void 0 : params.async) ?? false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$4(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$4(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$4(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$4(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$4(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$4(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$4(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$4(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$4.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$4({
      schema: this,
      typeName: ZodFirstPartyTypeKind$4.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$4.create(this, this._def);
  }
  nullable() {
    return ZodNullable$4.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$4.create(this);
  }
  promise() {
    return ZodPromise$4.create(this, this._def);
  }
  or(option) {
    return ZodUnion$4.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$4.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects$4({
      ...processCreateParams$4(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$4.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault$4({
      ...processCreateParams$4(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$4.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$4({
      typeName: ZodFirstPartyTypeKind$4.ZodBranded,
      type: this,
      ...processCreateParams$4(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch$4({
      ...processCreateParams$4(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$4.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$4.create(this, target);
  }
  readonly() {
    return ZodReadonly$4.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$4 = /^c[^\s-]{8,}$/i;
const cuid2Regex$4 = /^[0-9a-z]+$/;
const ulidRegex$4 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$4 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$4 = /^[a-z0-9_-]{21}$/i;
const jwtRegex$4 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$4 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$4 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$4 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$4;
const ipv4Regex$4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$4 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$4 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$4 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$4 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$4 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$4 = new RegExp(`^${dateRegexSource$4}$`);
function timeRegexSource$4(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex$4(args) {
  return new RegExp(`^${timeRegexSource$4(args)}$`);
}
function datetimeRegex$4(args) {
  let regex = `${dateRegexSource$4}T${timeRegexSource$4(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$4(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex$4.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex$4.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$4(jwt, alg) {
  if (!jwtRegex$4.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr$4(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex$4.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex$4.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$4 = class ZodString13 extends ZodType$4 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx2, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.string,
        received: ctx2.parsedType
      });
      return INVALID$4;
    }
    const status = new ParseStatus$4();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$4(ctx, {
              code: ZodIssueCode$4.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$4(ctx, {
              code: ZodIssueCode$4.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "email",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$4) {
          emojiRegex$4 = new RegExp(_emojiRegex$4, "u");
        }
        if (!emojiRegex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "emoji",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "uuid",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "cuid",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "ulid",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "url",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "regex",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$4(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$4;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$4(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "duration",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$4(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "ip",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$4(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "jwt",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$4(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "cidr",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "base64",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "base64url",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$4.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$4.invalid_string,
      ...errorUtil$4.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString13({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$4.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$4.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$4.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$4.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$4.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$4.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$4.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$4.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$4.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$4.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$4.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$4.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$4.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (options == null ? void 0 : options.offset) ?? false,
      local: (options == null ? void 0 : options.local) ?? false,
      ...errorUtil$4.errToObj(options == null ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      ...errorUtil$4.errToObj(options == null ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$4.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$4.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position,
      ...errorUtil$4.errToObj(options == null ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$4.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$4.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$4.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$4.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$4.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$4.errToObj(message));
  }
  trim() {
    return new ZodString13({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString13({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString13({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$4.create = (params) => {
  return new ZodString$4({
    checks: [],
    typeName: ZodFirstPartyTypeKind$4.ZodString,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$4(params)
  });
};
function floatSafeRemainder$4(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
let ZodNumber$4 = class ZodNumber13 extends ZodType$4 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx2, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.number,
        received: ctx2.parsedType
      });
      return INVALID$4;
    }
    let ctx = void 0;
    const status = new ParseStatus$4();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$4.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$4(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$4.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$4.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$4.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$4.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$4.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber13({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$4.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber13({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$4.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$4.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$4.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$4.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$4.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$4.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$4.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$4.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$4.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$4.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$4.create = (params) => {
  return new ZodNumber$4({
    checks: [],
    typeName: ZodFirstPartyTypeKind$4.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$4(params)
  });
};
let ZodBigInt$4 = class ZodBigInt13 extends ZodType$4 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$4();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$4.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$4(ctx, {
      code: ZodIssueCode$4.invalid_type,
      expected: ZodParsedType$4.bigint,
      received: ctx.parsedType
    });
    return INVALID$4;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$4.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$4.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$4.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$4.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt13({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$4.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt13({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$4.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$4.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$4.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$4.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$4.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$4.create = (params) => {
  return new ZodBigInt$4({
    checks: [],
    typeName: ZodFirstPartyTypeKind$4.ZodBigInt,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$4(params)
  });
};
let ZodBoolean$4 = class ZodBoolean13 extends ZodType$4 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.boolean,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    return OK$4(input.data);
  }
};
ZodBoolean$4.create = (params) => {
  return new ZodBoolean$4({
    typeName: ZodFirstPartyTypeKind$4.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$4(params)
  });
};
let ZodDate$4 = class ZodDate13 extends ZodType$4 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx2, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.date,
        received: ctx2.parsedType
      });
      return INVALID$4;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx2, {
        code: ZodIssueCode$4.invalid_date
      });
      return INVALID$4;
    }
    const status = new ParseStatus$4();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$4.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate13({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$4.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$4.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$4.create = (params) => {
  return new ZodDate$4({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$4.ZodDate,
    ...processCreateParams$4(params)
  });
};
let ZodSymbol$4 = class ZodSymbol13 extends ZodType$4 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.symbol,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    return OK$4(input.data);
  }
};
ZodSymbol$4.create = (params) => {
  return new ZodSymbol$4({
    typeName: ZodFirstPartyTypeKind$4.ZodSymbol,
    ...processCreateParams$4(params)
  });
};
let ZodUndefined$4 = class ZodUndefined13 extends ZodType$4 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.undefined,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    return OK$4(input.data);
  }
};
ZodUndefined$4.create = (params) => {
  return new ZodUndefined$4({
    typeName: ZodFirstPartyTypeKind$4.ZodUndefined,
    ...processCreateParams$4(params)
  });
};
let ZodNull$4 = class ZodNull13 extends ZodType$4 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.null,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    return OK$4(input.data);
  }
};
ZodNull$4.create = (params) => {
  return new ZodNull$4({
    typeName: ZodFirstPartyTypeKind$4.ZodNull,
    ...processCreateParams$4(params)
  });
};
let ZodAny$4 = class ZodAny13 extends ZodType$4 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$4(input.data);
  }
};
ZodAny$4.create = (params) => {
  return new ZodAny$4({
    typeName: ZodFirstPartyTypeKind$4.ZodAny,
    ...processCreateParams$4(params)
  });
};
let ZodUnknown$4 = class ZodUnknown13 extends ZodType$4 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$4(input.data);
  }
};
ZodUnknown$4.create = (params) => {
  return new ZodUnknown$4({
    typeName: ZodFirstPartyTypeKind$4.ZodUnknown,
    ...processCreateParams$4(params)
  });
};
let ZodNever$4 = class ZodNever13 extends ZodType$4 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$4(ctx, {
      code: ZodIssueCode$4.invalid_type,
      expected: ZodParsedType$4.never,
      received: ctx.parsedType
    });
    return INVALID$4;
  }
};
ZodNever$4.create = (params) => {
  return new ZodNever$4({
    typeName: ZodFirstPartyTypeKind$4.ZodNever,
    ...processCreateParams$4(params)
  });
};
let ZodVoid$4 = class ZodVoid13 extends ZodType$4 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.void,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    return OK$4(input.data);
  }
};
ZodVoid$4.create = (params) => {
  return new ZodVoid$4({
    typeName: ZodFirstPartyTypeKind$4.ZodVoid,
    ...processCreateParams$4(params)
  });
};
let ZodArray$4 = class ZodArray13 extends ZodType$4 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType$4.array) {
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.array,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$4(ctx, {
          code: tooBig ? ZodIssueCode$4.too_big : ZodIssueCode$4.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext$4(ctx, {
          code: ZodIssueCode$4.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext$4(ctx, {
          code: ZodIssueCode$4.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath$4(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$4.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath$4(ctx, item, ctx.path, i));
    });
    return ParseStatus$4.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray13({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$4.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray13({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$4.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray13({
      ...this._def,
      exactLength: { value: len, message: errorUtil$4.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$4.create = (schema, params) => {
  return new ZodArray$4({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$4.ZodArray,
    ...processCreateParams$4(params)
  });
};
function deepPartialify$4(schema) {
  if (schema instanceof ZodObject$4) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$4.create(deepPartialify$4(fieldSchema));
    }
    return new ZodObject$4({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$4) {
    return new ZodArray$4({
      ...schema._def,
      type: deepPartialify$4(schema.element)
    });
  } else if (schema instanceof ZodOptional$4) {
    return ZodOptional$4.create(deepPartialify$4(schema.unwrap()));
  } else if (schema instanceof ZodNullable$4) {
    return ZodNullable$4.create(deepPartialify$4(schema.unwrap()));
  } else if (schema instanceof ZodTuple$4) {
    return ZodTuple$4.create(schema.items.map((item) => deepPartialify$4(item)));
  } else {
    return schema;
  }
}
let ZodObject$4 = class ZodObject13 extends ZodType$4 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$4.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx2, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.object,
        received: ctx2.parsedType
      });
      return INVALID$4;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$4 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$4(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$4) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$4(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$4.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$4.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$4.errToObj;
    return new ZodObject13({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          var _a, _b;
          const defaultError = ((_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue2, ctx).message) ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil$4.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject13({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject13({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject13({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject13({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$4.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject13({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util$4.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject13({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util$4.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject13({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$4(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util$4.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject13({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util$4.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$4) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject13({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$4(util$4.objectKeys(this.shape));
  }
};
ZodObject$4.create = (shape, params) => {
  return new ZodObject$4({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$4.create(),
    typeName: ZodFirstPartyTypeKind$4.ZodObject,
    ...processCreateParams$4(params)
  });
};
ZodObject$4.strictCreate = (shape, params) => {
  return new ZodObject$4({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$4.create(),
    typeName: ZodFirstPartyTypeKind$4.ZodObject,
    ...processCreateParams$4(params)
  });
};
ZodObject$4.lazycreate = (shape, params) => {
  return new ZodObject$4({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$4.create(),
    typeName: ZodFirstPartyTypeKind$4.ZodObject,
    ...processCreateParams$4(params)
  });
};
let ZodUnion$4 = class ZodUnion13 extends ZodType$4 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$4(result.ctx.common.issues));
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_union,
        unionErrors
      });
      return INVALID$4;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$4(issues2));
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_union,
        unionErrors
      });
      return INVALID$4;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$4.create = (types, params) => {
  return new ZodUnion$4({
    options: types,
    typeName: ZodFirstPartyTypeKind$4.ZodUnion,
    ...processCreateParams$4(params)
  });
};
function mergeValues$4(a, b) {
  const aType = getParsedType$4(a);
  const bType = getParsedType$4(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$4.object && bType === ZodParsedType$4.object) {
    const bKeys = util$4.objectKeys(b);
    const sharedKeys = util$4.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$4(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$4.array && bType === ZodParsedType$4.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$4(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$4.date && bType === ZodParsedType$4.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$4 = class ZodIntersection13 extends ZodType$4 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$4(parsedLeft) || isAborted$4(parsedRight)) {
        return INVALID$4;
      }
      const merged = mergeValues$4(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$4(ctx, {
          code: ZodIssueCode$4.invalid_intersection_types
        });
        return INVALID$4;
      }
      if (isDirty$4(parsedLeft) || isDirty$4(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$4.create = (left, right, params) => {
  return new ZodIntersection$4({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$4.ZodIntersection,
    ...processCreateParams$4(params)
  });
};
let ZodTuple$4 = class ZodTuple13 extends ZodType$4 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$4.array) {
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.array,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$4;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$4(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$4.mergeArray(status, results);
      });
    } else {
      return ParseStatus$4.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple13({
      ...this._def,
      rest
    });
  }
};
ZodTuple$4.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$4({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$4.ZodTuple,
    rest: null,
    ...processCreateParams$4(params)
  });
};
let ZodMap$4 = class ZodMap13 extends ZodType$4 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$4.map) {
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.map,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$4(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$4(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$4;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$4;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$4.create = (keyType, valueType, params) => {
  return new ZodMap$4({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$4.ZodMap,
    ...processCreateParams$4(params)
  });
};
let ZodSet$4 = class ZodSet13 extends ZodType$4 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$4.set) {
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.set,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext$4(ctx, {
          code: ZodIssueCode$4.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext$4(ctx, {
          code: ZodIssueCode$4.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID$4;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$4(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet13({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$4.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet13({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$4.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$4.create = (valueType, params) => {
  return new ZodSet$4({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$4.ZodSet,
    ...processCreateParams$4(params)
  });
};
let ZodLazy$4 = class ZodLazy13 extends ZodType$4 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$4.create = (getter, params) => {
  return new ZodLazy$4({
    getter,
    typeName: ZodFirstPartyTypeKind$4.ZodLazy,
    ...processCreateParams$4(params)
  });
};
let ZodLiteral$4 = class ZodLiteral13 extends ZodType$4 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx, {
        received: ctx.data,
        code: ZodIssueCode$4.invalid_literal,
        expected: this._def.value
      });
      return INVALID$4;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$4.create = (value, params) => {
  return new ZodLiteral$4({
    value,
    typeName: ZodFirstPartyTypeKind$4.ZodLiteral,
    ...processCreateParams$4(params)
  });
};
function createZodEnum$4(values, params) {
  return new ZodEnum$4({
    values,
    typeName: ZodFirstPartyTypeKind$4.ZodEnum,
    ...processCreateParams$4(params)
  });
}
let ZodEnum$4 = class ZodEnum13 extends ZodType$4 {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$4(ctx, {
        expected: util$4.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$4.invalid_type
      });
      return INVALID$4;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$4(ctx, {
        received: ctx.data,
        code: ZodIssueCode$4.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$4;
    }
    return OK$4(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum13.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum13.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum$4.create = createZodEnum$4;
let ZodNativeEnum$4 = class ZodNativeEnum13 extends ZodType$4 {
  _parse(input) {
    const nativeEnumValues = util$4.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$4.string && ctx.parsedType !== ZodParsedType$4.number) {
      const expectedValues = util$4.objectValues(nativeEnumValues);
      addIssueToContext$4(ctx, {
        expected: util$4.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$4.invalid_type
      });
      return INVALID$4;
    }
    if (!this._cache) {
      this._cache = new Set(util$4.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util$4.objectValues(nativeEnumValues);
      addIssueToContext$4(ctx, {
        received: ctx.data,
        code: ZodIssueCode$4.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$4;
    }
    return OK$4(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum$4.create = (values, params) => {
  return new ZodNativeEnum$4({
    values,
    typeName: ZodFirstPartyTypeKind$4.ZodNativeEnum,
    ...processCreateParams$4(params)
  });
};
let ZodPromise$4 = class ZodPromise13 extends ZodType$4 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$4.promise && ctx.common.async === false) {
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.promise,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    const promisified = ctx.parsedType === ZodParsedType$4.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$4(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$4.create = (schema, params) => {
  return new ZodPromise$4({
    type: schema,
    typeName: ZodFirstPartyTypeKind$4.ZodPromise,
    ...processCreateParams$4(params)
  });
};
let ZodEffects$4 = class ZodEffects13 extends ZodType$4 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$4.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$4(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$4;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$4;
          if (result.status === "dirty")
            return DIRTY$4(result.value);
          if (status.value === "dirty")
            return DIRTY$4(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$4;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$4;
        if (result.status === "dirty")
          return DIRTY$4(result.value);
        if (status.value === "dirty")
          return DIRTY$4(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$4;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$4;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$4(base))
          return INVALID$4;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$4(base))
            return INVALID$4;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util$4.assertNever(effect);
  }
};
ZodEffects$4.create = (schema, effect, params) => {
  return new ZodEffects$4({
    schema,
    typeName: ZodFirstPartyTypeKind$4.ZodEffects,
    effect,
    ...processCreateParams$4(params)
  });
};
ZodEffects$4.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$4({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$4.ZodEffects,
    ...processCreateParams$4(params)
  });
};
let ZodOptional$4 = class ZodOptional13 extends ZodType$4 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$4.undefined) {
      return OK$4(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$4.create = (type, params) => {
  return new ZodOptional$4({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$4.ZodOptional,
    ...processCreateParams$4(params)
  });
};
let ZodNullable$4 = class ZodNullable13 extends ZodType$4 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$4.null) {
      return OK$4(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$4.create = (type, params) => {
  return new ZodNullable$4({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$4.ZodNullable,
    ...processCreateParams$4(params)
  });
};
let ZodDefault$4 = class ZodDefault13 extends ZodType$4 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$4.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$4.create = (type, params) => {
  return new ZodDefault$4({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$4.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$4(params)
  });
};
let ZodCatch$4 = class ZodCatch13 extends ZodType$4 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$4(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$4(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$4(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$4.create = (type, params) => {
  return new ZodCatch$4({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$4.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$4(params)
  });
};
let ZodNaN$4 = class ZodNaN13 extends ZodType$4 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.nan,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$4.create = (params) => {
  return new ZodNaN$4({
    typeName: ZodFirstPartyTypeKind$4.ZodNaN,
    ...processCreateParams$4(params)
  });
};
let ZodBranded$4 = class ZodBranded13 extends ZodType$4 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$4 = class ZodPipeline13 extends ZodType$4 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$4;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$4(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$4;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline13({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$4.ZodPipeline
    });
  }
};
let ZodReadonly$4 = class ZodReadonly13 extends ZodType$4 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$4(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$4(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$4.create = (type, params) => {
  return new ZodReadonly$4({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$4.ZodReadonly,
    ...processCreateParams$4(params)
  });
};
var ZodFirstPartyTypeKind$4;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$4 || (ZodFirstPartyTypeKind$4 = {}));
const numberType$4 = ZodNumber$4.create;
ZodNever$4.create;
ZodArray$4.create;
const objectType$4 = ZodObject$4.create;
const unionType$3 = ZodUnion$4.create;
ZodIntersection$4.create;
ZodTuple$4.create;
ZodEnum$4.create;
ZodPromise$4.create;
ZodOptional$4.create;
ZodNullable$4.create;
const MaskOptionsObjectSchema = objectType$4({
  src: JimpClassSchema,
  /** the x position to draw the image */
  x: numberType$4().optional(),
  /** the y position to draw the image */
  y: numberType$4().optional()
});
const MaskOptionsSchema = unionType$3([JimpClassSchema, MaskOptionsObjectSchema]);
const methods$4 = {
  /**
   * Masks a source image on to this image using average pixel colour. A completely black pixel on the mask will turn a pixel in the image completely transparent.
   * @param src the source Jimp instance
   * @param x the horizontal position to blit the image
   * @param y the vertical position to blit the image
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   * const mask = await Jimp.read("test/mask.png");
   *
   * image.mask(mask);
   * ```
   */
  mask(image, options) {
    MaskOptionsSchema.parse(options);
    let src2;
    let x2;
    let y2;
    if ("bitmap" in options) {
      src2 = options;
      x2 = 0;
      y2 = 0;
    } else {
      src2 = options.src;
      x2 = options.x ?? 0;
      y2 = options.y ?? 0;
    }
    x2 = Math.round(x2);
    y2 = Math.round(y2);
    const w = image.bitmap.width;
    const h = image.bitmap.height;
    src2.scan(function(sx, sy, idx) {
      const destX = x2 + sx;
      const destY = y2 + sy;
      if (destX >= 0 && destY >= 0 && destX < w && destY < h) {
        const dstIdx = image.getPixelIndex(destX, destY);
        const { data } = src2.bitmap;
        const avg = (data[idx + 0] + data[idx + 1] + data[idx + 2]) / 3;
        image.bitmap.data[dstIdx + 3] *= avg / 255;
      }
    });
    return image;
  }
};
var util$3;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$3 || (util$3 = {}));
var objectUtil$3;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$3 || (objectUtil$3 = {}));
const ZodParsedType$3 = util$3.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$3 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$3.undefined;
    case "string":
      return ZodParsedType$3.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType$3.nan : ZodParsedType$3.number;
    case "boolean":
      return ZodParsedType$3.boolean;
    case "function":
      return ZodParsedType$3.function;
    case "bigint":
      return ZodParsedType$3.bigint;
    case "symbol":
      return ZodParsedType$3.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$3.array;
      }
      if (data === null) {
        return ZodParsedType$3.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$3.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$3.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$3.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$3.date;
      }
      return ZodParsedType$3.object;
    default:
      return ZodParsedType$3.unknown;
  }
};
const ZodIssueCode$3 = util$3.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
let ZodError$3 = class ZodError14 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue2 of error.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError14)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$3.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$3.create = (issues) => {
  const error = new ZodError$3(issues);
  return error;
};
const errorMap$3 = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode$3.invalid_type:
      if (issue2.received === ZodParsedType$3.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode$3.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util$3.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$3.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$3.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode$3.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$3.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$3.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode$3.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$3.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode$3.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$3.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$3.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$3.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util$3.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$3.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$3.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$3.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$3.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$3.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode$3.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$3.assertNever(issue2);
  }
  return { message };
};
let overrideErrorMap$3 = errorMap$3;
function getErrorMap$3() {
  return overrideErrorMap$3;
}
const makeIssue$3 = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext$3(ctx, issueData) {
  const overrideMap = getErrorMap$3();
  const issue2 = makeIssue$3({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$3 ? void 0 : errorMap$3
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue2);
}
let ParseStatus$3 = class ParseStatus14 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$3;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus14.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$3;
      if (value.status === "aborted")
        return INVALID$3;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$3 = Object.freeze({
  status: "aborted"
});
const DIRTY$3 = (value) => ({ status: "dirty", value });
const OK$3 = (value) => ({ status: "valid", value });
const isAborted$3 = (x2) => x2.status === "aborted";
const isDirty$3 = (x2) => x2.status === "dirty";
const isValid$3 = (x2) => x2.status === "valid";
const isAsync$3 = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil$3;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil$3 || (errorUtil$3 = {}));
let ParseInputLazyPath$3 = class ParseInputLazyPath14 {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$3 = (ctx, result) => {
  if (isValid$3(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$3(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$3(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$3 = class ZodType14 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$3(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$3(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$3(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$3(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$3(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: (params == null ? void 0 : params.async) ?? false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$3(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$3(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$3(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$3(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$3(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$3(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$3(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$3(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$3.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$3({
      schema: this,
      typeName: ZodFirstPartyTypeKind$3.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$3.create(this, this._def);
  }
  nullable() {
    return ZodNullable$3.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$3.create(this);
  }
  promise() {
    return ZodPromise$3.create(this, this._def);
  }
  or(option) {
    return ZodUnion$3.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$3.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects$3({
      ...processCreateParams$3(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$3.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault$3({
      ...processCreateParams$3(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$3.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$3({
      typeName: ZodFirstPartyTypeKind$3.ZodBranded,
      type: this,
      ...processCreateParams$3(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch$3({
      ...processCreateParams$3(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$3.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$3.create(this, target);
  }
  readonly() {
    return ZodReadonly$3.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$3 = /^c[^\s-]{8,}$/i;
const cuid2Regex$3 = /^[0-9a-z]+$/;
const ulidRegex$3 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$3 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$3 = /^[a-z0-9_-]{21}$/i;
const jwtRegex$3 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$3 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$3 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$3 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$3;
const ipv4Regex$3 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$3 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$3 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$3 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$3 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$3 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$3 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$3 = new RegExp(`^${dateRegexSource$3}$`);
function timeRegexSource$3(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex$3(args) {
  return new RegExp(`^${timeRegexSource$3(args)}$`);
}
function datetimeRegex$3(args) {
  let regex = `${dateRegexSource$3}T${timeRegexSource$3(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$3(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex$3.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex$3.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$3(jwt, alg) {
  if (!jwtRegex$3.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr$3(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex$3.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex$3.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$3 = class ZodString14 extends ZodType$3 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx2, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.string,
        received: ctx2.parsedType
      });
      return INVALID$3;
    }
    const status = new ParseStatus$3();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$3(ctx, {
              code: ZodIssueCode$3.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$3(ctx, {
              code: ZodIssueCode$3.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "email",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$3) {
          emojiRegex$3 = new RegExp(_emojiRegex$3, "u");
        }
        if (!emojiRegex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "emoji",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "uuid",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "cuid",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "ulid",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "url",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "regex",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$3(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$3;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$3(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "duration",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$3(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "ip",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$3(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "jwt",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$3(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "cidr",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "base64",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "base64url",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$3.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$3.invalid_string,
      ...errorUtil$3.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString14({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$3.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$3.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$3.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$3.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$3.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$3.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$3.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$3.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$3.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$3.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$3.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$3.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$3.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (options == null ? void 0 : options.offset) ?? false,
      local: (options == null ? void 0 : options.local) ?? false,
      ...errorUtil$3.errToObj(options == null ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      ...errorUtil$3.errToObj(options == null ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$3.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$3.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position,
      ...errorUtil$3.errToObj(options == null ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$3.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$3.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$3.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$3.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$3.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$3.errToObj(message));
  }
  trim() {
    return new ZodString14({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString14({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString14({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$3.create = (params) => {
  return new ZodString$3({
    checks: [],
    typeName: ZodFirstPartyTypeKind$3.ZodString,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$3(params)
  });
};
function floatSafeRemainder$3(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
let ZodNumber$3 = class ZodNumber14 extends ZodType$3 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx2, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.number,
        received: ctx2.parsedType
      });
      return INVALID$3;
    }
    let ctx = void 0;
    const status = new ParseStatus$3();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$3.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$3(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$3.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$3.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$3.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$3.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$3.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber14({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$3.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber14({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$3.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$3.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$3.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$3.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$3.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$3.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$3.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$3.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$3.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$3.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$3.create = (params) => {
  return new ZodNumber$3({
    checks: [],
    typeName: ZodFirstPartyTypeKind$3.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$3(params)
  });
};
let ZodBigInt$3 = class ZodBigInt14 extends ZodType$3 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$3();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$3.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$3(ctx, {
      code: ZodIssueCode$3.invalid_type,
      expected: ZodParsedType$3.bigint,
      received: ctx.parsedType
    });
    return INVALID$3;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$3.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$3.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$3.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$3.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt14({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$3.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt14({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$3.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$3.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$3.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$3.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$3.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$3.create = (params) => {
  return new ZodBigInt$3({
    checks: [],
    typeName: ZodFirstPartyTypeKind$3.ZodBigInt,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$3(params)
  });
};
let ZodBoolean$3 = class ZodBoolean14 extends ZodType$3 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.boolean,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    return OK$3(input.data);
  }
};
ZodBoolean$3.create = (params) => {
  return new ZodBoolean$3({
    typeName: ZodFirstPartyTypeKind$3.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$3(params)
  });
};
let ZodDate$3 = class ZodDate14 extends ZodType$3 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx2, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.date,
        received: ctx2.parsedType
      });
      return INVALID$3;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx2, {
        code: ZodIssueCode$3.invalid_date
      });
      return INVALID$3;
    }
    const status = new ParseStatus$3();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$3.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate14({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$3.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$3.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$3.create = (params) => {
  return new ZodDate$3({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$3.ZodDate,
    ...processCreateParams$3(params)
  });
};
let ZodSymbol$3 = class ZodSymbol14 extends ZodType$3 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.symbol,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    return OK$3(input.data);
  }
};
ZodSymbol$3.create = (params) => {
  return new ZodSymbol$3({
    typeName: ZodFirstPartyTypeKind$3.ZodSymbol,
    ...processCreateParams$3(params)
  });
};
let ZodUndefined$3 = class ZodUndefined14 extends ZodType$3 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.undefined,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    return OK$3(input.data);
  }
};
ZodUndefined$3.create = (params) => {
  return new ZodUndefined$3({
    typeName: ZodFirstPartyTypeKind$3.ZodUndefined,
    ...processCreateParams$3(params)
  });
};
let ZodNull$3 = class ZodNull14 extends ZodType$3 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.null,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    return OK$3(input.data);
  }
};
ZodNull$3.create = (params) => {
  return new ZodNull$3({
    typeName: ZodFirstPartyTypeKind$3.ZodNull,
    ...processCreateParams$3(params)
  });
};
let ZodAny$3 = class ZodAny14 extends ZodType$3 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$3(input.data);
  }
};
ZodAny$3.create = (params) => {
  return new ZodAny$3({
    typeName: ZodFirstPartyTypeKind$3.ZodAny,
    ...processCreateParams$3(params)
  });
};
let ZodUnknown$3 = class ZodUnknown14 extends ZodType$3 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$3(input.data);
  }
};
ZodUnknown$3.create = (params) => {
  return new ZodUnknown$3({
    typeName: ZodFirstPartyTypeKind$3.ZodUnknown,
    ...processCreateParams$3(params)
  });
};
let ZodNever$3 = class ZodNever14 extends ZodType$3 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$3(ctx, {
      code: ZodIssueCode$3.invalid_type,
      expected: ZodParsedType$3.never,
      received: ctx.parsedType
    });
    return INVALID$3;
  }
};
ZodNever$3.create = (params) => {
  return new ZodNever$3({
    typeName: ZodFirstPartyTypeKind$3.ZodNever,
    ...processCreateParams$3(params)
  });
};
let ZodVoid$3 = class ZodVoid14 extends ZodType$3 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.void,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    return OK$3(input.data);
  }
};
ZodVoid$3.create = (params) => {
  return new ZodVoid$3({
    typeName: ZodFirstPartyTypeKind$3.ZodVoid,
    ...processCreateParams$3(params)
  });
};
let ZodArray$3 = class ZodArray14 extends ZodType$3 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType$3.array) {
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.array,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$3(ctx, {
          code: tooBig ? ZodIssueCode$3.too_big : ZodIssueCode$3.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext$3(ctx, {
          code: ZodIssueCode$3.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext$3(ctx, {
          code: ZodIssueCode$3.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath$3(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$3.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath$3(ctx, item, ctx.path, i));
    });
    return ParseStatus$3.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray14({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$3.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray14({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$3.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray14({
      ...this._def,
      exactLength: { value: len, message: errorUtil$3.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$3.create = (schema, params) => {
  return new ZodArray$3({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$3.ZodArray,
    ...processCreateParams$3(params)
  });
};
function deepPartialify$3(schema) {
  if (schema instanceof ZodObject$3) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$3.create(deepPartialify$3(fieldSchema));
    }
    return new ZodObject$3({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$3) {
    return new ZodArray$3({
      ...schema._def,
      type: deepPartialify$3(schema.element)
    });
  } else if (schema instanceof ZodOptional$3) {
    return ZodOptional$3.create(deepPartialify$3(schema.unwrap()));
  } else if (schema instanceof ZodNullable$3) {
    return ZodNullable$3.create(deepPartialify$3(schema.unwrap()));
  } else if (schema instanceof ZodTuple$3) {
    return ZodTuple$3.create(schema.items.map((item) => deepPartialify$3(item)));
  } else {
    return schema;
  }
}
let ZodObject$3 = class ZodObject14 extends ZodType$3 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$3.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx2, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.object,
        received: ctx2.parsedType
      });
      return INVALID$3;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$3 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$3(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$3) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$3(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$3.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$3.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$3.errToObj;
    return new ZodObject14({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          var _a, _b;
          const defaultError = ((_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue2, ctx).message) ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil$3.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject14({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject14({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject14({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject14({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$3.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject14({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util$3.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject14({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util$3.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject14({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$3(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util$3.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject14({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util$3.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$3) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject14({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$3(util$3.objectKeys(this.shape));
  }
};
ZodObject$3.create = (shape, params) => {
  return new ZodObject$3({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$3.create(),
    typeName: ZodFirstPartyTypeKind$3.ZodObject,
    ...processCreateParams$3(params)
  });
};
ZodObject$3.strictCreate = (shape, params) => {
  return new ZodObject$3({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$3.create(),
    typeName: ZodFirstPartyTypeKind$3.ZodObject,
    ...processCreateParams$3(params)
  });
};
ZodObject$3.lazycreate = (shape, params) => {
  return new ZodObject$3({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$3.create(),
    typeName: ZodFirstPartyTypeKind$3.ZodObject,
    ...processCreateParams$3(params)
  });
};
let ZodUnion$3 = class ZodUnion14 extends ZodType$3 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$3(result.ctx.common.issues));
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_union,
        unionErrors
      });
      return INVALID$3;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$3(issues2));
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_union,
        unionErrors
      });
      return INVALID$3;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$3.create = (types, params) => {
  return new ZodUnion$3({
    options: types,
    typeName: ZodFirstPartyTypeKind$3.ZodUnion,
    ...processCreateParams$3(params)
  });
};
function mergeValues$3(a, b) {
  const aType = getParsedType$3(a);
  const bType = getParsedType$3(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$3.object && bType === ZodParsedType$3.object) {
    const bKeys = util$3.objectKeys(b);
    const sharedKeys = util$3.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$3(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$3.array && bType === ZodParsedType$3.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$3(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$3.date && bType === ZodParsedType$3.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$3 = class ZodIntersection14 extends ZodType$3 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$3(parsedLeft) || isAborted$3(parsedRight)) {
        return INVALID$3;
      }
      const merged = mergeValues$3(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$3(ctx, {
          code: ZodIssueCode$3.invalid_intersection_types
        });
        return INVALID$3;
      }
      if (isDirty$3(parsedLeft) || isDirty$3(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$3.create = (left, right, params) => {
  return new ZodIntersection$3({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$3.ZodIntersection,
    ...processCreateParams$3(params)
  });
};
let ZodTuple$3 = class ZodTuple14 extends ZodType$3 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$3.array) {
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.array,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$3;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$3(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$3.mergeArray(status, results);
      });
    } else {
      return ParseStatus$3.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple14({
      ...this._def,
      rest
    });
  }
};
ZodTuple$3.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$3({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$3.ZodTuple,
    rest: null,
    ...processCreateParams$3(params)
  });
};
let ZodMap$3 = class ZodMap14 extends ZodType$3 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$3.map) {
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.map,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$3(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$3(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$3;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$3;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$3.create = (keyType, valueType, params) => {
  return new ZodMap$3({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$3.ZodMap,
    ...processCreateParams$3(params)
  });
};
let ZodSet$3 = class ZodSet14 extends ZodType$3 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$3.set) {
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.set,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext$3(ctx, {
          code: ZodIssueCode$3.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext$3(ctx, {
          code: ZodIssueCode$3.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID$3;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$3(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet14({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$3.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet14({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$3.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$3.create = (valueType, params) => {
  return new ZodSet$3({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$3.ZodSet,
    ...processCreateParams$3(params)
  });
};
let ZodFunction$1 = class ZodFunction2 extends ZodType$3 {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$3.function) {
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.function,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    function makeArgsIssue(args, error) {
      return makeIssue$3({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap$3(), errorMap$3].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode$3.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue$3({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap$3(), errorMap$3].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode$3.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise$3) {
      const me = this;
      return OK$3(async function(...args) {
        const error = new ZodError$3([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK$3(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError$3([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError$3([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction2({
      ...this._def,
      args: ZodTuple$3.create(items).rest(ZodUnknown$3.create())
    });
  }
  returns(returnType) {
    return new ZodFunction2({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction2({
      args: args ? args : ZodTuple$3.create([]).rest(ZodUnknown$3.create()),
      returns: returns || ZodUnknown$3.create(),
      typeName: ZodFirstPartyTypeKind$3.ZodFunction,
      ...processCreateParams$3(params)
    });
  }
};
let ZodLazy$3 = class ZodLazy14 extends ZodType$3 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$3.create = (getter, params) => {
  return new ZodLazy$3({
    getter,
    typeName: ZodFirstPartyTypeKind$3.ZodLazy,
    ...processCreateParams$3(params)
  });
};
let ZodLiteral$3 = class ZodLiteral14 extends ZodType$3 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx, {
        received: ctx.data,
        code: ZodIssueCode$3.invalid_literal,
        expected: this._def.value
      });
      return INVALID$3;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$3.create = (value, params) => {
  return new ZodLiteral$3({
    value,
    typeName: ZodFirstPartyTypeKind$3.ZodLiteral,
    ...processCreateParams$3(params)
  });
};
function createZodEnum$3(values, params) {
  return new ZodEnum$3({
    values,
    typeName: ZodFirstPartyTypeKind$3.ZodEnum,
    ...processCreateParams$3(params)
  });
}
let ZodEnum$3 = class ZodEnum14 extends ZodType$3 {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$3(ctx, {
        expected: util$3.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$3.invalid_type
      });
      return INVALID$3;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$3(ctx, {
        received: ctx.data,
        code: ZodIssueCode$3.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$3;
    }
    return OK$3(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum14.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum14.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum$3.create = createZodEnum$3;
let ZodNativeEnum$3 = class ZodNativeEnum14 extends ZodType$3 {
  _parse(input) {
    const nativeEnumValues = util$3.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$3.string && ctx.parsedType !== ZodParsedType$3.number) {
      const expectedValues = util$3.objectValues(nativeEnumValues);
      addIssueToContext$3(ctx, {
        expected: util$3.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$3.invalid_type
      });
      return INVALID$3;
    }
    if (!this._cache) {
      this._cache = new Set(util$3.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util$3.objectValues(nativeEnumValues);
      addIssueToContext$3(ctx, {
        received: ctx.data,
        code: ZodIssueCode$3.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$3;
    }
    return OK$3(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum$3.create = (values, params) => {
  return new ZodNativeEnum$3({
    values,
    typeName: ZodFirstPartyTypeKind$3.ZodNativeEnum,
    ...processCreateParams$3(params)
  });
};
let ZodPromise$3 = class ZodPromise14 extends ZodType$3 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$3.promise && ctx.common.async === false) {
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.promise,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    const promisified = ctx.parsedType === ZodParsedType$3.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$3(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$3.create = (schema, params) => {
  return new ZodPromise$3({
    type: schema,
    typeName: ZodFirstPartyTypeKind$3.ZodPromise,
    ...processCreateParams$3(params)
  });
};
let ZodEffects$3 = class ZodEffects14 extends ZodType$3 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$3.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$3(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$3;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$3;
          if (result.status === "dirty")
            return DIRTY$3(result.value);
          if (status.value === "dirty")
            return DIRTY$3(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$3;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$3;
        if (result.status === "dirty")
          return DIRTY$3(result.value);
        if (status.value === "dirty")
          return DIRTY$3(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$3;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$3;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$3(base))
          return INVALID$3;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$3(base))
            return INVALID$3;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util$3.assertNever(effect);
  }
};
ZodEffects$3.create = (schema, effect, params) => {
  return new ZodEffects$3({
    schema,
    typeName: ZodFirstPartyTypeKind$3.ZodEffects,
    effect,
    ...processCreateParams$3(params)
  });
};
ZodEffects$3.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$3({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$3.ZodEffects,
    ...processCreateParams$3(params)
  });
};
let ZodOptional$3 = class ZodOptional14 extends ZodType$3 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$3.undefined) {
      return OK$3(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$3.create = (type, params) => {
  return new ZodOptional$3({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$3.ZodOptional,
    ...processCreateParams$3(params)
  });
};
let ZodNullable$3 = class ZodNullable14 extends ZodType$3 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$3.null) {
      return OK$3(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$3.create = (type, params) => {
  return new ZodNullable$3({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$3.ZodNullable,
    ...processCreateParams$3(params)
  });
};
let ZodDefault$3 = class ZodDefault14 extends ZodType$3 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$3.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$3.create = (type, params) => {
  return new ZodDefault$3({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$3.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$3(params)
  });
};
let ZodCatch$3 = class ZodCatch14 extends ZodType$3 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$3(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$3(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$3(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$3.create = (type, params) => {
  return new ZodCatch$3({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$3.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$3(params)
  });
};
let ZodNaN$3 = class ZodNaN14 extends ZodType$3 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.nan,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$3.create = (params) => {
  return new ZodNaN$3({
    typeName: ZodFirstPartyTypeKind$3.ZodNaN,
    ...processCreateParams$3(params)
  });
};
let ZodBranded$3 = class ZodBranded14 extends ZodType$3 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$3 = class ZodPipeline14 extends ZodType$3 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$3;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$3(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$3;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline14({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$3.ZodPipeline
    });
  }
};
let ZodReadonly$3 = class ZodReadonly14 extends ZodType$3 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$3(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$3(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$3.create = (type, params) => {
  return new ZodReadonly$3({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$3.ZodReadonly,
    ...processCreateParams$3(params)
  });
};
var ZodFirstPartyTypeKind$3;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$3 || (ZodFirstPartyTypeKind$3 = {}));
const stringType$1 = ZodString$3.create;
const numberType$3 = ZodNumber$3.create;
ZodUnknown$3.create;
ZodNever$3.create;
ZodArray$3.create;
const objectType$3 = ZodObject$3.create;
const unionType$2 = ZodUnion$3.create;
ZodIntersection$3.create;
const tupleType$1 = ZodTuple$3.create;
const functionType$1 = ZodFunction$1.create;
ZodEnum$3.create;
const nativeEnumType$2 = ZodNativeEnum$3.create;
ZodPromise$3.create;
ZodOptional$3.create;
ZodNullable$3.create;
function measureText(font, text) {
  let x2 = 0;
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    const fontChar = font.chars[char];
    if (fontChar) {
      const fontKerning = font.kernings[char];
      const nextChar = text[i + 1];
      const kerning = fontKerning && nextChar && fontKerning[nextChar] ? fontKerning[nextChar] || 0 : 0;
      x2 += (fontChar.xadvance || 0) + kerning;
    }
  }
  return x2;
}
function splitLines(font, text, maxWidth) {
  const words = text.replace(/[\r\n]+/g, " \n").split(" ");
  const lines = [];
  let currentLine = [];
  let longestLine = 0;
  words.forEach((word) => {
    const wordWidth = measureText(font, word + (words.length > 1 ? " " : ""));
    if (wordWidth > maxWidth) {
      const characterIterator = word[Symbol.iterator]();
      let current = "";
      for (const char of characterIterator) {
        const nextLine = [...currentLine, current + char].join(" ");
        const length2 = measureText(font, nextLine);
        if (length2 < maxWidth) {
          current += char;
        } else if (length2 > maxWidth) {
          lines.push([...currentLine, current]);
          currentLine = [];
          current = char;
        } else {
          lines.push([...currentLine, current + char]);
          currentLine = [];
          current = "";
        }
      }
      return;
    }
    const line = [...currentLine, word].join(" ");
    const length = measureText(font, line);
    if (length <= maxWidth && !word.includes("\n")) {
      if (length > longestLine) {
        longestLine = length;
      }
      currentLine.push(word);
    } else {
      lines.push(currentLine);
      currentLine = [word.replace("\n", "")];
    }
  });
  lines.push(currentLine);
  return {
    lines,
    longestLine
  };
}
function measureTextHeight(font, text, maxWidth) {
  const { lines } = splitLines(font, text, maxWidth);
  return lines.length * font.common.lineHeight;
}
const PrintOptionsSchema = objectType$3({
  /** the x position to draw the image */
  x: numberType$3(),
  /** the y position to draw the image */
  y: numberType$3(),
  /** the text to print */
  text: unionType$2([
    unionType$2([stringType$1(), numberType$3()]),
    objectType$3({
      text: unionType$2([stringType$1(), numberType$3()]),
      alignmentX: nativeEnumType$2(HorizontalAlign).optional(),
      alignmentY: nativeEnumType$2(VerticalAlign).optional()
    })
  ]),
  /** the boundary width to draw in */
  maxWidth: numberType$3().optional(),
  /** the boundary height to draw in */
  maxHeight: numberType$3().optional(),
  /** a callback for when complete that ahs the end co-ordinates of the text */
  cb: functionType$1(tupleType$1([objectType$3({ x: numberType$3(), y: numberType$3() })])).optional()
});
function xOffsetBasedOnAlignment(font, line, maxWidth, alignment) {
  if (alignment === HorizontalAlign.LEFT) {
    return 0;
  }
  if (alignment === HorizontalAlign.CENTER) {
    return (maxWidth - measureText(font, line)) / 2;
  }
  return maxWidth - measureText(font, line);
}
function drawCharacter(image, font, x2, y2, char) {
  if (char.width > 0 && char.height > 0) {
    const characterPage = font.pages[char.page];
    if (characterPage) {
      image = methods$h.blit(image, {
        src: characterPage,
        x: x2 + char.xoffset,
        y: y2 + char.yoffset,
        srcX: char.x,
        srcY: char.y,
        srcW: char.width,
        srcH: char.height
      });
    }
  }
  return image;
}
function printText(image, font, x2, y2, text, defaultCharWidth) {
  for (let i = 0; i < text.length; i++) {
    const stringChar = text[i];
    let char;
    if (font.chars[stringChar]) {
      char = stringChar;
    } else if (/\s/.test(stringChar)) {
      char = "";
    } else {
      char = "?";
    }
    const fontChar = font.chars[char] || { xadvance: void 0 };
    const fontKerning = font.kernings[char];
    if (fontChar) {
      drawCharacter(image, font, x2, y2, fontChar);
    }
    const nextChar = text[i + 1];
    const kerning = fontKerning && nextChar && fontKerning[nextChar] ? fontKerning[nextChar] || 0 : 0;
    x2 += kerning + (fontChar.xadvance || defaultCharWidth);
  }
}
const methods$3 = {
  /**
   * Draws a text on a image on a given boundary
   * @param font a bitmap font loaded from `Jimp.loadFont` command
   * @param x the x position to start drawing the text
   * @param y the y position to start drawing the text
   * @param text the text to draw (string or object with `text`, `alignmentX`, and/or `alignmentY`)
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   * const font = await Jimp.loadFont(Jimp.FONT_SANS_32_BLACK);
   *
   * image.print({ font, x: 10, y: 10, text: "Hello world!" });
   * ```
   */
  print(image, { font, ...options }) {
    var _a;
    let {
      // eslint-disable-next-line prefer-const
      x: x2,
      y: y2,
      text,
      // eslint-disable-next-line prefer-const
      maxWidth = Infinity,
      // eslint-disable-next-line prefer-const
      maxHeight = Infinity,
      // eslint-disable-next-line prefer-const
      cb = () => {
      }
    } = PrintOptionsSchema.parse(options);
    let alignmentX;
    let alignmentY;
    if (typeof text === "object" && text.text !== null && text.text !== void 0) {
      alignmentX = text.alignmentX || HorizontalAlign.LEFT;
      alignmentY = text.alignmentY || VerticalAlign.TOP;
      ({ text } = text);
    } else {
      alignmentX = HorizontalAlign.LEFT;
      alignmentY = VerticalAlign.TOP;
      text = text.toString();
    }
    if (typeof text === "number") {
      text = text.toString();
    }
    if (maxHeight !== Infinity && alignmentY === VerticalAlign.BOTTOM) {
      y2 += maxHeight - measureTextHeight(font, text, maxWidth);
    } else if (maxHeight !== Infinity && alignmentY === VerticalAlign.MIDDLE) {
      y2 += maxHeight / 2 - measureTextHeight(font, text, maxWidth) / 2;
    }
    const defaultCharWidth = (_a = Object.entries(font.chars).find((c2) => c2[1].xadvance)) == null ? void 0 : _a[1].xadvance;
    if (typeof defaultCharWidth !== "number") {
      throw new Error("Could not find default character width");
    }
    const { lines, longestLine } = splitLines(font, text, maxWidth);
    lines.forEach((line) => {
      const lineString = line.join(" ");
      const alignmentWidth = xOffsetBasedOnAlignment(font, lineString, maxWidth, alignmentX);
      printText(image, font, x2 + alignmentWidth, y2, lineString, defaultCharWidth);
      y2 += font.common.lineHeight;
    });
    cb.bind(image)({ x: x2 + longestLine, y: y2 });
    return image;
  }
};
var util$2;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$2 || (util$2 = {}));
var objectUtil$2;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$2 || (objectUtil$2 = {}));
const ZodParsedType$2 = util$2.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$2.undefined;
    case "string":
      return ZodParsedType$2.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType$2.nan : ZodParsedType$2.number;
    case "boolean":
      return ZodParsedType$2.boolean;
    case "function":
      return ZodParsedType$2.function;
    case "bigint":
      return ZodParsedType$2.bigint;
    case "symbol":
      return ZodParsedType$2.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$2.array;
      }
      if (data === null) {
        return ZodParsedType$2.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$2.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$2.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$2.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$2.date;
      }
      return ZodParsedType$2.object;
    default:
      return ZodParsedType$2.unknown;
  }
};
const ZodIssueCode$2 = util$2.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
let ZodError$2 = class ZodError15 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue2 of error.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError15)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$2.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$2.create = (issues) => {
  const error = new ZodError$2(issues);
  return error;
};
const errorMap$2 = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode$2.invalid_type:
      if (issue2.received === ZodParsedType$2.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode$2.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util$2.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$2.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$2.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode$2.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$2.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$2.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode$2.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$2.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode$2.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$2.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$2.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$2.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util$2.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$2.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$2.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$2.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$2.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$2.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode$2.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$2.assertNever(issue2);
  }
  return { message };
};
let overrideErrorMap$2 = errorMap$2;
function getErrorMap$2() {
  return overrideErrorMap$2;
}
const makeIssue$2 = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext$2(ctx, issueData) {
  const overrideMap = getErrorMap$2();
  const issue2 = makeIssue$2({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$2 ? void 0 : errorMap$2
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue2);
}
let ParseStatus$2 = class ParseStatus15 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$2;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus15.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$2;
      if (value.status === "aborted")
        return INVALID$2;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$2 = Object.freeze({
  status: "aborted"
});
const DIRTY$2 = (value) => ({ status: "dirty", value });
const OK$2 = (value) => ({ status: "valid", value });
const isAborted$2 = (x2) => x2.status === "aborted";
const isDirty$2 = (x2) => x2.status === "dirty";
const isValid$2 = (x2) => x2.status === "valid";
const isAsync$2 = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil$2;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil$2 || (errorUtil$2 = {}));
let ParseInputLazyPath$2 = class ParseInputLazyPath15 {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$2 = (ctx, result) => {
  if (isValid$2(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$2(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$2(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$2 = class ZodType15 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$2(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$2(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$2(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$2(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$2(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: (params == null ? void 0 : params.async) ?? false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$2(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$2(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$2(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$2(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$2(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$2(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$2(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$2(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$2.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$2({
      schema: this,
      typeName: ZodFirstPartyTypeKind$2.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$2.create(this, this._def);
  }
  nullable() {
    return ZodNullable$2.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$2.create(this);
  }
  promise() {
    return ZodPromise$2.create(this, this._def);
  }
  or(option) {
    return ZodUnion$2.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$2.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects$2({
      ...processCreateParams$2(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$2.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault$2({
      ...processCreateParams$2(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$2.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$2({
      typeName: ZodFirstPartyTypeKind$2.ZodBranded,
      type: this,
      ...processCreateParams$2(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch$2({
      ...processCreateParams$2(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$2.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$2.create(this, target);
  }
  readonly() {
    return ZodReadonly$2.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$2 = /^c[^\s-]{8,}$/i;
const cuid2Regex$2 = /^[0-9a-z]+$/;
const ulidRegex$2 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$2 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$2 = /^[a-z0-9_-]{21}$/i;
const jwtRegex$2 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$2 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$2 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$2 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$2;
const ipv4Regex$2 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$2 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$2 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$2 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$2 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$2 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$2 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$2 = new RegExp(`^${dateRegexSource$2}$`);
function timeRegexSource$2(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex$2(args) {
  return new RegExp(`^${timeRegexSource$2(args)}$`);
}
function datetimeRegex$2(args) {
  let regex = `${dateRegexSource$2}T${timeRegexSource$2(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$2(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex$2.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex$2.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$2(jwt, alg) {
  if (!jwtRegex$2.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr$2(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex$2.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex$2.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$2 = class ZodString15 extends ZodType$2 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx2, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.string,
        received: ctx2.parsedType
      });
      return INVALID$2;
    }
    const status = new ParseStatus$2();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$2(ctx, {
              code: ZodIssueCode$2.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$2(ctx, {
              code: ZodIssueCode$2.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "email",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$2) {
          emojiRegex$2 = new RegExp(_emojiRegex$2, "u");
        }
        if (!emojiRegex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "emoji",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "uuid",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "cuid",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "ulid",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "url",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "regex",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$2(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$2;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$2(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "duration",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$2(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "ip",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$2(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "jwt",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$2(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "cidr",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "base64",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "base64url",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$2.invalid_string,
      ...errorUtil$2.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString15({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$2.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$2.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$2.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$2.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$2.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$2.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$2.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$2.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$2.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$2.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$2.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$2.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$2.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (options == null ? void 0 : options.offset) ?? false,
      local: (options == null ? void 0 : options.local) ?? false,
      ...errorUtil$2.errToObj(options == null ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      ...errorUtil$2.errToObj(options == null ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$2.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$2.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position,
      ...errorUtil$2.errToObj(options == null ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$2.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$2.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$2.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$2.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$2.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$2.errToObj(message));
  }
  trim() {
    return new ZodString15({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString15({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString15({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$2.create = (params) => {
  return new ZodString$2({
    checks: [],
    typeName: ZodFirstPartyTypeKind$2.ZodString,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$2(params)
  });
};
function floatSafeRemainder$2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
let ZodNumber$2 = class ZodNumber15 extends ZodType$2 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx2, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.number,
        received: ctx2.parsedType
      });
      return INVALID$2;
    }
    let ctx = void 0;
    const status = new ParseStatus$2();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$2.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$2(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$2.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$2.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$2.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$2.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber15({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$2.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber15({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$2.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$2.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$2.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$2.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$2.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$2.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$2.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$2.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$2.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$2.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$2.create = (params) => {
  return new ZodNumber$2({
    checks: [],
    typeName: ZodFirstPartyTypeKind$2.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$2(params)
  });
};
let ZodBigInt$2 = class ZodBigInt15 extends ZodType$2 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$2();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$2(ctx, {
      code: ZodIssueCode$2.invalid_type,
      expected: ZodParsedType$2.bigint,
      received: ctx.parsedType
    });
    return INVALID$2;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$2.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$2.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$2.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$2.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt15({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$2.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt15({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$2.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$2.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$2.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$2.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$2.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$2.create = (params) => {
  return new ZodBigInt$2({
    checks: [],
    typeName: ZodFirstPartyTypeKind$2.ZodBigInt,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$2(params)
  });
};
let ZodBoolean$2 = class ZodBoolean15 extends ZodType$2 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.boolean,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    return OK$2(input.data);
  }
};
ZodBoolean$2.create = (params) => {
  return new ZodBoolean$2({
    typeName: ZodFirstPartyTypeKind$2.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$2(params)
  });
};
let ZodDate$2 = class ZodDate15 extends ZodType$2 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx2, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.date,
        received: ctx2.parsedType
      });
      return INVALID$2;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx2, {
        code: ZodIssueCode$2.invalid_date
      });
      return INVALID$2;
    }
    const status = new ParseStatus$2();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate15({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$2.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$2.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$2.create = (params) => {
  return new ZodDate$2({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$2.ZodDate,
    ...processCreateParams$2(params)
  });
};
let ZodSymbol$2 = class ZodSymbol15 extends ZodType$2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.symbol,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    return OK$2(input.data);
  }
};
ZodSymbol$2.create = (params) => {
  return new ZodSymbol$2({
    typeName: ZodFirstPartyTypeKind$2.ZodSymbol,
    ...processCreateParams$2(params)
  });
};
let ZodUndefined$2 = class ZodUndefined15 extends ZodType$2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.undefined,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    return OK$2(input.data);
  }
};
ZodUndefined$2.create = (params) => {
  return new ZodUndefined$2({
    typeName: ZodFirstPartyTypeKind$2.ZodUndefined,
    ...processCreateParams$2(params)
  });
};
let ZodNull$2 = class ZodNull15 extends ZodType$2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.null,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    return OK$2(input.data);
  }
};
ZodNull$2.create = (params) => {
  return new ZodNull$2({
    typeName: ZodFirstPartyTypeKind$2.ZodNull,
    ...processCreateParams$2(params)
  });
};
let ZodAny$2 = class ZodAny15 extends ZodType$2 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$2(input.data);
  }
};
ZodAny$2.create = (params) => {
  return new ZodAny$2({
    typeName: ZodFirstPartyTypeKind$2.ZodAny,
    ...processCreateParams$2(params)
  });
};
let ZodUnknown$2 = class ZodUnknown15 extends ZodType$2 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$2(input.data);
  }
};
ZodUnknown$2.create = (params) => {
  return new ZodUnknown$2({
    typeName: ZodFirstPartyTypeKind$2.ZodUnknown,
    ...processCreateParams$2(params)
  });
};
let ZodNever$2 = class ZodNever15 extends ZodType$2 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$2(ctx, {
      code: ZodIssueCode$2.invalid_type,
      expected: ZodParsedType$2.never,
      received: ctx.parsedType
    });
    return INVALID$2;
  }
};
ZodNever$2.create = (params) => {
  return new ZodNever$2({
    typeName: ZodFirstPartyTypeKind$2.ZodNever,
    ...processCreateParams$2(params)
  });
};
let ZodVoid$2 = class ZodVoid15 extends ZodType$2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.void,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    return OK$2(input.data);
  }
};
ZodVoid$2.create = (params) => {
  return new ZodVoid$2({
    typeName: ZodFirstPartyTypeKind$2.ZodVoid,
    ...processCreateParams$2(params)
  });
};
let ZodArray$2 = class ZodArray15 extends ZodType$2 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType$2.array) {
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.array,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$2(ctx, {
          code: tooBig ? ZodIssueCode$2.too_big : ZodIssueCode$2.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext$2(ctx, {
          code: ZodIssueCode$2.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext$2(ctx, {
          code: ZodIssueCode$2.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath$2(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$2.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath$2(ctx, item, ctx.path, i));
    });
    return ParseStatus$2.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray15({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$2.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray15({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$2.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray15({
      ...this._def,
      exactLength: { value: len, message: errorUtil$2.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$2.create = (schema, params) => {
  return new ZodArray$2({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$2.ZodArray,
    ...processCreateParams$2(params)
  });
};
function deepPartialify$2(schema) {
  if (schema instanceof ZodObject$2) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$2.create(deepPartialify$2(fieldSchema));
    }
    return new ZodObject$2({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$2) {
    return new ZodArray$2({
      ...schema._def,
      type: deepPartialify$2(schema.element)
    });
  } else if (schema instanceof ZodOptional$2) {
    return ZodOptional$2.create(deepPartialify$2(schema.unwrap()));
  } else if (schema instanceof ZodNullable$2) {
    return ZodNullable$2.create(deepPartialify$2(schema.unwrap()));
  } else if (schema instanceof ZodTuple$2) {
    return ZodTuple$2.create(schema.items.map((item) => deepPartialify$2(item)));
  } else {
    return schema;
  }
}
let ZodObject$2 = class ZodObject15 extends ZodType$2 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$2.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx2, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.object,
        received: ctx2.parsedType
      });
      return INVALID$2;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$2 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$2(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$2) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$2(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$2.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$2.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$2.errToObj;
    return new ZodObject15({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          var _a, _b;
          const defaultError = ((_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue2, ctx).message) ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil$2.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject15({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject15({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject15({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject15({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$2.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject15({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util$2.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject15({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util$2.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject15({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$2(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util$2.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject15({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util$2.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$2) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject15({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$2(util$2.objectKeys(this.shape));
  }
};
ZodObject$2.create = (shape, params) => {
  return new ZodObject$2({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$2.create(),
    typeName: ZodFirstPartyTypeKind$2.ZodObject,
    ...processCreateParams$2(params)
  });
};
ZodObject$2.strictCreate = (shape, params) => {
  return new ZodObject$2({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$2.create(),
    typeName: ZodFirstPartyTypeKind$2.ZodObject,
    ...processCreateParams$2(params)
  });
};
ZodObject$2.lazycreate = (shape, params) => {
  return new ZodObject$2({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$2.create(),
    typeName: ZodFirstPartyTypeKind$2.ZodObject,
    ...processCreateParams$2(params)
  });
};
let ZodUnion$2 = class ZodUnion15 extends ZodType$2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$2(result.ctx.common.issues));
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_union,
        unionErrors
      });
      return INVALID$2;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$2(issues2));
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_union,
        unionErrors
      });
      return INVALID$2;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$2.create = (types, params) => {
  return new ZodUnion$2({
    options: types,
    typeName: ZodFirstPartyTypeKind$2.ZodUnion,
    ...processCreateParams$2(params)
  });
};
function mergeValues$2(a, b) {
  const aType = getParsedType$2(a);
  const bType = getParsedType$2(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$2.object && bType === ZodParsedType$2.object) {
    const bKeys = util$2.objectKeys(b);
    const sharedKeys = util$2.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$2(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$2.array && bType === ZodParsedType$2.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$2(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$2.date && bType === ZodParsedType$2.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$2 = class ZodIntersection15 extends ZodType$2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$2(parsedLeft) || isAborted$2(parsedRight)) {
        return INVALID$2;
      }
      const merged = mergeValues$2(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$2(ctx, {
          code: ZodIssueCode$2.invalid_intersection_types
        });
        return INVALID$2;
      }
      if (isDirty$2(parsedLeft) || isDirty$2(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$2.create = (left, right, params) => {
  return new ZodIntersection$2({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$2.ZodIntersection,
    ...processCreateParams$2(params)
  });
};
let ZodTuple$2 = class ZodTuple15 extends ZodType$2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$2.array) {
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.array,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$2;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$2(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$2.mergeArray(status, results);
      });
    } else {
      return ParseStatus$2.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple15({
      ...this._def,
      rest
    });
  }
};
ZodTuple$2.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$2({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$2.ZodTuple,
    rest: null,
    ...processCreateParams$2(params)
  });
};
let ZodMap$2 = class ZodMap15 extends ZodType$2 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$2.map) {
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.map,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$2(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$2(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$2;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$2;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$2.create = (keyType, valueType, params) => {
  return new ZodMap$2({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$2.ZodMap,
    ...processCreateParams$2(params)
  });
};
let ZodSet$2 = class ZodSet15 extends ZodType$2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$2.set) {
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.set,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext$2(ctx, {
          code: ZodIssueCode$2.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext$2(ctx, {
          code: ZodIssueCode$2.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID$2;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$2(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet15({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$2.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet15({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$2.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$2.create = (valueType, params) => {
  return new ZodSet$2({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$2.ZodSet,
    ...processCreateParams$2(params)
  });
};
let ZodLazy$2 = class ZodLazy15 extends ZodType$2 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$2.create = (getter, params) => {
  return new ZodLazy$2({
    getter,
    typeName: ZodFirstPartyTypeKind$2.ZodLazy,
    ...processCreateParams$2(params)
  });
};
let ZodLiteral$2 = class ZodLiteral15 extends ZodType$2 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx, {
        received: ctx.data,
        code: ZodIssueCode$2.invalid_literal,
        expected: this._def.value
      });
      return INVALID$2;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$2.create = (value, params) => {
  return new ZodLiteral$2({
    value,
    typeName: ZodFirstPartyTypeKind$2.ZodLiteral,
    ...processCreateParams$2(params)
  });
};
function createZodEnum$2(values, params) {
  return new ZodEnum$2({
    values,
    typeName: ZodFirstPartyTypeKind$2.ZodEnum,
    ...processCreateParams$2(params)
  });
}
let ZodEnum$2 = class ZodEnum15 extends ZodType$2 {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$2(ctx, {
        expected: util$2.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$2.invalid_type
      });
      return INVALID$2;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$2(ctx, {
        received: ctx.data,
        code: ZodIssueCode$2.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$2;
    }
    return OK$2(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum15.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum15.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum$2.create = createZodEnum$2;
let ZodNativeEnum$2 = class ZodNativeEnum15 extends ZodType$2 {
  _parse(input) {
    const nativeEnumValues = util$2.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$2.string && ctx.parsedType !== ZodParsedType$2.number) {
      const expectedValues = util$2.objectValues(nativeEnumValues);
      addIssueToContext$2(ctx, {
        expected: util$2.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$2.invalid_type
      });
      return INVALID$2;
    }
    if (!this._cache) {
      this._cache = new Set(util$2.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util$2.objectValues(nativeEnumValues);
      addIssueToContext$2(ctx, {
        received: ctx.data,
        code: ZodIssueCode$2.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$2;
    }
    return OK$2(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum$2.create = (values, params) => {
  return new ZodNativeEnum$2({
    values,
    typeName: ZodFirstPartyTypeKind$2.ZodNativeEnum,
    ...processCreateParams$2(params)
  });
};
let ZodPromise$2 = class ZodPromise15 extends ZodType$2 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$2.promise && ctx.common.async === false) {
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.promise,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    const promisified = ctx.parsedType === ZodParsedType$2.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$2(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$2.create = (schema, params) => {
  return new ZodPromise$2({
    type: schema,
    typeName: ZodFirstPartyTypeKind$2.ZodPromise,
    ...processCreateParams$2(params)
  });
};
let ZodEffects$2 = class ZodEffects15 extends ZodType$2 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$2.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$2(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$2;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$2;
          if (result.status === "dirty")
            return DIRTY$2(result.value);
          if (status.value === "dirty")
            return DIRTY$2(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$2;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$2;
        if (result.status === "dirty")
          return DIRTY$2(result.value);
        if (status.value === "dirty")
          return DIRTY$2(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$2;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$2;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$2(base))
          return INVALID$2;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$2(base))
            return INVALID$2;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util$2.assertNever(effect);
  }
};
ZodEffects$2.create = (schema, effect, params) => {
  return new ZodEffects$2({
    schema,
    typeName: ZodFirstPartyTypeKind$2.ZodEffects,
    effect,
    ...processCreateParams$2(params)
  });
};
ZodEffects$2.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$2({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$2.ZodEffects,
    ...processCreateParams$2(params)
  });
};
let ZodOptional$2 = class ZodOptional15 extends ZodType$2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$2.undefined) {
      return OK$2(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$2.create = (type, params) => {
  return new ZodOptional$2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$2.ZodOptional,
    ...processCreateParams$2(params)
  });
};
let ZodNullable$2 = class ZodNullable15 extends ZodType$2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$2.null) {
      return OK$2(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$2.create = (type, params) => {
  return new ZodNullable$2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$2.ZodNullable,
    ...processCreateParams$2(params)
  });
};
let ZodDefault$2 = class ZodDefault15 extends ZodType$2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$2.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$2.create = (type, params) => {
  return new ZodDefault$2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$2.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$2(params)
  });
};
let ZodCatch$2 = class ZodCatch15 extends ZodType$2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$2(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$2(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$2(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$2.create = (type, params) => {
  return new ZodCatch$2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$2.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$2(params)
  });
};
let ZodNaN$2 = class ZodNaN15 extends ZodType$2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.nan,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$2.create = (params) => {
  return new ZodNaN$2({
    typeName: ZodFirstPartyTypeKind$2.ZodNaN,
    ...processCreateParams$2(params)
  });
};
let ZodBranded$2 = class ZodBranded15 extends ZodType$2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$2 = class ZodPipeline15 extends ZodType$2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$2;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$2(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$2;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline15({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$2.ZodPipeline
    });
  }
};
let ZodReadonly$2 = class ZodReadonly15 extends ZodType$2 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$2(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$2(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$2.create = (type, params) => {
  return new ZodReadonly$2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$2.ZodReadonly,
    ...processCreateParams$2(params)
  });
};
var ZodFirstPartyTypeKind$2;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$2 || (ZodFirstPartyTypeKind$2 = {}));
const numberType$2 = ZodNumber$2.create;
const booleanType$2 = ZodBoolean$2.create;
ZodNever$2.create;
ZodArray$2.create;
const objectType$2 = ZodObject$2.create;
const unionType$1 = ZodUnion$2.create;
ZodIntersection$2.create;
ZodTuple$2.create;
ZodEnum$2.create;
const nativeEnumType$1 = ZodNativeEnum$2.create;
ZodPromise$2.create;
ZodOptional$2.create;
ZodNullable$2.create;
const RotateOptionsSchema = unionType$1([
  numberType$2(),
  objectType$2({
    /** the number of degrees to rotate the image by */
    deg: numberType$2(),
    /** resize mode or a boolean, if false then the width and height of the image will not be changed */
    mode: unionType$1([booleanType$2(), nativeEnumType$1(ResizeStrategy)]).optional()
  })
]);
function createIdxTranslationFunction(w) {
  return function(x2, y2) {
    return y2 * w + x2 << 2;
  };
}
function matrixRotate(image, deg) {
  if (Math.abs(deg) % 90 !== 0) {
    throw new Error("Unsupported matrix rotation degree");
  }
  const w = image.bitmap.width;
  const h = image.bitmap.height;
  let angle;
  switch (deg) {
    case 90:
    case -270:
      angle = 90;
      break;
    case 180:
    case -180:
      angle = 180;
      break;
    case 270:
    case -90:
      angle = -90;
      break;
    default:
      throw new Error("Unsupported matrix rotation degree");
  }
  const nW = angle === 180 ? w : h;
  const nH = angle === 180 ? h : w;
  const dstBuffer = Buffer.alloc(image.bitmap.data.length);
  const srcIdxFunction = createIdxTranslationFunction(w);
  const dstIdxFunction = createIdxTranslationFunction(nW);
  for (let x2 = 0; x2 < w; x2++) {
    for (let y2 = 0; y2 < h; y2++) {
      const srcIdx = srcIdxFunction(x2, y2);
      const pixelRGBA = image.bitmap.data.readUInt32BE(srcIdx);
      let dstIdx;
      switch (angle) {
        case 90:
          dstIdx = dstIdxFunction(y2, w - x2 - 1);
          break;
        case -90:
          dstIdx = dstIdxFunction(h - y2 - 1, x2);
          break;
        case 180:
          dstIdx = dstIdxFunction(w - x2 - 1, h - y2 - 1);
          break;
        default:
          throw new Error("Unsupported matrix rotation angle");
      }
      dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);
    }
  }
  image.bitmap.data = dstBuffer;
  image.bitmap.width = nW;
  image.bitmap.height = nH;
}
function createTranslationFunction(deltaX, deltaY) {
  return function(x2, y2) {
    return {
      x: x2 + deltaX,
      y: y2 + deltaY
    };
  };
}
function advancedRotate(image, deg, mode) {
  const rad = deg * Math.PI / 180;
  const cosine = Math.cos(rad);
  const sine = Math.sin(rad);
  let w = image.bitmap.width;
  let h = image.bitmap.height;
  if (mode === true || typeof mode === "string") {
    w = Math.ceil(Math.abs(image.bitmap.width * cosine) + Math.abs(image.bitmap.height * sine)) + 1;
    h = Math.ceil(Math.abs(image.bitmap.width * sine) + Math.abs(image.bitmap.height * cosine)) + 1;
    if (w % 2 !== 0) {
      w++;
    }
    if (h % 2 !== 0) {
      h++;
    }
    const c2 = clone(image);
    image.scan((_, __, idx) => {
      image.bitmap.data.writeUInt32BE(image.background, idx);
    });
    const max = Math.max(w, h, image.bitmap.width, image.bitmap.height);
    image = methods$d.resize(image, {
      h: max,
      w: max,
      mode: mode === true ? void 0 : mode
    });
    image = composite(image, c2, image.bitmap.width / 2 - c2.bitmap.width / 2, image.bitmap.height / 2 - c2.bitmap.height / 2);
  }
  const bW = image.bitmap.width;
  const bH = image.bitmap.height;
  const dstBuffer = Buffer.alloc(image.bitmap.data.length);
  const translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));
  const translate2Screen = createTranslationFunction(bW / 2 + 0.5, bH / 2 + 0.5);
  for (let y2 = 1; y2 <= bH; y2++) {
    for (let x2 = 1; x2 <= bW; x2++) {
      const cartesian = translate2Cartesian(x2, y2);
      const source = translate2Screen(cosine * cartesian.x - sine * cartesian.y, cosine * cartesian.y + sine * cartesian.x);
      const dstIdx = bW * (y2 - 1) + x2 - 1 << 2;
      if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {
        const srcIdx = (bW * (source.y | 0) + source.x | 0) << 2;
        const pixelRGBA = image.bitmap.data.readUInt32BE(srcIdx);
        dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);
      } else {
        dstBuffer.writeUInt32BE(image.background, dstIdx);
      }
    }
  }
  image.bitmap.data = dstBuffer;
  if (mode === true || typeof mode === "string") {
    const x2 = Math.max(bW / 2 - w / 2, 0);
    const y2 = Math.max(bH / 2 - h / 2, 0);
    image = methods$b.crop(image, { x: x2, y: y2, w, h });
  }
}
const methods$2 = {
  /**
   * Rotates the image counter-clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.rotate(90);
   * ```
   */
  rotate(image, options) {
    const parsed = RotateOptionsSchema.parse(options);
    const actualOptions = typeof parsed === "number" ? { deg: parsed } : parsed;
    const { mode = true } = actualOptions;
    let { deg } = actualOptions;
    deg %= 360;
    if (deg % 360 === 0) {
      return image;
    }
    const matrixRotateAllowed = deg % 90 === 0 && (mode || image.bitmap.width === image.bitmap.height || deg % 180 === 0);
    if (matrixRotateAllowed) {
      matrixRotate(image, deg);
    } else {
      advancedRotate(image, deg, mode);
    }
    return image;
  }
};
var util$1;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$1 || (util$1 = {}));
var objectUtil$1;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$1 || (objectUtil$1 = {}));
const ZodParsedType$1 = util$1.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$1 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$1.undefined;
    case "string":
      return ZodParsedType$1.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType$1.nan : ZodParsedType$1.number;
    case "boolean":
      return ZodParsedType$1.boolean;
    case "function":
      return ZodParsedType$1.function;
    case "bigint":
      return ZodParsedType$1.bigint;
    case "symbol":
      return ZodParsedType$1.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$1.array;
      }
      if (data === null) {
        return ZodParsedType$1.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$1.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$1.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$1.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$1.date;
      }
      return ZodParsedType$1.object;
    default:
      return ZodParsedType$1.unknown;
  }
};
const ZodIssueCode$1 = util$1.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
let ZodError$1 = class ZodError16 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue2 of error.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError16)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$1.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$1.create = (issues) => {
  const error = new ZodError$1(issues);
  return error;
};
const errorMap$1 = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode$1.invalid_type:
      if (issue2.received === ZodParsedType$1.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode$1.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util$1.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$1.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$1.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode$1.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$1.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$1.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode$1.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$1.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode$1.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$1.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$1.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$1.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util$1.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$1.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$1.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$1.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$1.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$1.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode$1.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$1.assertNever(issue2);
  }
  return { message };
};
let overrideErrorMap$1 = errorMap$1;
function getErrorMap$1() {
  return overrideErrorMap$1;
}
const makeIssue$1 = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext$1(ctx, issueData) {
  const overrideMap = getErrorMap$1();
  const issue2 = makeIssue$1({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$1 ? void 0 : errorMap$1
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue2);
}
let ParseStatus$1 = class ParseStatus16 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$1;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus16.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$1;
      if (value.status === "aborted")
        return INVALID$1;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$1 = Object.freeze({
  status: "aborted"
});
const DIRTY$1 = (value) => ({ status: "dirty", value });
const OK$1 = (value) => ({ status: "valid", value });
const isAborted$1 = (x2) => x2.status === "aborted";
const isDirty$1 = (x2) => x2.status === "dirty";
const isValid$1 = (x2) => x2.status === "valid";
const isAsync$1 = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil$1;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil$1 || (errorUtil$1 = {}));
let ParseInputLazyPath$1 = class ParseInputLazyPath16 {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$1 = (ctx, result) => {
  if (isValid$1(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$1(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$1(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$1 = class ZodType16 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$1(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$1(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$1(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$1(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$1(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: (params == null ? void 0 : params.async) ?? false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$1(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$1(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$1(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$1(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$1(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$1(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$1(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$1(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$1.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$1({
      schema: this,
      typeName: ZodFirstPartyTypeKind$1.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$1.create(this, this._def);
  }
  nullable() {
    return ZodNullable$1.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$1.create(this);
  }
  promise() {
    return ZodPromise$1.create(this, this._def);
  }
  or(option) {
    return ZodUnion$1.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$1.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects$1({
      ...processCreateParams$1(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$1.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault$1({
      ...processCreateParams$1(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$1.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$1({
      typeName: ZodFirstPartyTypeKind$1.ZodBranded,
      type: this,
      ...processCreateParams$1(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch$1({
      ...processCreateParams$1(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$1.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$1.create(this, target);
  }
  readonly() {
    return ZodReadonly$1.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$1 = /^c[^\s-]{8,}$/i;
const cuid2Regex$1 = /^[0-9a-z]+$/;
const ulidRegex$1 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$1 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$1 = /^[a-z0-9_-]{21}$/i;
const jwtRegex$1 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$1 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$1 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$1;
const ipv4Regex$1 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$1 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$1 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$1 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$1 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$1 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$1 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$1 = new RegExp(`^${dateRegexSource$1}$`);
function timeRegexSource$1(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex$1(args) {
  return new RegExp(`^${timeRegexSource$1(args)}$`);
}
function datetimeRegex$1(args) {
  let regex = `${dateRegexSource$1}T${timeRegexSource$1(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$1(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex$1.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex$1.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$1(jwt, alg) {
  if (!jwtRegex$1.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr$1(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex$1.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex$1.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$1 = class ZodString16 extends ZodType$1 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx2, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.string,
        received: ctx2.parsedType
      });
      return INVALID$1;
    }
    const status = new ParseStatus$1();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "email",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$1) {
          emojiRegex$1 = new RegExp(_emojiRegex$1, "u");
        }
        if (!emojiRegex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "emoji",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "uuid",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "cuid",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "ulid",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "url",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "regex",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$1(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$1;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$1(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "duration",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$1(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "ip",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$1(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "jwt",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$1(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "cidr",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "base64",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "base64url",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$1.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$1.invalid_string,
      ...errorUtil$1.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString16({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$1.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$1.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$1.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$1.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$1.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$1.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$1.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$1.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$1.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$1.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$1.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$1.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$1.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (options == null ? void 0 : options.offset) ?? false,
      local: (options == null ? void 0 : options.local) ?? false,
      ...errorUtil$1.errToObj(options == null ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      ...errorUtil$1.errToObj(options == null ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$1.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$1.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position,
      ...errorUtil$1.errToObj(options == null ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$1.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$1.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$1.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$1.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$1.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$1.errToObj(message));
  }
  trim() {
    return new ZodString16({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString16({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString16({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$1.create = (params) => {
  return new ZodString$1({
    checks: [],
    typeName: ZodFirstPartyTypeKind$1.ZodString,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$1(params)
  });
};
function floatSafeRemainder$1(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
let ZodNumber$1 = class ZodNumber16 extends ZodType$1 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx2, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.number,
        received: ctx2.parsedType
      });
      return INVALID$1;
    }
    let ctx = void 0;
    const status = new ParseStatus$1();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$1.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$1(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$1.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$1.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$1.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$1.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$1.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber16({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$1.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber16({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$1.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$1.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$1.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$1.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$1.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$1.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$1.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$1.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$1.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$1.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$1.create = (params) => {
  return new ZodNumber$1({
    checks: [],
    typeName: ZodFirstPartyTypeKind$1.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$1(params)
  });
};
let ZodBigInt$1 = class ZodBigInt16 extends ZodType$1 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$1();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$1.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$1(ctx, {
      code: ZodIssueCode$1.invalid_type,
      expected: ZodParsedType$1.bigint,
      received: ctx.parsedType
    });
    return INVALID$1;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$1.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$1.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$1.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$1.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt16({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$1.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt16({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$1.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$1.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$1.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$1.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$1.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$1.create = (params) => {
  return new ZodBigInt$1({
    checks: [],
    typeName: ZodFirstPartyTypeKind$1.ZodBigInt,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams$1(params)
  });
};
let ZodBoolean$1 = class ZodBoolean16 extends ZodType$1 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.boolean,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    return OK$1(input.data);
  }
};
ZodBoolean$1.create = (params) => {
  return new ZodBoolean$1({
    typeName: ZodFirstPartyTypeKind$1.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams$1(params)
  });
};
let ZodDate$1 = class ZodDate16 extends ZodType$1 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx2, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.date,
        received: ctx2.parsedType
      });
      return INVALID$1;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx2, {
        code: ZodIssueCode$1.invalid_date
      });
      return INVALID$1;
    }
    const status = new ParseStatus$1();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$1.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate16({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$1.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$1.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$1.create = (params) => {
  return new ZodDate$1({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$1.ZodDate,
    ...processCreateParams$1(params)
  });
};
let ZodSymbol$1 = class ZodSymbol16 extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.symbol,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    return OK$1(input.data);
  }
};
ZodSymbol$1.create = (params) => {
  return new ZodSymbol$1({
    typeName: ZodFirstPartyTypeKind$1.ZodSymbol,
    ...processCreateParams$1(params)
  });
};
let ZodUndefined$1 = class ZodUndefined16 extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.undefined,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    return OK$1(input.data);
  }
};
ZodUndefined$1.create = (params) => {
  return new ZodUndefined$1({
    typeName: ZodFirstPartyTypeKind$1.ZodUndefined,
    ...processCreateParams$1(params)
  });
};
let ZodNull$1 = class ZodNull16 extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.null,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    return OK$1(input.data);
  }
};
ZodNull$1.create = (params) => {
  return new ZodNull$1({
    typeName: ZodFirstPartyTypeKind$1.ZodNull,
    ...processCreateParams$1(params)
  });
};
let ZodAny$1 = class ZodAny16 extends ZodType$1 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$1(input.data);
  }
};
ZodAny$1.create = (params) => {
  return new ZodAny$1({
    typeName: ZodFirstPartyTypeKind$1.ZodAny,
    ...processCreateParams$1(params)
  });
};
let ZodUnknown$1 = class ZodUnknown16 extends ZodType$1 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$1(input.data);
  }
};
ZodUnknown$1.create = (params) => {
  return new ZodUnknown$1({
    typeName: ZodFirstPartyTypeKind$1.ZodUnknown,
    ...processCreateParams$1(params)
  });
};
let ZodNever$1 = class ZodNever16 extends ZodType$1 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$1(ctx, {
      code: ZodIssueCode$1.invalid_type,
      expected: ZodParsedType$1.never,
      received: ctx.parsedType
    });
    return INVALID$1;
  }
};
ZodNever$1.create = (params) => {
  return new ZodNever$1({
    typeName: ZodFirstPartyTypeKind$1.ZodNever,
    ...processCreateParams$1(params)
  });
};
let ZodVoid$1 = class ZodVoid16 extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.void,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    return OK$1(input.data);
  }
};
ZodVoid$1.create = (params) => {
  return new ZodVoid$1({
    typeName: ZodFirstPartyTypeKind$1.ZodVoid,
    ...processCreateParams$1(params)
  });
};
let ZodArray$1 = class ZodArray16 extends ZodType$1 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType$1.array) {
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.array,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$1(ctx, {
          code: tooBig ? ZodIssueCode$1.too_big : ZodIssueCode$1.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath$1(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$1.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath$1(ctx, item, ctx.path, i));
    });
    return ParseStatus$1.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray16({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$1.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray16({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$1.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray16({
      ...this._def,
      exactLength: { value: len, message: errorUtil$1.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$1.create = (schema, params) => {
  return new ZodArray$1({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$1.ZodArray,
    ...processCreateParams$1(params)
  });
};
function deepPartialify$1(schema) {
  if (schema instanceof ZodObject$1) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$1.create(deepPartialify$1(fieldSchema));
    }
    return new ZodObject$1({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$1) {
    return new ZodArray$1({
      ...schema._def,
      type: deepPartialify$1(schema.element)
    });
  } else if (schema instanceof ZodOptional$1) {
    return ZodOptional$1.create(deepPartialify$1(schema.unwrap()));
  } else if (schema instanceof ZodNullable$1) {
    return ZodNullable$1.create(deepPartialify$1(schema.unwrap()));
  } else if (schema instanceof ZodTuple$1) {
    return ZodTuple$1.create(schema.items.map((item) => deepPartialify$1(item)));
  } else {
    return schema;
  }
}
let ZodObject$1 = class ZodObject16 extends ZodType$1 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$1.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx2, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.object,
        received: ctx2.parsedType
      });
      return INVALID$1;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$1 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$1(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$1) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$1(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$1.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$1.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$1.errToObj;
    return new ZodObject16({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          var _a, _b;
          const defaultError = ((_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue2, ctx).message) ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil$1.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject16({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject16({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject16({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject16({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$1.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject16({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util$1.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject16({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util$1.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject16({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$1(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util$1.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject16({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util$1.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$1) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject16({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$1(util$1.objectKeys(this.shape));
  }
};
ZodObject$1.create = (shape, params) => {
  return new ZodObject$1({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$1.create(),
    typeName: ZodFirstPartyTypeKind$1.ZodObject,
    ...processCreateParams$1(params)
  });
};
ZodObject$1.strictCreate = (shape, params) => {
  return new ZodObject$1({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$1.create(),
    typeName: ZodFirstPartyTypeKind$1.ZodObject,
    ...processCreateParams$1(params)
  });
};
ZodObject$1.lazycreate = (shape, params) => {
  return new ZodObject$1({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$1.create(),
    typeName: ZodFirstPartyTypeKind$1.ZodObject,
    ...processCreateParams$1(params)
  });
};
let ZodUnion$1 = class ZodUnion16 extends ZodType$1 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$1(result.ctx.common.issues));
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_union,
        unionErrors
      });
      return INVALID$1;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$1(issues2));
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_union,
        unionErrors
      });
      return INVALID$1;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$1.create = (types, params) => {
  return new ZodUnion$1({
    options: types,
    typeName: ZodFirstPartyTypeKind$1.ZodUnion,
    ...processCreateParams$1(params)
  });
};
function mergeValues$1(a, b) {
  const aType = getParsedType$1(a);
  const bType = getParsedType$1(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$1.object && bType === ZodParsedType$1.object) {
    const bKeys = util$1.objectKeys(b);
    const sharedKeys = util$1.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$1(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$1.array && bType === ZodParsedType$1.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$1(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$1.date && bType === ZodParsedType$1.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$1 = class ZodIntersection16 extends ZodType$1 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$1(parsedLeft) || isAborted$1(parsedRight)) {
        return INVALID$1;
      }
      const merged = mergeValues$1(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.invalid_intersection_types
        });
        return INVALID$1;
      }
      if (isDirty$1(parsedLeft) || isDirty$1(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$1.create = (left, right, params) => {
  return new ZodIntersection$1({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$1.ZodIntersection,
    ...processCreateParams$1(params)
  });
};
let ZodTuple$1 = class ZodTuple16 extends ZodType$1 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$1.array) {
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.array,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$1;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$1(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$1.mergeArray(status, results);
      });
    } else {
      return ParseStatus$1.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple16({
      ...this._def,
      rest
    });
  }
};
ZodTuple$1.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$1({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$1.ZodTuple,
    rest: null,
    ...processCreateParams$1(params)
  });
};
let ZodMap$1 = class ZodMap16 extends ZodType$1 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$1.map) {
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.map,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$1(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$1(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$1;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$1;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$1.create = (keyType, valueType, params) => {
  return new ZodMap$1({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$1.ZodMap,
    ...processCreateParams$1(params)
  });
};
let ZodSet$1 = class ZodSet16 extends ZodType$1 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$1.set) {
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.set,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID$1;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$1(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet16({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$1.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet16({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$1.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$1.create = (valueType, params) => {
  return new ZodSet$1({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$1.ZodSet,
    ...processCreateParams$1(params)
  });
};
let ZodLazy$1 = class ZodLazy16 extends ZodType$1 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$1.create = (getter, params) => {
  return new ZodLazy$1({
    getter,
    typeName: ZodFirstPartyTypeKind$1.ZodLazy,
    ...processCreateParams$1(params)
  });
};
let ZodLiteral$1 = class ZodLiteral16 extends ZodType$1 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx, {
        received: ctx.data,
        code: ZodIssueCode$1.invalid_literal,
        expected: this._def.value
      });
      return INVALID$1;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$1.create = (value, params) => {
  return new ZodLiteral$1({
    value,
    typeName: ZodFirstPartyTypeKind$1.ZodLiteral,
    ...processCreateParams$1(params)
  });
};
function createZodEnum$1(values, params) {
  return new ZodEnum$1({
    values,
    typeName: ZodFirstPartyTypeKind$1.ZodEnum,
    ...processCreateParams$1(params)
  });
}
let ZodEnum$1 = class ZodEnum16 extends ZodType$1 {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$1(ctx, {
        expected: util$1.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$1.invalid_type
      });
      return INVALID$1;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$1(ctx, {
        received: ctx.data,
        code: ZodIssueCode$1.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$1;
    }
    return OK$1(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum16.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum16.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum$1.create = createZodEnum$1;
let ZodNativeEnum$1 = class ZodNativeEnum16 extends ZodType$1 {
  _parse(input) {
    const nativeEnumValues = util$1.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$1.string && ctx.parsedType !== ZodParsedType$1.number) {
      const expectedValues = util$1.objectValues(nativeEnumValues);
      addIssueToContext$1(ctx, {
        expected: util$1.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$1.invalid_type
      });
      return INVALID$1;
    }
    if (!this._cache) {
      this._cache = new Set(util$1.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util$1.objectValues(nativeEnumValues);
      addIssueToContext$1(ctx, {
        received: ctx.data,
        code: ZodIssueCode$1.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$1;
    }
    return OK$1(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum$1.create = (values, params) => {
  return new ZodNativeEnum$1({
    values,
    typeName: ZodFirstPartyTypeKind$1.ZodNativeEnum,
    ...processCreateParams$1(params)
  });
};
let ZodPromise$1 = class ZodPromise16 extends ZodType$1 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$1.promise && ctx.common.async === false) {
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.promise,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    const promisified = ctx.parsedType === ZodParsedType$1.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$1(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$1.create = (schema, params) => {
  return new ZodPromise$1({
    type: schema,
    typeName: ZodFirstPartyTypeKind$1.ZodPromise,
    ...processCreateParams$1(params)
  });
};
let ZodEffects$1 = class ZodEffects16 extends ZodType$1 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$1.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$1(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$1;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$1;
          if (result.status === "dirty")
            return DIRTY$1(result.value);
          if (status.value === "dirty")
            return DIRTY$1(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$1;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$1;
        if (result.status === "dirty")
          return DIRTY$1(result.value);
        if (status.value === "dirty")
          return DIRTY$1(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$1;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$1;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$1(base))
          return INVALID$1;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$1(base))
            return INVALID$1;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util$1.assertNever(effect);
  }
};
ZodEffects$1.create = (schema, effect, params) => {
  return new ZodEffects$1({
    schema,
    typeName: ZodFirstPartyTypeKind$1.ZodEffects,
    effect,
    ...processCreateParams$1(params)
  });
};
ZodEffects$1.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$1({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$1.ZodEffects,
    ...processCreateParams$1(params)
  });
};
let ZodOptional$1 = class ZodOptional16 extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$1.undefined) {
      return OK$1(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$1.create = (type, params) => {
  return new ZodOptional$1({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$1.ZodOptional,
    ...processCreateParams$1(params)
  });
};
let ZodNullable$1 = class ZodNullable16 extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$1.null) {
      return OK$1(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$1.create = (type, params) => {
  return new ZodNullable$1({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$1.ZodNullable,
    ...processCreateParams$1(params)
  });
};
let ZodDefault$1 = class ZodDefault16 extends ZodType$1 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$1.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$1.create = (type, params) => {
  return new ZodDefault$1({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$1.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$1(params)
  });
};
let ZodCatch$1 = class ZodCatch16 extends ZodType$1 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$1(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$1(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$1(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$1.create = (type, params) => {
  return new ZodCatch$1({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$1.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$1(params)
  });
};
let ZodNaN$1 = class ZodNaN16 extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.nan,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$1.create = (params) => {
  return new ZodNaN$1({
    typeName: ZodFirstPartyTypeKind$1.ZodNaN,
    ...processCreateParams$1(params)
  });
};
let ZodBranded$1 = class ZodBranded16 extends ZodType$1 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$1 = class ZodPipeline16 extends ZodType$1 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$1;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$1(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$1;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline16({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$1.ZodPipeline
    });
  }
};
let ZodReadonly$1 = class ZodReadonly16 extends ZodType$1 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$1(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$1(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$1.create = (type, params) => {
  return new ZodReadonly$1({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$1.ZodReadonly,
    ...processCreateParams$1(params)
  });
};
var ZodFirstPartyTypeKind$1;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$1 || (ZodFirstPartyTypeKind$1 = {}));
const numberType$1 = ZodNumber$1.create;
const booleanType$1 = ZodBoolean$1.create;
ZodNever$1.create;
ZodArray$1.create;
const objectType$1 = ZodObject$1.create;
ZodUnion$1.create;
ZodIntersection$1.create;
ZodTuple$1.create;
ZodEnum$1.create;
ZodPromise$1.create;
ZodOptional$1.create;
ZodNullable$1.create;
const ThresholdOptionsSchema = objectType$1({
  /** A number auto limited between 0 - 255 */
  max: numberType$1().min(0).max(255),
  /** A number auto limited between 0 - 255 (default 255)  */
  replace: numberType$1().min(0).max(255).optional(),
  /** A boolean whether to apply greyscale beforehand (default true)  */
  autoGreyscale: booleanType$1().optional()
});
const methods$1 = {
  /**
   * Applies a minimum color threshold to a grayscale image.
   * Converts image to grayscale by default.
   * @example
   * ```ts
   * import { Jimp } from "jimp";
   *
   * const image = await Jimp.read("test/image.png");
   *
   * image.threshold({ max: 150 });
   * ```
   */
  threshold(image, options) {
    let {
      max,
      replace = 255,
      // eslint-disable-next-line prefer-const
      autoGreyscale = true
    } = ThresholdOptionsSchema.parse(options);
    max = limit255(max);
    replace = limit255(replace);
    if (autoGreyscale) {
      methods$e.greyscale(image);
    }
    image.scan((_, __, idx) => {
      const grey = image.bitmap.data[idx] < max ? image.bitmap.data[idx] : replace;
      image.bitmap.data[idx] = grey;
      image.bitmap.data[idx + 1] = grey;
      image.bitmap.data[idx + 2] = grey;
    });
    return image;
  }
};
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue2 of error.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode.invalid_type:
      if (issue2.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue2);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue2 = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue2);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x2) => x2.status === "aborted";
const isDirty = (x2) => x2.status === "dirty";
const isValid = (x2) => x2.status === "valid";
const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: (params == null ? void 0 : params.async) ?? false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (options == null ? void 0 : options.offset) ?? false,
      local: (options == null ? void 0 : options.local) ?? false,
      ...errorUtil.errToObj(options == null ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      ...errorUtil.errToObj(options == null ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position,
      ...errorUtil.errToObj(options == null ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          var _a, _b;
          const defaultError = ((_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue2, ctx).message) ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), errorMap].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), errorMap].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
const z = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BRAND,
  DIRTY,
  EMPTY_PATH,
  INVALID,
  NEVER,
  OK,
  ParseStatus,
  Schema: ZodType,
  ZodAny,
  ZodArray,
  ZodBigInt,
  ZodBoolean,
  ZodBranded,
  ZodCatch,
  ZodDate,
  ZodDefault,
  ZodDiscriminatedUnion,
  ZodEffects,
  ZodEnum,
  ZodError,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  ZodFunction,
  ZodIntersection,
  ZodIssueCode,
  ZodLazy,
  ZodLiteral,
  ZodMap,
  ZodNaN,
  ZodNativeEnum,
  ZodNever,
  ZodNull,
  ZodNullable,
  ZodNumber,
  ZodObject,
  ZodOptional,
  ZodParsedType,
  ZodPipeline,
  ZodPromise,
  ZodReadonly,
  ZodRecord,
  ZodSchema: ZodType,
  ZodSet,
  ZodString,
  ZodSymbol,
  ZodTransformer: ZodEffects,
  ZodTuple,
  ZodType,
  ZodUndefined,
  ZodUnion,
  ZodUnknown,
  ZodVoid,
  addIssueToContext,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  coerce,
  custom,
  date: dateType,
  datetimeRegex,
  defaultErrorMap: errorMap,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  getErrorMap,
  getParsedType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  isAborted,
  isAsync,
  isDirty,
  isValid,
  late,
  lazy: lazyType,
  literal: literalType,
  makeIssue,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  get objectUtil() {
    return objectUtil;
  },
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  quotelessJson,
  record: recordType,
  set: setType,
  setErrorMap,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  get util() {
    return util;
  },
  void: voidType
}, Symbol.toStringTag, { value: "Module" }));
const QuantizeOptionsSchema = z.object({
  colors: z.number().optional(),
  colorDistanceFormula: z.union([
    z.literal("cie94-textiles"),
    z.literal("cie94-graphic-arts"),
    z.literal("ciede2000"),
    z.literal("color-metric"),
    z.literal("euclidean"),
    z.literal("euclidean-bt709-noalpha"),
    z.literal("euclidean-bt709"),
    z.literal("manhattan"),
    z.literal("manhattan-bt709"),
    z.literal("manhattan-nommyde"),
    z.literal("pngquant")
  ]).optional(),
  paletteQuantization: z.union([
    z.literal("neuquant"),
    z.literal("neuquant-float"),
    z.literal("rgbquant"),
    z.literal("wuquant")
  ]).optional(),
  imageQuantization: z.union([
    z.literal("nearest"),
    z.literal("riemersma"),
    z.literal("floyd-steinberg"),
    z.literal("false-floyd-steinberg"),
    z.literal("stucki"),
    z.literal("atkinson"),
    z.literal("jarvis"),
    z.literal("burkes"),
    z.literal("sierra"),
    z.literal("two-sierra"),
    z.literal("sierra-lite")
  ]).optional()
});
const methods = {
  /**
   * Image color number reduction.
   */
  quantize(image, options) {
    const { colors, colorDistanceFormula, paletteQuantization, imageQuantization } = QuantizeOptionsSchema.parse(options);
    const inPointContainer = utils_exports.PointContainer.fromUint8Array(image.bitmap.data, image.bitmap.width, image.bitmap.height);
    const palette = buildPaletteSync([inPointContainer], {
      colors,
      colorDistanceFormula,
      paletteQuantization
    });
    const outPointContainer = applyPaletteSync(inPointContainer, palette, {
      colorDistanceFormula,
      imageQuantization
    });
    image.bitmap.data = Buffer.from(outPointContainer.toUint8Array());
    return image;
  }
};
const defaultPlugins = [
  methods$h,
  methods$g,
  methods$f,
  methods$e,
  methods$c,
  methods$a,
  methods$b,
  methods$9,
  methods$8,
  methods$7,
  methods$6,
  methods$5,
  methods$4,
  methods$3,
  methods$d,
  methods$2,
  methods$1,
  methods
];
const defaultFormats = [bmp, msBmp, gif, jpeg$2, png, tiff];
({
  bmp: bmp().mime,
  gif: gif().mime,
  jpeg: jpeg$2().mime,
  png: png().mime,
  tiff: tiff().mime
});
const Jimp = createJimp({
  formats: defaultFormats,
  plugins: defaultPlugins
});
async function ensureSquarePng(srcPath) {
  if (path.extname(srcPath).toLowerCase() !== ".png") {
    throw new Error("Thumbnail must be a PNG (.png)");
  }
  const img = await Jimp.read(srcPath);
  const w = img.width;
  const h = img.height;
  if (typeof w !== "number" || typeof h !== "number") {
    throw new Error("Could not read image dimensions");
  }
  if (w !== h) {
    throw new Error(`Thumbnail must be square (got ${w}x${h})`);
  }
}
async function copyThumbnailTo(outDir, srcPath, assetId) {
  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });
  await ensureSquarePng(srcPath);
  const dst = path.join(outDir, `${assetId}.png`);
  fs.copyFileSync(srcPath, dst);
  return dst;
}
async function exportProjectAsHWJsonSingle(p, projectDir, outDir) {
  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });
  const thumbsOut = path.join(outDir, "thumbnails");
  if (!fs.existsSync(thumbsOut)) fs.mkdirSync(thumbsOut, { recursive: true });
  const seen = /* @__PURE__ */ new Set();
  const items = p.items.filter((i) => {
    const ok = i.assetId && !seen.has(i.assetId);
    if (ok) seen.add(i.assetId);
    return ok;
  });
  const recipes = p.recipes.filter(
    (r) => r.resultAssetId && r.ingredients.every((g) => !!g.assetId)
  );
  for (const it of items) {
    if (it.thumbnailPath) {
      const abs = path.resolve(projectDir, it.thumbnailPath);
      if (fs.existsSync(abs)) await copyThumbnailTo(thumbsOut, abs, it.assetId);
    }
  }
  const payload = {
    items: items.map((i) => ({
      assetId: i.assetId,
      name: i.name,
      type: i.type,
      vendorPrice: i.vendorPrice,
      tags: i.tags
    }))
  };
  const payload2 = {
    recipes: recipes.map((r) => ({
      resultAssetId: r.resultAssetId,
      ingredients: r.ingredients
    }))
  };
  const database = JSON.stringify({
    v: 1,
    items: payload.items,
    recipes: payload2.recipes
  });
  const databaseFile = path.join(outDir, "database.txt");
  fs.writeFileSync(databaseFile, database);
  return { outDir, databaseFile, thumbnailsDir: thumbsOut };
}
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
process.env.DIST_ELECTRON = __dirname;
process.env.DIST = join(__dirname, "../dist");
process.env.PUBLIC = process.env.VITE_DEV_SERVER_URL ? join(__dirname, "../public") : process.env.DIST;
let win = null;
function setMenu() {
  const isMac = process.platform === "darwin";
  const template = [
    ...isMac ? [
      {
        label: "Item World Database",
        submenu: [
          { role: "about" },
          { type: "separator" },
          { role: "services" },
          { type: "separator" },
          { role: "hide" },
          { role: "hideOthers" },
          { role: "unhide" },
          { type: "separator" },
          { role: "quit" }
        ]
      }
    ] : [],
    { role: "fileMenu" },
    {
      label: "Help",
      submenu: [
        {
          label: "ItemWorld GitHub",
          click: () => shell.openExternal("https://github.com/todd-roberts/ItemWorld")
        }
      ]
    }
  ];
  Menu.setApplicationMenu(Menu.buildFromTemplate(template));
}
async function createWindow() {
  setMenu();
  const preload = join(__dirname, "preload.js");
  const url = process.env.VITE_DEV_SERVER_URL;
  const indexHtml = join(process.env.DIST, "index.html");
  win = new BrowserWindow({
    title: "Item World Database",
    width: 1400,
    height: 900,
    webPreferences: { preload }
  });
  if (url) await win.loadURL(url);
  else await win.loadFile(indexHtml);
  win.setTitle("Item World Database");
}
app.whenReady().then(createWindow).catch(console.error);
app.on("activate", () => {
  if (BrowserWindow.getAllWindows().length === 0) createWindow();
});
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") app.quit();
});
ipcMain.handle("project:getDefault", async () => {
  const base = app.getPath("userData");
  const dir = path.join(base, "ItemWorldProject");
  ensureProject(dir);
  return dir;
});
ipcMain.handle("project:open", async () => {
  const res = await dialog.showOpenDialog({
    properties: ["openDirectory", "createDirectory"]
  });
  if (res.canceled || res.filePaths.length === 0) return null;
  const dir = res.filePaths[0];
  ensureProject(dir);
  return dir;
});
ipcMain.handle("project:load", async (_e, dir) => loadProject(dir));
ipcMain.handle("project:save", async (_e, dir, data) => {
  saveProject(dir, data);
  return true;
});
ipcMain.handle("thumb:add", async (_e, projectDir, srcPath) => {
  await ensureSquarePng(srcPath);
  const thumbs = projectThumbsDir(projectDir);
  if (!fs.existsSync(thumbs)) fs.mkdirSync(thumbs, { recursive: true });
  const base = path.basename(srcPath);
  const dst = path.join(thumbs, base);
  fs.copyFileSync(srcPath, dst);
  return path.relative(projectDir, dst).replace(/\\/g, "/");
});
ipcMain.handle("export:hw", async (_e, projectDir) => {
  const p = loadProject(projectDir);
  const outDir = path.join(projectDir, "exports", "hw");
  return exportProjectAsHWJsonSingle(p, projectDir, outDir);
});
